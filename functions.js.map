{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-ai-gemini-addin/./src/shared/core.js","webpack://excel-ai-gemini-addin/./src/shared/providers.js","webpack://excel-ai-gemini-addin/./src/functions/functions.js"],"sourcesContent":["// src/shared/core.js\n// Shared utilities + persisted configuration for the Neurow add-in.\n//\n// Key design goals:\n// - Two providers (Gemini + OpenAI) can coexist.\n// - The default provider is chosen in the taskpane (not in formulas).\n// - No temperature / sampling controls anywhere (per requirements).\n// - A single \"max output tokens\" setting applies to both providers.\n\nexport const PROVIDERS = Object.freeze({\n  GEMINI: \"gemini\",\n  OPENAI: \"openai\"\n});\n\nexport const DEFAULTS = Object.freeze({\n  provider: PROVIDERS.GEMINI,\n  // Default models (User specified future versions)\n  geminiModel: \"gemini-3-flash-preview\",\n  openaiModel: \"gpt-5-mini\",\n  geminiReasoningEffort: \"minimal\",\n  openaiReasoningEffort: \"low\",\n  maxOutputTokens: 4096,\n  concurrencyLimit: 4,\n  rpmLimit: 0,\n\n  // Execution / UX\n  retry: 2,\n  timeoutMs: 120000,\n\n  // In-memory cache (per runtime). Note: Office custom functions can run in a long-lived runtime.\n  cache: true,\n  cacheTtlSec: 7 * 24 * 3600 // 7 days\n});\n\nconst STORAGE_KEYS = Object.freeze({\n  DEFAULT_PROVIDER: \"AI_DEFAULT_PROVIDER_V3\",\n  GEMINI_API_KEY: \"AI_GEMINI_API_KEY_V3\",\n  OPENAI_API_KEY: \"AI_OPENAI_API_KEY_V3\",\n  GEMINI_MODEL: \"AI_GEMINI_MODEL_V3\",\n  OPENAI_MODEL: \"AI_OPENAI_MODEL_V3\",\n  GEMINI_REASONING_EFFORT: \"AI_GEMINI_REASONING_EFFORT_V3\",\n  OPENAI_REASONING_EFFORT: \"AI_OPENAI_REASONING_EFFORT_V3\",\n  MAX_OUTPUT_TOKENS: \"AI_MAX_OUTPUT_TOKENS_V3\",\n  CONCURRENCY_LIMIT: \"AI_CONCURRENCY_LIMIT_V1\",\n  RPM_LIMIT: \"AI_RPM_LIMIT_V1\",\n  ONBOARDING_SEEN: \"AI_ONBOARDING_SEEN_V1\",\n  ONBOARDING_KEYS_CONFIRMED: \"AI_ONBOARDING_KEYS_CONFIRMED_V1\",\n  SECTION_ORDER: \"AI_SECTION_ORDER_V1\",\n  SECTION_HIDDEN: \"AI_SECTION_HIDDEN_V1\",\n  LICENSE: \"AI_LICENSE_V1\",\n  PRIVACY_MODE: \"AI_PRIVACY_MODE_V1\",\n\n  // Prevent re-running migrations each time.\n  MIGRATION_DONE: \"AI_MIGRATION_DONE_V3\",\n\n  // Diagnostics + cache metadata\n  REQUEST_LOG: \"AI_REQUEST_LOG_V1\",\n  REQUEST_LOG_CLEAR_AT: \"AI_REQUEST_LOG_CLEAR_AT_V1\",\n  USAGE_TOTALS: \"AI_USAGE_TOTALS_V1\",\n  CACHE_INDEX: \"AI_CACHE_INDEX_V1\",\n  CACHE_CLEAR_AT: \"AI_CACHE_CLEAR_AT_V1\",\n  RUNTIME_STATUS: \"AI_RUNTIME_STATUS_V1\"\n});\n\nconst SENSITIVE_KEYS = new Set([STORAGE_KEYS.GEMINI_API_KEY, STORAGE_KEYS.OPENAI_API_KEY, STORAGE_KEYS.LICENSE]);\n\n// Older keys used by previous versions (best-effort migration).\nconst LEGACY_KEYS = Object.freeze({\n  GEMINI_API_KEY: \"GEMINI_API_KEY\",\n  MAX_OUTPUT_TOKENS: \"MAX_OUTPUT_TOKENS\",\n\n  DEFAULT_PROVIDER_V2: \"AI_DEFAULT_PROVIDER_V2\",\n  GEMINI_API_KEY_V2: \"AI_GEMINI_API_KEY_V2\",\n  OPENAI_API_KEY_V2: \"AI_OPENAI_API_KEY_V2\",\n  GEMINI_MODEL_V2: \"AI_GEMINI_MODEL_V2\",\n  OPENAI_MODEL_V2: \"AI_OPENAI_MODEL_V2\",\n\n  GEMINI_MAX_TOKENS_V2: \"AI_GEMINI_MAX_OUTPUT_TOKENS_V2\",\n  OPENAI_MAX_TOKENS_V2: \"AI_OPENAI_MAX_OUTPUT_TOKENS_V2\"\n});\n\nlet _migrationPromise = null;\nlet _officeStorageFailed = false;\nlet _privacyModeCache = null;\nlet _privacyModeCacheAt = 0;\nconst SETTINGS_CACHE_TTL_MS = 1500;\nlet _defaultProviderCache = null;\nlet _defaultProviderCacheAt = 0;\nlet _maxOutputTokensCache = null;\nlet _maxOutputTokensCacheAt = 0;\nlet _geminiReasoningCache = null;\nlet _geminiReasoningCacheAt = 0;\nlet _openaiReasoningCache = null;\nlet _openaiReasoningCacheAt = 0;\nconst _apiKeyCache = { gemini: null, openai: null };\nconst _apiKeyCacheAt = { gemini: 0, openai: 0 };\nconst _modelCache = { gemini: null, openai: null };\nconst _modelCacheAt = { gemini: 0, openai: 0 };\n\nfunction markOfficeStorageFailed() {\n  _officeStorageFailed = true;\n}\n\nfunction isSensitiveKey(key) {\n  return SENSITIVE_KEYS.has(key);\n}\n\nconst MEMORY_STORAGE = {\n  kind: \"memory\",\n  storage: (() => {\n    const mem = new Map();\n    return {\n      async getItem(k) {\n        return mem.has(k) ? mem.get(k) : null;\n      },\n      async setItem(k, v) {\n        mem.set(k, String(v));\n      },\n      async removeItem(k) {\n        mem.delete(k);\n      }\n    };\n  })()\n};\n\nfunction getRuntimeStorage() {\n  if (!_officeStorageFailed) {\n    try {\n      if (typeof OfficeRuntime !== \"undefined\" && OfficeRuntime?.storage?.getItem) {\n        return { kind: \"office\", storage: OfficeRuntime.storage };\n      }\n    } catch {\n      // ignore\n    }\n  }\n\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return { kind: \"local\", storage: window.localStorage };\n    }\n  } catch {\n    // ignore\n  }\n\n  // Extremely defensive fallback (in-memory only, persisted for this session).\n  return MEMORY_STORAGE;\n}\n\nfunction getLocalStorageSafe() {\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return window.localStorage;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nfunction localGet(local, key) {\n  try {\n    return local.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nfunction localSet(local, key, value) {\n  try {\n    local.setItem(key, value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction localRemove(local, key) {\n  try {\n    local.removeItem(key);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function storageBackendName() {\n  return getRuntimeStorage().kind;\n}\n\nasync function rawGet(key, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const sensitive = options.sensitive ?? isSensitiveKey(key);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    return localGet(storage, key);\n  }\n\n  if (kind === \"office\") {\n    let result = null;\n    try {\n      result = await storage.getItem(key);\n    } catch {\n      markOfficeStorageFailed();\n    }\n    if (result != null) {\n      if (sensitive) {\n        const local = getLocalStorageSafe();\n        if (local) localRemove(local, key);\n      }\n      return result;\n    }\n    if (!allowLocalFallback) return null;\n\n    const local = getLocalStorageSafe();\n    if (!local) return null;\n    const localValue = localGet(local, key);\n    if (localValue == null) return null;\n\n    if (!_officeStorageFailed) {\n      try {\n        await storage.setItem(key, String(localValue));\n        localRemove(local, key);\n      } catch {\n        markOfficeStorageFailed();\n      }\n    }\n\n    return localValue;\n  }\n\n  try {\n    return await storage.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nasync function rawSet(key, value, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const v = value == null ? \"\" : String(value);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    localSet(storage, key, v);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let stored = false;\n    try {\n      await storage.setItem(key, v);\n      stored = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (stored) {\n      if (local) localRemove(local, key);\n      return;\n    }\n\n    if (!allowLocalFallback || !local) return;\n    localSet(local, key, v);\n    return;\n  }\n\n  try {\n    await storage.setItem(key, v);\n  } catch {\n    // ignore\n  }\n}\n\nasync function rawRemove(key) {\n  const { kind, storage } = getRuntimeStorage();\n\n  if (kind === \"local\") {\n    localRemove(storage, key);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let removed = false;\n    try {\n      await storage.removeItem(key);\n      removed = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (local) localRemove(local, key);\n    return;\n  }\n\n  try {\n    await storage.removeItem(key);\n  } catch {\n    // ignore\n  }\n}\n\nasync function ensureMigrated() {\n  if (_migrationPromise) return _migrationPromise;\n\n  _migrationPromise = (async () => {\n    // Fast exit if already migrated\n    const done = await rawGet(STORAGE_KEYS.MIGRATION_DONE);\n    if (done === \"1\") return;\n\n    // Migrate provider\n    const currentProvider = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n    if (!currentProvider) {\n      const legacyProvider = normalizeProvider(await rawGet(LEGACY_KEYS.DEFAULT_PROVIDER_V2));\n      await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, legacyProvider || DEFAULTS.provider);\n    }\n\n    // Migrate keys\n    const gKey = await rawGet(STORAGE_KEYS.GEMINI_API_KEY);\n    if (!gKey) {\n      const legacy = (await rawGet(LEGACY_KEYS.GEMINI_API_KEY_V2)) || (await rawGet(LEGACY_KEYS.GEMINI_API_KEY));\n      if (legacy) await rawSet(STORAGE_KEYS.GEMINI_API_KEY, legacy);\n    }\n\n    const oKey = await rawGet(STORAGE_KEYS.OPENAI_API_KEY);\n    if (!oKey) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_API_KEY_V2);\n      if (legacy) await rawSet(STORAGE_KEYS.OPENAI_API_KEY, legacy);\n    }\n\n    // Migrate models\n    const gModel = await rawGet(STORAGE_KEYS.GEMINI_MODEL);\n    if (!gModel) {\n      const legacy = await rawGet(LEGACY_KEYS.GEMINI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.GEMINI_MODEL, legacy || DEFAULTS.geminiModel);\n    }\n\n    const oModel = await rawGet(STORAGE_KEYS.OPENAI_MODEL);\n    if (!oModel) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.OPENAI_MODEL, legacy || DEFAULTS.openaiModel);\n    }\n\n    // Migrate max tokens (unified)\n    const tok = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n    if (!tok) {\n      const legacyUnified = await rawGet(LEGACY_KEYS.MAX_OUTPUT_TOKENS);\n      const legacyGem = await rawGet(LEGACY_KEYS.GEMINI_MAX_TOKENS_V2);\n      const legacyOai = await rawGet(LEGACY_KEYS.OPENAI_MAX_TOKENS_V2);\n\n      const candidates = [legacyUnified, legacyGem, legacyOai]\n        .map((x) => parseInt(String(x || \"\").trim(), 10))\n        .filter((n) => Number.isFinite(n) && n > 0);\n\n      const migrated = candidates.length ? Math.max(...candidates) : DEFAULTS.maxOutputTokens;\n      await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(migrated));\n    }\n\n    await rawSet(STORAGE_KEYS.MIGRATION_DONE, \"1\");\n  })();\n\n  try {\n    await _migrationPromise;\n  } finally {\n    _migrationPromise = null;\n  }\n}\n\nexport function normalizeProvider(p) {\n  if (!p) return \"\";\n  const s = String(p).trim().toLowerCase();\n  if (s === PROVIDERS.GEMINI) return PROVIDERS.GEMINI;\n  if (s === PROVIDERS.OPENAI) return PROVIDERS.OPENAI;\n  // Common aliases (defensive)\n  if (s === \"google\" || s === \"gem\") return PROVIDERS.GEMINI;\n  if (s === \"oai\" || s === \"chatgpt\") return PROVIDERS.OPENAI;\n  return \"\";\n}\n\nconst GEMINI_REASONING_EFFORTS = new Set([\"auto\", \"minimal\", \"low\", \"medium\", \"high\"]);\nconst OPENAI_REASONING_EFFORTS = new Set([\"none\", \"minimal\", \"low\", \"medium\", \"high\"]);\n\nfunction normalizeGeminiReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.geminiReasoningEffort;\n  return GEMINI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.geminiReasoningEffort;\n}\n\nfunction normalizeReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.openaiReasoningEffort;\n  return OPENAI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.openaiReasoningEffort;\n}\n\nexport async function getDefaultProvider() {\n  const now = nowMs();\n  if (_defaultProviderCache && now - _defaultProviderCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _defaultProviderCache;\n  }\n  await ensureMigrated();\n  const p = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER)) || DEFAULTS.provider;\n  _defaultProviderCache = p;\n  _defaultProviderCacheAt = now;\n  return p;\n}\n\nexport async function setDefaultProvider(provider) {\n  const p = normalizeProvider(provider) || DEFAULTS.provider;\n  await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, p);\n  _defaultProviderCache = p;\n  _defaultProviderCacheAt = nowMs();\n  return p;\n}\n\nfunction keyKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_API_KEY;\n  return STORAGE_KEYS.GEMINI_API_KEY;\n}\n\nexport async function getApiKey(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const now = nowMs();\n  if (_apiKeyCache[p] != null && now - _apiKeyCacheAt[p] < SETTINGS_CACHE_TTL_MS) {\n    return (_apiKeyCache[p] || \"\").trim();\n  }\n  await ensureMigrated();\n  const k = (await rawGet(keyKey(p))) || \"\";\n  const trimmed = String(k).trim();\n  _apiKeyCache[p] = trimmed;\n  _apiKeyCacheAt[p] = now;\n  return trimmed;\n}\n\nexport async function hasApiKey(provider) {\n  const k = await getApiKey(provider);\n  return !!k;\n}\n\nexport async function setApiKey(provider, apiKey) {\n  const k = (apiKey || \"\").trim();\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  await rawSet(keyKey(p), k);\n  _apiKeyCache[p] = k;\n  _apiKeyCacheAt[p] = nowMs();\n  return k;\n}\n\nexport async function clearApiKey(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  await rawRemove(keyKey(p));\n  _apiKeyCache[p] = \"\";\n  _apiKeyCacheAt[p] = nowMs();\n}\n\nfunction modelKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_MODEL;\n  return STORAGE_KEYS.GEMINI_MODEL;\n}\n\nexport async function getModel(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const now = nowMs();\n  const cached = _modelCache[p];\n  if (cached && now - _modelCacheAt[p] < SETTINGS_CACHE_TTL_MS) return cached;\n  await ensureMigrated();\n  const raw = await rawGet(modelKey(p));\n  const resolved = (raw && String(raw).trim())\n    ? String(raw).trim()\n    : (p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel);\n  _modelCache[p] = resolved;\n  _modelCacheAt[p] = now;\n  return resolved;\n}\n\nexport async function getGeminiReasoningEffort() {\n  const now = nowMs();\n  if (_geminiReasoningCache && now - _geminiReasoningCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _geminiReasoningCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.GEMINI_REASONING_EFFORT);\n  const v = normalizeGeminiReasoningEffort(raw || DEFAULTS.geminiReasoningEffort);\n  _geminiReasoningCache = v;\n  _geminiReasoningCacheAt = now;\n  return v;\n}\n\nexport async function getOpenAIReasoningEffort() {\n  const now = nowMs();\n  if (_openaiReasoningCache && now - _openaiReasoningCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _openaiReasoningCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.OPENAI_REASONING_EFFORT);\n  const v = normalizeReasoningEffort(raw || DEFAULTS.openaiReasoningEffort);\n  _openaiReasoningCache = v;\n  _openaiReasoningCacheAt = now;\n  return v;\n}\n\nexport async function setModel(provider, model) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const v = String(model || \"\").trim();\n  if (!v) {\n    // Reset to default if emptied\n    const fallback = p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel;\n    await rawSet(modelKey(p), fallback);\n    _modelCache[p] = fallback;\n    _modelCacheAt[p] = nowMs();\n    return;\n  }\n  await rawSet(modelKey(p), v);\n  _modelCache[p] = v;\n  _modelCacheAt[p] = nowMs();\n}\n\nexport async function setOpenAIReasoningEffort(value) {\n  const v = normalizeReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.OPENAI_REASONING_EFFORT, v);\n  _openaiReasoningCache = v;\n  _openaiReasoningCacheAt = nowMs();\n  return v;\n}\n\nexport async function setGeminiReasoningEffort(value) {\n  const v = normalizeGeminiReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.GEMINI_REASONING_EFFORT, v);\n  _geminiReasoningCache = v;\n  _geminiReasoningCacheAt = nowMs();\n  return v;\n}\n\nexport async function getMaxOutputTokens() {\n  const now = nowMs();\n  if (_maxOutputTokensCache && now - _maxOutputTokensCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _maxOutputTokensCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  const v = clampInt(n, 1, 128000, DEFAULTS.maxOutputTokens);\n  _maxOutputTokensCache = v;\n  _maxOutputTokensCacheAt = now;\n  return v;\n}\n\nexport async function setMaxOutputTokens(value) {\n  const n = clampInt(value, 1, 128000, DEFAULTS.maxOutputTokens);\n  await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(n));\n  _maxOutputTokensCache = n;\n  _maxOutputTokensCacheAt = nowMs();\n  return n;\n}\n\nconst CONCURRENCY_OPTIONS = [4, 8, 16, 32, 64, 128];\n\nfunction normalizeConcurrencyLimit(value) {\n  const base = clampInt(\n    value,\n    CONCURRENCY_OPTIONS[0],\n    CONCURRENCY_OPTIONS[CONCURRENCY_OPTIONS.length - 1],\n    DEFAULTS.concurrencyLimit\n  );\n  if (CONCURRENCY_OPTIONS.includes(base)) return base;\n  let best = CONCURRENCY_OPTIONS[0];\n  let bestDiff = Math.abs(base - best);\n  for (const option of CONCURRENCY_OPTIONS.slice(1)) {\n    const diff = Math.abs(base - option);\n    if (diff < bestDiff) {\n      best = option;\n      bestDiff = diff;\n    }\n  }\n  return best;\n}\n\nexport async function getConcurrencyLimit() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.CONCURRENCY_LIMIT);\n  return normalizeConcurrencyLimit(raw);\n}\n\nexport async function setConcurrencyLimit(value) {\n  const normalized = normalizeConcurrencyLimit(value);\n  await rawSet(STORAGE_KEYS.CONCURRENCY_LIMIT, String(normalized));\n  return normalized;\n}\n\nconst RPM_MIN = 0;\nconst RPM_MAX = 100000;\n\nfunction normalizeRpmLimit(value) {\n  const n = typeof value === \"string\" ? parseInt(value.trim(), 10) : Number(value);\n  return clampInt(n, RPM_MIN, RPM_MAX, DEFAULTS.rpmLimit);\n}\n\nexport async function getRpmLimit() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.RPM_LIMIT);\n  return normalizeRpmLimit(raw);\n}\n\nexport async function setRpmLimit(value) {\n  const normalized = normalizeRpmLimit(value);\n  await rawSet(STORAGE_KEYS.RPM_LIMIT, String(normalized));\n  return normalized;\n}\n\nexport async function getOnboardingSeen() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_SEEN);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingSeen(seen = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_SEEN, seen ? \"1\" : \"0\");\n  return seen;\n}\n\nexport async function getOnboardingKeysConfirmed() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingKeysConfirmed(confirmed = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED, confirmed ? \"1\" : \"0\");\n  return confirmed;\n}\n\nfunction normalizeRuntimeStatus(raw) {\n  const base = { active: 0, queued: 0, rpm: 0, ts: 0 };\n  if (!raw || typeof raw !== \"object\") return base;\n  const active = clampInt(raw.active, 0, 100000, 0);\n  const queued = clampInt(raw.queued, 0, 100000, 0);\n  const rpm = clampInt(raw.rpm, 0, 1000000, 0);\n  const ts = clampInt(raw.ts, 0, Number.MAX_SAFE_INTEGER, 0);\n  return { active, queued, rpm, ts };\n}\n\nexport async function getRuntimeStatus() {\n  const raw = await rawGet(STORAGE_KEYS.RUNTIME_STATUS);\n  if (!raw) return normalizeRuntimeStatus(null);\n  try {\n    return normalizeRuntimeStatus(JSON.parse(raw));\n  } catch {\n    return normalizeRuntimeStatus(null);\n  }\n}\n\nexport async function setRuntimeStatus(status) {\n  const normalized = normalizeRuntimeStatus(status);\n  await rawSet(STORAGE_KEYS.RUNTIME_STATUS, JSON.stringify(normalized));\n  return normalized;\n}\n\nconst PRIVACY_MODE_CACHE_TTL_MS = 2000;\n\nasync function loadPrivacyMode() {\n  const now = nowMs();\n  if (_privacyModeCache != null && now - _privacyModeCacheAt < PRIVACY_MODE_CACHE_TTL_MS) {\n    return _privacyModeCache;\n  }\n  const raw = await rawGet(STORAGE_KEYS.PRIVACY_MODE);\n  const enabled = raw === \"1\";\n  _privacyModeCache = enabled;\n  _privacyModeCacheAt = now;\n  return enabled;\n}\n\nexport async function getPrivacyMode() {\n  return await loadPrivacyMode();\n}\n\nexport async function setPrivacyMode(enabled = false) {\n  const next = !!enabled;\n  _privacyModeCache = next;\n  _privacyModeCacheAt = nowMs();\n  await rawSet(STORAGE_KEYS.PRIVACY_MODE, next ? \"1\" : \"0\");\n  return next;\n}\n\nfunction normalizeSectionList(value) {\n  if (!Array.isArray(value)) return [];\n  const out = [];\n  const seen = new Set();\n  for (const item of value) {\n    const key = String(item || \"\").trim();\n    if (!key || seen.has(key)) continue;\n    seen.add(key);\n    out.push(key);\n  }\n  return out;\n}\n\nexport async function getSectionOrder() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_ORDER);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setSectionOrder(order) {\n  const normalized = normalizeSectionList(order);\n  await rawSet(STORAGE_KEYS.SECTION_ORDER, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getHiddenSections() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_HIDDEN);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setHiddenSections(list) {\n  const normalized = normalizeSectionList(list);\n  await rawSet(STORAGE_KEYS.SECTION_HIDDEN, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getLicense() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.LICENSE);\n  if (!raw) return null;\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}\n\nexport async function setLicense(license) {\n  if (!license) {\n    await rawRemove(STORAGE_KEYS.LICENSE);\n    return null;\n  }\n  await rawSet(STORAGE_KEYS.LICENSE, JSON.stringify(license));\n  return license;\n}\n\nexport async function clearLicense() {\n  await rawRemove(STORAGE_KEYS.LICENSE);\n}\n\n// ---------- Small utilities ----------\nexport function nowMs() {\n  return Date.now();\n}\n\nexport function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function clamp(value, min, max, fallback = min) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nexport function clampInt(value, min, max, fallback = min) {\n  const n = parseInt(String(value), 10);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nconst REDACT_PATTERNS = [\n  /\\bsk-[A-Za-z0-9-_]{1,}\\b/gi,\n  /\\bAIza[0-9A-Za-z_-]{1,}\\b/gi,\n  /\\b[A-Z0-9]{4}(?:-[A-Z0-9]{4}){1,3}\\b/gi\n];\n\nexport function redactSensitiveText(value) {\n  if (value == null) return \"\";\n  let text = String(value);\n  for (const pattern of REDACT_PATTERNS) {\n    text = text.replace(pattern, \"[REDACTED]\");\n  }\n  return text;\n}\n\nexport function redactSensitiveValue(value) {\n  if (value == null) return value;\n  if (typeof value === \"string\") return redactSensitiveText(value);\n  if (Array.isArray(value)) return value.map(redactSensitiveValue);\n  if (typeof value === \"object\") {\n    const out = {};\n    for (const [key, entry] of Object.entries(value)) {\n      out[key] = redactSensitiveValue(entry);\n    }\n    return out;\n  }\n  return value;\n}\n\nfunction parseTimestampMs(raw) {\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return Number.isFinite(n) && n > 0 ? n : 0;\n}\n\n// ---------- LRU cache with TTL ----------\nexport class LRUCache {\n  constructor(maxEntries = 500) {\n    this.maxEntries = maxEntries;\n    this.map = new Map(); // key => {value, expiresAtMs}\n  }\n\n  get(key) {\n    if (!this.map.has(key)) return null;\n    const entry = this.map.get(key);\n\n    if (entry?.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      this.map.delete(key);\n      return null;\n    }\n\n    // Refresh key order (most recent)\n    this.map.delete(key);\n    this.map.set(key, entry);\n    return entry.value;\n  }\n\n  set(key, value, ttlMs) {\n    const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? nowMs() + ttlMs : null;\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, { value, expiresAtMs });\n\n    // Evict LRU\n    while (this.map.size > this.maxEntries) {\n      const oldestKey = this.map.keys().next().value;\n      this.map.delete(oldestKey);\n    }\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\n// ---------- Persistent cache (survives reloads) ----------\nconst CACHE_ENTRY_PREFIX = \"AI_CACHE_ENTRY_V1:\";\nconst CACHE_INDEX_MAX_ENTRIES = 5000;\nconst CACHE_INDEX_MAX_BYTES = 5 * 1024 * 1024;\nlet _cacheClearMs = 0;\n\nfunction estimateSizeBytes(value) {\n  if (typeof value !== \"string\") return 0;\n  try {\n    if (typeof TextEncoder !== \"undefined\") {\n      return new TextEncoder().encode(value).length;\n    }\n  } catch {\n    // ignore and fallback\n  }\n  return value.length;\n}\n\nasync function syncCacheClearMarker() {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.CACHE_CLEAR_AT));\n  if (clearedAt > _cacheClearMs) _cacheClearMs = clearedAt;\n  return _cacheClearMs;\n}\n\nexport async function getCacheClearAt() {\n  return await syncCacheClearMarker();\n}\n\nasync function loadCacheIndex() {\n  const raw = await rawGet(STORAGE_KEYS.CACHE_INDEX);\n  if (!raw) return [];\n  try {\n    const arr = JSON.parse(raw);\n    return Array.isArray(arr) ? arr : [];\n  } catch {\n    return [];\n  }\n}\n\nasync function saveCacheIndex(entries) {\n  try {\n    await rawSet(STORAGE_KEYS.CACHE_INDEX, JSON.stringify(entries));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneCacheIndex(entries, clearedAt = 0) {\n  const now = nowMs();\n  const kept = [];\n  const removedKeys = [];\n\n  for (const entry of entries || []) {\n    if (!entry || !entry.key) continue;\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= now) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    kept.push(entry);\n  }\n\n  let totalSize = 0;\n  for (const entry of kept) totalSize += Number(entry?.size || 0);\n\n  if (kept.length > CACHE_INDEX_MAX_ENTRIES || totalSize > CACHE_INDEX_MAX_BYTES) {\n    kept.sort((a, b) => (a.savedAtMs || 0) - (b.savedAtMs || 0));\n    let dropCount = 0;\n    while (kept.length - dropCount > CACHE_INDEX_MAX_ENTRIES || totalSize > CACHE_INDEX_MAX_BYTES) {\n      const entry = kept[dropCount];\n      if (!entry) break;\n      removedKeys.push(entry.key);\n      totalSize -= Number(entry?.size || 0);\n      dropCount += 1;\n    }\n    return { list: kept.slice(dropCount), removedKeys };\n  }\n\n  return { list: kept, removedKeys };\n}\n\nasync function removeCacheEntry(key) {\n  if (!key) return;\n  await rawRemove(CACHE_ENTRY_PREFIX + key);\n}\n\nasync function removeFromCacheIndex(key) {\n  const index = await loadCacheIndex();\n  const next = (index || []).filter((item) => item?.key !== key);\n  if (next.length !== index.length) await saveCacheIndex(next);\n}\n\nexport async function getPersistentCache(cacheKey) {\n  if (!cacheKey) return null;\n  if (await getPrivacyMode()) return null;\n  const clearedAt = await syncCacheClearMarker();\n  const raw = await rawGet(CACHE_ENTRY_PREFIX + cacheKey);\n  if (!raw) {\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n\n  try {\n    const entry = JSON.parse(raw);\n    if (!entry || typeof entry !== \"object\") throw new Error(\"Invalid entry\");\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    return entry.value || null;\n  } catch {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n}\n\nexport async function setPersistentCache(cacheKey, value, ttlMs, meta = {}) {\n  if (!cacheKey) return;\n  if (await getPrivacyMode()) return;\n  const now = nowMs();\n  const clearedAt = await syncCacheClearMarker();\n  const savedAtMs = clearedAt && now <= clearedAt ? clearedAt + 1 : now;\n  const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? savedAtMs + ttlMs : null;\n  const entry = {\n    v: 1,\n    savedAtMs,\n    expiresAtMs,\n    value\n  };\n\n  const raw = JSON.stringify(entry);\n  const size = estimateSizeBytes(raw);\n  if (size > CACHE_INDEX_MAX_BYTES) {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return;\n  }\n  await rawSet(CACHE_ENTRY_PREFIX + cacheKey, raw);\n\n  const index = await loadCacheIndex();\n  const provider = meta.provider || value?.provider || \"\";\n  const model = meta.model || value?.model || \"\";\n\n  let updated = false;\n  const next = (index || []).map((item) => {\n    if (item?.key !== cacheKey) return item;\n    updated = true;\n    return {\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    };\n  });\n\n  if (!updated) {\n    next.push({\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    });\n  }\n\n  const pruned = pruneCacheIndex(next, clearedAt);\n  for (const key of pruned.removedKeys) await removeCacheEntry(key);\n  await saveCacheIndex(pruned.list);\n}\n\nexport async function clearPersistentCache() {\n  const clearedAt = nowMs();\n  _cacheClearMs = clearedAt;\n  await rawSet(STORAGE_KEYS.CACHE_CLEAR_AT, String(clearedAt));\n  const index = await loadCacheIndex();\n  for (const item of index || []) {\n    if (!item?.key) continue;\n    await removeCacheEntry(item.key);\n  }\n  await rawRemove(STORAGE_KEYS.CACHE_INDEX);\n}\n\nexport async function getPersistentCacheStats() {\n  if (await getPrivacyMode()) {\n    return {\n      entries: 0,\n      sizeBytes: 0,\n      providers: {\n        gemini: { entries: 0, sizeBytes: 0 },\n        openai: { entries: 0, sizeBytes: 0 }\n      },\n      oldestMs: null,\n      newestMs: null\n    };\n  }\n  const index = await loadCacheIndex();\n  const clearedAt = await syncCacheClearMarker();\n  const pruned = pruneCacheIndex(index, clearedAt);\n  if (pruned.removedKeys.length) {\n    for (const key of pruned.removedKeys) await removeCacheEntry(key);\n    await saveCacheIndex(pruned.list);\n  }\n\n  const stats = {\n    entries: 0,\n    sizeBytes: 0,\n    providers: {\n      gemini: { entries: 0, sizeBytes: 0 },\n      openai: { entries: 0, sizeBytes: 0 }\n    },\n    oldestMs: null,\n    newestMs: null\n  };\n\n  for (const item of pruned.list || []) {\n    if (!item?.key) continue;\n    stats.entries += 1;\n    stats.sizeBytes += Number(item.size || 0);\n    const provider = String(item.provider || \"\").toLowerCase();\n    if (provider === PROVIDERS.GEMINI) {\n      stats.providers.gemini.entries += 1;\n      stats.providers.gemini.sizeBytes += Number(item.size || 0);\n    } else if (provider === PROVIDERS.OPENAI) {\n      stats.providers.openai.entries += 1;\n      stats.providers.openai.sizeBytes += Number(item.size || 0);\n    }\n\n    const savedAt = Number(item.savedAtMs || 0);\n    if (savedAt) {\n      stats.oldestMs = stats.oldestMs == null ? savedAt : Math.min(stats.oldestMs, savedAt);\n      stats.newestMs = stats.newestMs == null ? savedAt : Math.max(stats.newestMs, savedAt);\n    }\n  }\n\n  return stats;\n}\n\n// ---------- Stable stringify + hashing (for cache keys) ----------\nfunction isPlainObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\n\nexport function stableStringify(value) {\n  return JSON.stringify(sortKeysDeep(value));\n}\n\nfunction sortKeysDeep(value) {\n  if (Array.isArray(value)) return value.map(sortKeysDeep);\n  if (isPlainObject(value)) {\n    const out = {};\n    for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);\n    return out;\n  }\n  return value;\n}\n\nfunction fnv1a32(str) {\n  let h = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  // Unsigned\n  return (h >>> 0).toString(16).padStart(8, \"0\");\n}\n\nexport async function hashKey(input) {\n  const text = typeof input === \"string\" ? input : stableStringify(input);\n\n  // Prefer SHA-256 when available (browser/Office runtime)\n  try {\n    if (typeof crypto !== \"undefined\" && crypto?.subtle?.digest && typeof TextEncoder !== \"undefined\") {\n      const enc = new TextEncoder();\n      const bytes = enc.encode(text);\n      const digest = await crypto.subtle.digest(\"SHA-256\", bytes);\n      const arr = Array.from(new Uint8Array(digest));\n      return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n  } catch {\n    // ignore and fallback\n  }\n\n  return `fnv1a:${fnv1a32(text)}`;\n}\n\n// ---------- Lightweight diagnostics log (persisted) ----------\nconst REQUEST_LOG_MAX_PER_TYPE = 50;\nconst REQUEST_LOG_MAX_TOTAL = REQUEST_LOG_MAX_PER_TYPE * 2;\nconst REQUEST_LOG_TTL_MS = Infinity; // Kept until manual reset (capped by count)\nconst LOG_FLUSH_INTERVAL_MS = 500;\nconst LOG_FLUSH_MAX_BUFFER = 80;\nlet _requestLog = [];\nlet _requestLogLoading = null;\nlet _requestLogLoaded = false;\nlet _requestLogLastLoadedMs = 0;\nlet _requestLogClearMs = 0;\nlet _logBuffer = [];\nlet _logFlushTimer = null;\nlet _logFlushPromise = null;\nconst USAGE_TOTALS_CACHE_TTL_MS = 1500;\nconst BATCH_APPLIED_MAX = 80;\nconst BATCH_APPLIED_TTL_MS = 24 * 60 * 60 * 1000;\nlet _usageTotals = createEmptyUsageTotals();\nlet _usageTotalsLoading = null;\nlet _usageTotalsLoaded = false;\nlet _usageTotalsLastLoadedMs = 0;\nlet _usageTotalsDirty = false;\n\nasync function syncRequestLogClearMarker(options = {}) {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT));\n  if (clearedAt > _requestLogClearMs) {\n    _requestLogClearMs = clearedAt;\n    _requestLog = [];\n    if (options.reset) {\n      _requestLogLoaded = true;\n      _requestLogLoading = null;\n      _requestLogLastLoadedMs = nowMs();\n    } else {\n      _requestLogLoaded = false;\n    }\n  }\n  return _requestLogClearMs;\n}\n\nfunction coerceRequestLogArray(value) {\n  if (Array.isArray(value)) return value;\n  if (value && typeof value === \"object\") {\n    const normal = Array.isArray(value.normal) ? value.normal : [];\n    const errors = Array.isArray(value.errors) ? value.errors : [];\n    return normal.concat(errors);\n  }\n  return [];\n}\n\nfunction isErrorLogEntry(entry) {\n  return !!entry && entry.ok === false;\n}\n\nasync function loadRequestLog(force = false) {\n  if (_requestLogLoading) return _requestLogLoading;\n\n  _requestLogLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_requestLogLoaded) {\n        _requestLogLoaded = true;\n        _requestLogLastLoadedMs = nowMs();\n      }\n      return _requestLog;\n    }\n    const clearedAt = await syncRequestLogClearMarker();\n    if (!force && _requestLogLoaded) return _requestLog;\n    const raw = await rawGet(STORAGE_KEYS.REQUEST_LOG);\n    let arr = [];\n    if (raw) {\n      try {\n        const parsed = JSON.parse(raw);\n        arr = coerceRequestLogArray(parsed);\n      } catch {\n        arr = [];\n      }\n    }\n    const now = nowMs();\n    arr = arr\n      .map((e) => {\n        if (!e) return null;\n        let ts = e.ts;\n        if (typeof ts === \"string\") {\n          const parsed = Date.parse(ts);\n          if (Number.isFinite(parsed)) ts = parsed;\n        }\n        if (typeof ts !== \"number\") return null;\n        return { ...e, ts };\n      })\n      .filter((e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS)\n      .map((e) => sanitizeLogEntry(e));\n    _requestLog = arr;\n    pruneRequestLog();\n    _requestLogLoaded = true;\n    _requestLogLastLoadedMs = nowMs();\n    return _requestLog;\n  })();\n\n  try {\n    return await _requestLogLoading;\n  } finally {\n    _requestLogLoading = null;\n  }\n}\n\nasync function persistRequestLog() {\n  try {\n    if (await getPrivacyMode()) return;\n    pruneRequestLog();\n    await rawSet(STORAGE_KEYS.REQUEST_LOG, JSON.stringify(_requestLog.slice(-REQUEST_LOG_MAX_TOTAL)));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneRequestLog() {\n  const now = nowMs();\n  const clearedAt = _requestLogClearMs || 0;\n  const valid = (_requestLog || []).filter(\n    (e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS\n  );\n  const normals = [];\n  const errors = [];\n  for (const entry of valid) {\n    if (isErrorLogEntry(entry)) errors.push(entry);\n    else normals.push(entry);\n  }\n  normals.sort((a, b) => a.ts - b.ts);\n  errors.sort((a, b) => a.ts - b.ts);\n  const pruned = normals.slice(-REQUEST_LOG_MAX_PER_TYPE).concat(errors.slice(-REQUEST_LOG_MAX_PER_TYPE));\n  pruned.sort((a, b) => a.ts - b.ts);\n  _requestLog = pruned;\n}\n\n// ---------- Persistent usage totals ----------\nfunction toNonNegInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nfunction toNonNegNumber(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return n;\n}\n\nfunction createEmptyUsageTotals() {\n  return {\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    cacheStorageTokenHours: 0,\n    requests: 0,\n    batchApplied: {},\n    byProvider: {\n      [PROVIDERS.GEMINI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0,\n        models: {}\n      },\n      [PROVIDERS.OPENAI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0,\n        models: {}\n      }\n    }\n  };\n}\n\nfunction normalizeUsageTotals(raw) {\n  const base = createEmptyUsageTotals();\n  if (!raw || typeof raw !== \"object\") return base;\n\n  base.inputTokens = toNonNegInt(raw.inputTokens);\n  base.outputTokens = toNonNegInt(raw.outputTokens);\n  base.reasoningTokens = toNonNegInt(raw.reasoningTokens);\n  base.cachedInputTokens = toNonNegInt(raw.cachedInputTokens);\n  base.cacheStorageTokenHours = toNonNegNumber(raw.cacheStorageTokenHours);\n  base.requests = toNonNegInt(raw.requests);\n  base.batchApplied = normalizeBatchApplied(raw.batchApplied);\n\n  const providers = raw.byProvider && typeof raw.byProvider === \"object\" ? raw.byProvider : {};\n  for (const provider of [PROVIDERS.GEMINI, PROVIDERS.OPENAI]) {\n    const rawProvider = providers[provider];\n    if (!rawProvider || typeof rawProvider !== \"object\") continue;\n    const target = base.byProvider[provider];\n    target.inputTokens = toNonNegInt(rawProvider.inputTokens);\n    target.outputTokens = toNonNegInt(rawProvider.outputTokens);\n    target.reasoningTokens = toNonNegInt(rawProvider.reasoningTokens);\n    target.cachedInputTokens = toNonNegInt(rawProvider.cachedInputTokens);\n    target.cacheStorageTokenHours = toNonNegNumber(rawProvider.cacheStorageTokenHours);\n    target.requests = toNonNegInt(rawProvider.requests);\n\n    const rawModels = rawProvider.models && typeof rawProvider.models === \"object\" ? rawProvider.models : {};\n    for (const [key, value] of Object.entries(rawModels)) {\n      if (!value || typeof value !== \"object\") continue;\n      const label = typeof value.label === \"string\" ? value.label : String(key || \"\");\n      const modelKey = String(key || label || \"\").toLowerCase();\n      if (!modelKey) continue;\n      target.models[modelKey] = {\n        label,\n        inputTokens: toNonNegInt(value.inputTokens),\n        outputTokens: toNonNegInt(value.outputTokens),\n        reasoningTokens: toNonNegInt(value.reasoningTokens),\n        cachedInputTokens: toNonNegInt(value.cachedInputTokens),\n        cacheStorageTokenHours: toNonNegNumber(value.cacheStorageTokenHours),\n        requests: toNonNegInt(value.requests)\n      };\n    }\n  }\n\n  return base;\n}\n\nfunction normalizeBatchApplied(raw) {\n  if (!raw || typeof raw !== \"object\") return {};\n  const out = {};\n  for (const [batchId, value] of Object.entries(raw)) {\n    if (!value || typeof value !== \"object\") continue;\n    const models = value.models && typeof value.models === \"object\" ? value.models : {};\n    const normalizedModels = {};\n    for (const [key, model] of Object.entries(models)) {\n      if (!model || typeof model !== \"object\") continue;\n      const provider = String(model.provider || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      const modelKey = String(model.modelKey || model.model || key || \"\").toLowerCase();\n      if (!modelKey) continue;\n      normalizedModels[key] = {\n        provider,\n        modelKey,\n        label: typeof model.label === \"string\" ? model.label : \"\",\n        inputTokens: toNonNegInt(model.inputTokens),\n        outputTokens: toNonNegInt(model.outputTokens),\n        reasoningTokens: toNonNegInt(model.reasoningTokens),\n        cachedInputTokens: toNonNegInt(model.cachedInputTokens),\n        cacheStorageTokenHours: toNonNegNumber(model.cacheStorageTokenHours),\n        requests: toNonNegInt(model.requests)\n      };\n    }\n    out[batchId] = {\n      ts: Number(value.ts) || 0,\n      models: normalizedModels\n    };\n  }\n  return pruneBatchApplied(out);\n}\n\nfunction pruneBatchApplied(map) {\n  if (!map || typeof map !== \"object\") return {};\n  const now = nowMs();\n  const entries = Object.entries(map)\n    .filter(([, value]) => value && typeof value === \"object\")\n    .filter(([, value]) => {\n      const ts = Number(value.ts) || 0;\n      return !ts || now - ts <= BATCH_APPLIED_TTL_MS;\n    })\n    .sort((a, b) => (Number(a[1].ts) || 0) - (Number(b[1].ts) || 0));\n  const trimmed = entries.slice(-BATCH_APPLIED_MAX);\n  const out = {};\n  for (const [key, value] of trimmed) {\n    out[key] = value;\n  }\n  return out;\n}\n\nfunction cloneUsageTotals(value) {\n  try {\n    return JSON.parse(JSON.stringify(value || createEmptyUsageTotals()));\n  } catch {\n    return createEmptyUsageTotals();\n  }\n}\n\nasync function loadUsageTotals(force = false) {\n  if (_usageTotalsLoading) return _usageTotalsLoading;\n\n  _usageTotalsLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_usageTotalsLoaded) {\n        _usageTotalsLoaded = true;\n        _usageTotalsLastLoadedMs = nowMs();\n      }\n      return _usageTotals;\n    }\n\n    if (!force && _usageTotalsLoaded) return _usageTotals;\n\n    const raw = await rawGet(STORAGE_KEYS.USAGE_TOTALS);\n    let parsed = null;\n    if (raw) {\n      try {\n        parsed = JSON.parse(raw);\n      } catch {\n        parsed = null;\n      }\n    }\n\n    _usageTotals = normalizeUsageTotals(parsed);\n    _usageTotalsLoaded = true;\n    _usageTotalsLastLoadedMs = nowMs();\n    return _usageTotals;\n  })();\n\n  try {\n    return await _usageTotalsLoading;\n  } finally {\n    _usageTotalsLoading = null;\n  }\n}\n\nasync function persistUsageTotals() {\n  try {\n    if (await getPrivacyMode()) return;\n    await rawSet(STORAGE_KEYS.USAGE_TOTALS, JSON.stringify(_usageTotals));\n  } catch {\n    // ignore\n  }\n}\n\nfunction applyUsageTotalsFromEntry(entry) {\n  if (!entry || typeof entry !== \"object\") return false;\n\n  if (entry.batch && Array.isArray(entry.batchModels)) {\n    const batchId = entry.batchId ? String(entry.batchId) : \"\";\n    const now = nowMs();\n    const currentModels = {};\n    for (const item of entry.batchModels) {\n      if (!item || typeof item !== \"object\") continue;\n      const provider = String(item.provider || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      const modelLabel = String(item.model || \"\").trim();\n      const modelKey = (modelLabel || \"unknown\").toLowerCase();\n      const mapKey = `${provider}|${modelKey}`;\n      const existing = currentModels[mapKey] || {\n        provider,\n        modelKey,\n        label: modelLabel,\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0\n      };\n      existing.inputTokens += toNonNegInt(item.inputTokens);\n      existing.outputTokens += toNonNegInt(item.outputTokens);\n      existing.reasoningTokens += toNonNegInt(item.reasoningTokens);\n      existing.cachedInputTokens += toNonNegInt(item.cachedInputTokens);\n      existing.cacheStorageTokenHours += toNonNegNumber(item.cacheStorageTokenHours);\n      existing.requests += toNonNegInt(item.requests);\n      if (!existing.label && modelLabel) existing.label = modelLabel;\n      currentModels[mapKey] = existing;\n    }\n\n    if (!batchId) {\n      let touched = false;\n      for (const model of Object.values(currentModels)) {\n        if (applyUsageDelta(model.provider, model.modelKey, model.label, model)) touched = true;\n      }\n      return touched;\n    }\n\n    const batchApplied = _usageTotals.batchApplied || {};\n    const previous = batchApplied[batchId]?.models || {};\n    const keys = new Set([...Object.keys(previous), ...Object.keys(currentModels)]);\n    let touched = false;\n    for (const key of keys) {\n      const curr = currentModels[key] || null;\n      const prev = previous[key] || null;\n      if (!curr && !prev) continue;\n      const provider = (curr?.provider || prev?.provider || \"\").toLowerCase();\n      const modelKey = (curr?.modelKey || prev?.modelKey || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      if (!modelKey) continue;\n      const delta = {\n        inputTokens: (curr?.inputTokens || 0) - (prev?.inputTokens || 0),\n        outputTokens: (curr?.outputTokens || 0) - (prev?.outputTokens || 0),\n        reasoningTokens: (curr?.reasoningTokens || 0) - (prev?.reasoningTokens || 0),\n        cachedInputTokens: (curr?.cachedInputTokens || 0) - (prev?.cachedInputTokens || 0),\n        cacheStorageTokenHours: (curr?.cacheStorageTokenHours || 0) - (prev?.cacheStorageTokenHours || 0),\n        requests: (curr?.requests || 0) - (prev?.requests || 0),\n        label: curr?.label || prev?.label || \"\"\n      };\n      if (!hasUsageDelta(delta)) continue;\n      if (applyUsageDelta(provider, modelKey, delta.label, delta)) touched = true;\n    }\n\n    batchApplied[batchId] = { ts: Number(entry.ts) || now, models: currentModels };\n    _usageTotals.batchApplied = pruneBatchApplied(batchApplied);\n    return touched;\n  }\n\n  const inputTokens = toNonNegInt(entry.inputTokens);\n  const outputTokens = toNonNegInt(entry.outputTokens);\n  const reasoningTokens = toNonNegInt(entry.reasoningTokens);\n  const cachedInputTokens = toNonNegInt(entry.cachedInputTokens);\n  const cacheStorageTokenHours = toNonNegNumber(entry.cacheStorageTokenHours);\n  const hasUsage = inputTokens + outputTokens + reasoningTokens + cachedInputTokens > 0 || cacheStorageTokenHours > 0;\n  if (!hasUsage) return false;\n\n  const provider = String(entry.provider || \"\").toLowerCase();\n  if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) return false;\n\n  const modelLabel = String(entry.model || \"\").trim();\n  const modelKey = (modelLabel || \"unknown\").toLowerCase();\n\n  return applyUsageDelta(provider, modelKey, modelLabel, {\n    inputTokens,\n    outputTokens,\n    reasoningTokens,\n    cachedInputTokens,\n    cacheStorageTokenHours,\n    requests: 1\n  });\n}\n\nfunction hasUsageDelta(delta) {\n  return (\n    Number(delta?.inputTokens || 0) !== 0 ||\n    Number(delta?.outputTokens || 0) !== 0 ||\n    Number(delta?.reasoningTokens || 0) !== 0 ||\n    Number(delta?.cachedInputTokens || 0) !== 0 ||\n    Number(delta?.cacheStorageTokenHours || 0) !== 0 ||\n    Number(delta?.requests || 0) !== 0\n  );\n}\n\nfunction applyUsageDelta(provider, modelKey, modelLabel, delta) {\n  if (!delta) return false;\n  const inputTokens = Number(delta.inputTokens || 0);\n  const outputTokens = Number(delta.outputTokens || 0);\n  const reasoningTokens = Number(delta.reasoningTokens || 0);\n  const cachedInputTokens = Number(delta.cachedInputTokens || 0);\n  const cacheStorageTokenHours = Number(delta.cacheStorageTokenHours || 0);\n  const requests = Number(delta.requests || 0);\n  const hasUsage = inputTokens || outputTokens || reasoningTokens || cachedInputTokens || cacheStorageTokenHours || requests;\n  if (!hasUsage) return false;\n\n  _usageTotals.inputTokens = Math.max(0, _usageTotals.inputTokens + inputTokens);\n  _usageTotals.outputTokens = Math.max(0, _usageTotals.outputTokens + outputTokens);\n  _usageTotals.reasoningTokens = Math.max(0, _usageTotals.reasoningTokens + reasoningTokens);\n  _usageTotals.cachedInputTokens = Math.max(0, _usageTotals.cachedInputTokens + cachedInputTokens);\n  _usageTotals.cacheStorageTokenHours = Math.max(0, _usageTotals.cacheStorageTokenHours + cacheStorageTokenHours);\n  _usageTotals.requests = Math.max(0, _usageTotals.requests + requests);\n\n  const providerTotals = _usageTotals.byProvider[provider];\n  providerTotals.inputTokens = Math.max(0, providerTotals.inputTokens + inputTokens);\n  providerTotals.outputTokens = Math.max(0, providerTotals.outputTokens + outputTokens);\n  providerTotals.reasoningTokens = Math.max(0, providerTotals.reasoningTokens + reasoningTokens);\n  providerTotals.cachedInputTokens = Math.max(0, providerTotals.cachedInputTokens + cachedInputTokens);\n  providerTotals.cacheStorageTokenHours = Math.max(0, providerTotals.cacheStorageTokenHours + cacheStorageTokenHours);\n  providerTotals.requests = Math.max(0, providerTotals.requests + requests);\n\n  const models = providerTotals.models || {};\n  const existing = models[modelKey] || {\n    label: modelLabel,\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    cacheStorageTokenHours: 0,\n    requests: 0\n  };\n  if (!existing.label && modelLabel) existing.label = modelLabel;\n  existing.inputTokens = Math.max(0, existing.inputTokens + inputTokens);\n  existing.outputTokens = Math.max(0, existing.outputTokens + outputTokens);\n  existing.reasoningTokens = Math.max(0, existing.reasoningTokens + reasoningTokens);\n  existing.cachedInputTokens = Math.max(0, existing.cachedInputTokens + cachedInputTokens);\n  existing.cacheStorageTokenHours = Math.max(0, existing.cacheStorageTokenHours + cacheStorageTokenHours);\n  existing.requests = Math.max(0, existing.requests + requests);\n  models[modelKey] = existing;\n  providerTotals.models = models;\n  return true;\n}\n\nexport async function getUsageTotals(options = {}) {\n  if (_logBuffer.length) {\n    await flushLogBuffer();\n  }\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_usageTotalsLoaded || now - _usageTotalsLastLoadedMs > USAGE_TOTALS_CACHE_TTL_MS) {\n    await loadUsageTotals(true);\n  } else {\n    await loadUsageTotals(false);\n  }\n  return cloneUsageTotals(_usageTotals);\n}\n\nexport async function clearUsageTotals() {\n  _usageTotals = createEmptyUsageTotals();\n  _usageTotalsLoaded = true;\n  _usageTotalsLoading = null;\n  _usageTotalsLastLoadedMs = nowMs();\n  _usageTotalsDirty = false;\n  await rawRemove(STORAGE_KEYS.USAGE_TOTALS);\n}\n\nexport function logRequest(entry) {\n  if (!entry || typeof entry !== \"object\") return;\n  const logEntry = sanitizeLogEntry({ ts: nowMs(), ...entry });\n  if (logEntry.batch && logEntry.batchId) {\n    let replaced = false;\n    for (let i = _logBuffer.length - 1; i >= 0; i -= 1) {\n      const existing = _logBuffer[i];\n      if (existing && existing.batch && existing.batchId === logEntry.batchId) {\n        _logBuffer[i] = logEntry;\n        replaced = true;\n        break;\n      }\n    }\n    if (!replaced) _logBuffer.push(logEntry);\n  } else {\n    _logBuffer.push(logEntry);\n  }\n\n  if (_logBuffer.length >= LOG_FLUSH_MAX_BUFFER) {\n    void flushLogBuffer();\n    return;\n  }\n\n  if (_logFlushTimer) return;\n  _logFlushTimer = setTimeout(() => {\n    _logFlushTimer = null;\n    void flushLogBuffer();\n  }, LOG_FLUSH_INTERVAL_MS);\n}\nasync function flushLogBuffer() {\n  if (_logFlushPromise) return _logFlushPromise;\n  if (!_logBuffer.length) return;\n\n  _logFlushPromise = (async () => {\n    try {\n      const entries = _logBuffer;\n      _logBuffer = [];\n\n      if (!entries.length) return;\n\n      await loadUsageTotals();\n      let usageTouched = false;\n      for (const entry of entries) {\n        if (applyUsageTotalsFromEntry(entry)) usageTouched = true;\n      }\n      if (usageTouched) {\n        _usageTotalsLastLoadedMs = nowMs();\n        _usageTotalsDirty = true;\n      }\n\n      const privacyMode = await getPrivacyMode();\n      if (privacyMode) {\n        _requestLog.push(...entries);\n        pruneRequestLog();\n        _requestLogLoaded = true;\n        _requestLogLastLoadedMs = nowMs();\n        return;\n      }\n\n      await syncRequestLogClearMarker({ reset: true });\n      if (!_requestLogLoaded) {\n        await loadRequestLog();\n      }\n      for (const entry of entries) {\n        if (entry?.batch && entry?.batchId) {\n          const idx = _requestLog.findIndex((e) => e?.batch && e?.batchId === entry.batchId);\n          if (idx >= 0) _requestLog[idx] = entry;\n          else _requestLog.push(entry);\n        } else {\n          _requestLog.push(entry);\n        }\n      }\n      pruneRequestLog();\n      _requestLogLastLoadedMs = nowMs();\n      await persistRequestLog();\n\n      if (_usageTotalsDirty) {\n        await persistUsageTotals();\n        _usageTotalsDirty = false;\n      }\n    } catch {\n      // ignore\n    }\n  })();\n\n  try {\n    await _logFlushPromise;\n  } finally {\n    _logFlushPromise = null;\n  }\n}\n\nfunction sanitizeLogEntry(entry) {\n  if (!entry || typeof entry !== \"object\") return entry;\n  return redactSensitiveValue(entry);\n}\n\nexport async function getRequestLog(options = {}) {\n  if (_logBuffer.length) {\n    await flushLogBuffer();\n  }\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_requestLogLoaded || now - _requestLogLastLoadedMs > 1500) {\n    await loadRequestLog(true);\n  } else {\n    await loadRequestLog(false);\n  }\n  return _requestLog.slice();\n}\n\nexport async function clearRequestLog() {\n  const clearedAt = nowMs();\n  _logBuffer = [];\n  if (_logFlushTimer) {\n    clearTimeout(_logFlushTimer);\n    _logFlushTimer = null;\n  }\n  _requestLog = [];\n  _requestLogLoaded = true;\n  _requestLogLoading = null;\n  _requestLogClearMs = clearedAt;\n  _requestLogLastLoadedMs = clearedAt;\n  await rawSet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT, String(clearedAt));\n  await rawRemove(STORAGE_KEYS.REQUEST_LOG);\n}\n","// src/shared/providers.js\n// Provider implementations (Gemini + OpenAI) and shared request orchestration.\n//\n// Requirements implemented:\n// - Gemini 3 Flash (via Google Generative Language API)\n// - OpenAI GPT-5 Mini (via OpenAI Responses API)\n// - No temperature / sampling parameters are ever sent\n// - Provider selection happens via taskpane default provider (formulas cannot override)\n// - AI.WEB uses provider-native web search mechanisms:\n//   - Gemini: google_search tool\n//   - OpenAI: web_search tool\n\nimport {\n  PROVIDERS,\n  DEFAULTS,\n  normalizeProvider,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getGeminiReasoningEffort,\n  getOpenAIReasoningEffort,\n  getMaxOutputTokens,\n  getConcurrencyLimit,\n  getRpmLimit,\n  clampInt,\n  nowMs,\n  sleep,\n  LRUCache,\n  hashKey,\n  logRequest,\n  setRuntimeStatus,\n  getCacheClearAt,\n  getPersistentCache,\n  setPersistentCache,\n  clearPersistentCache,\n  getPrivacyMode,\n  redactSensitiveText\n} from \"./core.js\";\n\n// ---- In-memory cache (per runtime) ----\nconst CACHE = new LRUCache(800);\nlet _cacheClearLocalMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = await getCacheClearAt();\n  if (clearedAt > _cacheClearLocalMs) {\n    _cacheClearLocalMs = clearedAt;\n    CACHE.clear();\n  }\n}\n\n// Deduplicate in-flight identical requests to avoid bursts (per runtime)\nconst INFLIGHT = new Map(); // key => Promise<AIResult>\n\nconst GEMINI_503_RETRY_DELAY_MS = 10000;\nconst GEMINI_503_MAX_RETRIES = 2;\nconst GEMINI_CACHED_CONTENT_TTL_MS = 15 * 60 * 1000;\nconst GEMINI_CACHED_CONTENT_MIN_PREFIX_CHARS = 200;\nconst GEMINI_CACHED_CONTENT_MIN_SUFFIX_CHARS = 1;\nconst GEMINI_CACHED_CONTENT = new Map(); // key => {name, createdAtMs, expiresAtMs, chargedTokenHours}\nconst GEMINI_CACHED_INFLIGHT = new Map(); // key => Promise<{name, cacheKey} | null>\n\n// Concurrency limiter (per runtime)\nconst QUEUE_CANCELLED = Symbol(\"queue_cancelled\");\nconst QUEUE_CANCELLED_RESULT = { ok: false, code: \"QUEUE_CANCELLED\", message: \"File d'attente arrte.\" };\nconst CONCURRENCY_CACHE_TTL_MS = 1500;\nlet concurrencyLimitCached = DEFAULTS.concurrencyLimit;\nlet concurrencyLimitCachedAt = 0;\n\n// RPM limiter (per runtime, global across providers)\nconst RPM_WINDOW_MS = 60000;\nconst RPM_CACHE_TTL_MS = 1500;\nlet rpmLimitCached = DEFAULTS.rpmLimit;\nlet rpmLimitCachedAt = 0;\nlet rpmWindow = [];\nlet rpmGate = Promise.resolve();\nlet rpmStatusTimer = null;\n\nclass FastQueue {\n  constructor() {\n    this._items = [];\n    this._head = 0;\n  }\n\n  get length() {\n    return this._items.length - this._head;\n  }\n\n  push(value) {\n    this._items.push(value);\n  }\n\n  shift() {\n    if (this._head >= this._items.length) return undefined;\n    const value = this._items[this._head++];\n    if (this._head > 1024 && this._head * 2 > this._items.length) {\n      this._items = this._items.slice(this._head);\n      this._head = 0;\n    }\n    return value;\n  }\n\n  drain() {\n    const pending = this._items.slice(this._head);\n    this._items = [];\n    this._head = 0;\n    return pending;\n  }\n}\n\nlet active = 0;\nconst queue = new FastQueue();\nlet statusTimer = null;\nlet pendingStatus = null;\nlet lastStatusKey = \"\";\nconst BATCH_REQUEST_THRESHOLD = Number.POSITIVE_INFINITY;\nconst BATCH_LOG_THROTTLE_MS = 1000;\nlet batchState = null;\n\nfunction createBatchState() {\n  const startedAt = nowMs();\n  return {\n    id: `batch_${startedAt}_${Math.random().toString(36).slice(2, 8)}`,\n    startedAt,\n    endedAt: 0,\n    totalRequests: 0,\n    okCount: 0,\n    errorCount: 0,\n    cachedCount: 0,\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    msSum: 0,\n    msMax: 0,\n    msMin: 0,\n    peakQueued: 0,\n    peakActive: 0,\n    models: new Map(),\n    lastLogAt: 0\n  };\n}\n\nfunction totalPendingRequests() {\n  return active + queue.length;\n}\n\nfunction ensureBatchState() {\n  if (batchState) return true;\n  if (totalPendingRequests() < BATCH_REQUEST_THRESHOLD) return false;\n  batchState = createBatchState();\n  return true;\n}\n\nfunction updateBatchPeaks() {\n  if (!batchState) return;\n  batchState.peakQueued = Math.max(batchState.peakQueued, queue.length);\n  batchState.peakActive = Math.max(batchState.peakActive, active);\n}\n\nfunction recordBatchResult({ provider, model, ok, cached, usage, ms, cacheAdjusted = false }) {\n  if (!batchState) return false;\n  batchState.totalRequests += 1;\n  if (ok) batchState.okCount += 1;\n  else batchState.errorCount += 1;\n  if (cached) batchState.cachedCount += 1;\n\n  const inputTokens = Number(usage?.inputTokens || 0) || 0;\n  const outputTokens = Number(usage?.outputTokens || 0) || 0;\n  const reasoningTokens = Number(usage?.reasoningTokens || 0) || 0;\n  const cachedInputTokens = Number(usage?.cachedInputTokens || 0) || 0;\n\n  batchState.inputTokens += inputTokens;\n  batchState.outputTokens += outputTokens;\n  batchState.reasoningTokens += reasoningTokens;\n  batchState.cachedInputTokens += cachedInputTokens;\n\n  const duration = Number(ms || 0) || 0;\n  if (duration > 0) {\n    batchState.msSum += duration;\n    batchState.msMax = Math.max(batchState.msMax, duration);\n    batchState.msMin = batchState.msMin ? Math.min(batchState.msMin, duration) : duration;\n  }\n\n  if (inputTokens + outputTokens + reasoningTokens + cachedInputTokens > 0) {\n    const key = `${String(provider || \"\").toLowerCase()}|${String(model || \"\").trim()}`;\n    const existing = batchState.models.get(key) || {\n      provider: String(provider || \"\").toLowerCase(),\n      model: String(model || \"\").trim(),\n      inputTokens: 0,\n      outputTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0,\n      requests: 0,\n      cacheAdjusted: false\n    };\n    existing.inputTokens += inputTokens;\n    existing.outputTokens += outputTokens;\n    existing.reasoningTokens += reasoningTokens;\n    existing.cachedInputTokens += cachedInputTokens;\n    existing.requests += 1;\n    if (cacheAdjusted) existing.cacheAdjusted = true;\n    batchState.models.set(key, existing);\n  }\n\n  maybeEmitBatchLog(false);\n  return true;\n}\n\nfunction shouldUsePersistentCache() {\n  if (batchState) return false;\n  if (totalPendingRequests() >= BATCH_REQUEST_THRESHOLD) return false;\n  return true;\n}\n\nfunction buildBatchLogEntry(isFinal) {\n  if (!batchState) return null;\n  const models = Array.from(batchState.models.values());\n  const totalTokens = batchState.inputTokens + batchState.outputTokens + batchState.reasoningTokens;\n  const durationMs = Math.max(0, (batchState.endedAt || nowMs()) - batchState.startedAt);\n  const avgMs = batchState.totalRequests > 0 ? Math.round(batchState.msSum / batchState.totalRequests) : 0;\n\n  return {\n    fn: \"AI.BATCH\",\n    provider: \"batch\",\n    model: \"\",\n    ok: batchState.errorCount === 0,\n    cache: false,\n    ms: durationMs,\n    inputTokens: batchState.inputTokens,\n    outputTokens: batchState.outputTokens,\n    reasoningTokens: batchState.reasoningTokens,\n    cachedInputTokens: batchState.cachedInputTokens,\n    totalTokens,\n    batch: true,\n    batchId: batchState.id,\n    batchLive: !isFinal,\n    batchModels: models,\n    batchStats: {\n      totalRequests: batchState.totalRequests,\n      ok: batchState.okCount,\n      error: batchState.errorCount,\n      cached: batchState.cachedCount,\n      avgMs,\n      maxMs: batchState.msMax,\n      minMs: batchState.msMin,\n      peakQueued: batchState.peakQueued,\n      peakActive: batchState.peakActive\n    }\n  };\n}\n\nfunction maybeEmitBatchLog(force) {\n  if (!batchState) return;\n  const now = nowMs();\n  if (!force && now - batchState.lastLogAt < BATCH_LOG_THROTTLE_MS) return;\n  batchState.lastLogAt = now;\n  const entry = buildBatchLogEntry(false);\n  if (entry) logRequest(entry);\n}\n\nfunction finalizeBatchIfIdle() {\n  if (!batchState) return;\n  if (active > 0 || queue.length > 0) return;\n  batchState.endedAt = nowMs();\n  const entry = buildBatchLogEntry(true);\n  batchState = null;\n  if (entry) logRequest(entry);\n}\n\nfunction getRpmCount() {\n  const now = nowMs();\n  pruneRpmWindow(now);\n  return rpmWindow.length;\n}\n\nfunction snapshotQueueStatus() {\n  return { active, queued: queue.length, rpm: getRpmCount() };\n}\n\nfunction scheduleRuntimeStatusUpdate() {\n  const snapshot = snapshotQueueStatus();\n  pendingStatus = snapshot;\n  if (statusTimer) return;\n  statusTimer = setTimeout(() => {\n    statusTimer = null;\n    const status = pendingStatus;\n    pendingStatus = null;\n    if (!status) return;\n    const key = `${status.active}:${status.queued}:${status.rpm}`;\n    if (key === lastStatusKey) return;\n    lastStatusKey = key;\n    void setRuntimeStatus({ ...status, ts: nowMs() });\n  }, 120);\n}\n\nasync function getConcurrencyLimitCached() {\n  const now = nowMs();\n  if (now - concurrencyLimitCachedAt < CONCURRENCY_CACHE_TTL_MS) return concurrencyLimitCached;\n  const value = await getConcurrencyLimit();\n  concurrencyLimitCached = value;\n  concurrencyLimitCachedAt = now;\n  return value;\n}\n\nasync function getRpmLimitCached() {\n  const now = nowMs();\n  if (now - rpmLimitCachedAt < RPM_CACHE_TTL_MS) return rpmLimitCached;\n  const value = await getRpmLimit();\n  rpmLimitCached = value;\n  rpmLimitCachedAt = now;\n  return value;\n}\n\nfunction pruneRpmWindow(now) {\n  const cutoff = now - RPM_WINDOW_MS;\n  while (rpmWindow.length && rpmWindow[0] <= cutoff) {\n    rpmWindow.shift();\n  }\n}\n\nfunction ensureRpmStatusTimer() {\n  if (rpmStatusTimer) return;\n  rpmStatusTimer = setInterval(() => {\n    const count = getRpmCount();\n    scheduleRuntimeStatusUpdate();\n    if (count <= 0) {\n      clearInterval(rpmStatusTimer);\n      rpmStatusTimer = null;\n    }\n  }, 1000);\n}\n\nasync function reserveRpmSlot(limit) {\n  while (true) {\n    const now = nowMs();\n    pruneRpmWindow(now);\n    if (!limit || limit <= 0 || rpmWindow.length < limit) {\n      rpmWindow.push(now);\n      ensureRpmStatusTimer();\n      scheduleRuntimeStatusUpdate();\n      return;\n    }\n    const waitMs = Math.max(0, rpmWindow[0] + RPM_WINDOW_MS - now);\n    if (waitMs > 0) {\n      await sleep(waitMs);\n    } else {\n      await sleep(0);\n    }\n  }\n}\n\nasync function waitForRpmSlot() {\n  const limit = await getRpmLimitCached();\n  if (!limit || limit <= 0) return;\n  rpmGate = rpmGate.then(() => reserveRpmSlot(limit));\n  return rpmGate;\n}\n\nexport function stopQueuedRequests() {\n  if (!queue.length) return 0;\n  const pending = queue.drain();\n  for (const resolve of pending) {\n    resolve(QUEUE_CANCELLED);\n  }\n  scheduleRuntimeStatusUpdate();\n  return pending.length;\n}\n\nasync function withConcurrencyLimit(fn) {\n  while (true) {\n    const limit = await getConcurrencyLimitCached();\n    if (active < limit) break;\n    const gate = await new Promise((resolve) => {\n      queue.push(resolve);\n      ensureBatchState();\n      updateBatchPeaks();\n      scheduleRuntimeStatusUpdate();\n    });\n    if (gate === QUEUE_CANCELLED) return { ...QUEUE_CANCELLED_RESULT };\n  }\n  active++;\n  ensureBatchState();\n  updateBatchPeaks();\n  scheduleRuntimeStatusUpdate();\n  try {\n    await waitForRpmSlot();\n    return await fn();\n  } finally {\n    active--;\n    const next = queue.shift();\n    if (next) next();\n    scheduleRuntimeStatusUpdate();\n    finalizeBatchIfIdle();\n  }\n}\n\n// Reset runtime status on load to avoid stale UI.\nvoid setRuntimeStatus({ active: 0, queued: 0, rpm: 0, ts: nowMs() });\n\nfunction isNonEmptyString(s) {\n  return typeof s === \"string\" && s.trim().length > 0;\n}\n\nfunction normalizeBoolean(v, def = false) {\n  if (typeof v === \"boolean\") return v;\n  if (typeof v === \"number\") return v !== 0;\n  if (typeof v === \"string\") {\n    const s = v.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(s)) return true;\n    if ([\"0\", \"false\", \"no\", \"n\", \"off\"].includes(s)) return false;\n  }\n  return def;\n}\n\nfunction normalizeTimeoutMs(v) {\n  return clampInt(v, 1000, 120000, DEFAULTS.timeoutMs);\n}\n\nfunction normalizeRetry(v) {\n  return clampInt(v, 0, 5, DEFAULTS.retry);\n}\n\nfunction normalizeMaxOutputTokens(v) {\n  return clampInt(v, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nfunction toLowerMsg(v) {\n  return String(v || \"\").toLowerCase();\n}\n\nfunction isTimeoutError(err) {\n  if (!err) return false;\n  if (err.name === \"AbortError\") return true;\n  const msg = String(err.message || \"\").toLowerCase();\n  return msg.includes(\"aborted\") || msg.includes(\"timeout\");\n}\n\nfunction toGeminiModelRef(model) {\n  const id = String(model || \"\").trim();\n  if (!id) return \"\";\n  return id.startsWith(\"models/\") ? id : `models/${id}`;\n}\n\nfunction pruneGeminiCachedContent() {\n  const now = nowMs();\n  for (const [key, entry] of GEMINI_CACHED_CONTENT.entries()) {\n    if (entry?.expiresAtMs && entry.expiresAtMs <= now) {\n      GEMINI_CACHED_CONTENT.delete(key);\n    }\n  }\n}\n\nasync function createGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs }) {\n  const url = \"https://generativelanguage.googleapis.com/v1beta/cachedContents\";\n  const body = {\n    model: toGeminiModelRef(model),\n    contents: [{ role: \"user\", parts: [{ text: prefix }] }],\n    ttl: `${Math.max(60, Math.floor((ttlMs || GEMINI_CACHED_CONTENT_TTL_MS) / 1000))}s`\n  };\n\n  if (isNonEmptyString(system)) {\n    body.systemInstruction = { role: \"system\", parts: [{ text: system }] };\n  }\n\n  const res = await fetchWithTimeout(\n    url,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-goog-api-key\": apiKey\n      },\n      body: JSON.stringify(body)\n    },\n    Math.max(10000, Math.min(60000, timeoutMs || 30000))\n  );\n\n  const json = await safeJson(res);\n  if (!res.ok) return { ok: false, status: res.status, json };\n  const name = String(json?.name || \"\").trim();\n  if (!name) return { ok: false, status: res.status, json };\n  const expireTime = json?.expireTime ? Date.parse(String(json.expireTime)) : 0;\n  return { ok: true, name, expireTime };\n}\n\nasync function ensureGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs }) {\n  if (!apiKey || !isNonEmptyString(prefix)) return null;\n  if (await getPrivacyMode()) return null;\n  if (prefix.length < GEMINI_CACHED_CONTENT_MIN_PREFIX_CHARS) return null;\n\n  pruneGeminiCachedContent();\n  const cacheKey = await hashKey({ v: 1, model: String(model || \"\").trim(), system: String(system || \"\").trim(), prefix });\n  const existing = GEMINI_CACHED_CONTENT.get(cacheKey);\n  if (existing?.name) {\n    if (!Number.isFinite(existing.createdAtMs) || existing.createdAtMs <= 0) {\n      existing.createdAtMs = nowMs();\n    }\n    if (!Number.isFinite(existing.expiresAtMs) || existing.expiresAtMs <= existing.createdAtMs) {\n      existing.expiresAtMs = existing.createdAtMs + (ttlMs || GEMINI_CACHED_CONTENT_TTL_MS);\n    }\n    if (!Number.isFinite(existing.chargedTokenHours)) existing.chargedTokenHours = 0;\n    GEMINI_CACHED_CONTENT.set(cacheKey, existing);\n    return { name: existing.name, cacheKey };\n  }\n\n  if (GEMINI_CACHED_INFLIGHT.has(cacheKey)) return GEMINI_CACHED_INFLIGHT.get(cacheKey);\n\n  const p = (async () => {\n    try {\n      const created = await createGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs });\n      if (!created?.ok || !created?.name) return null;\n      const expiresAtMs = Number.isFinite(created.expireTime) && created.expireTime > 0\n        ? created.expireTime\n        : nowMs() + (ttlMs || GEMINI_CACHED_CONTENT_TTL_MS);\n      GEMINI_CACHED_CONTENT.set(cacheKey, {\n        name: created.name,\n        createdAtMs: nowMs(),\n        expiresAtMs,\n        chargedTokenHours: 0\n      });\n      return { name: created.name, cacheKey };\n    } catch {\n      return null;\n    }\n  })();\n\n  GEMINI_CACHED_INFLIGHT.set(cacheKey, p);\n  try {\n    return await p;\n  } finally {\n    GEMINI_CACHED_INFLIGHT.delete(cacheKey);\n  }\n}\n\nfunction looksLikeCachedContentInvalid(message) {\n  const s = toLowerMsg(message);\n  if (!s || !s.includes(\"cached\")) return false;\n  return (\n    s.includes(\"not found\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"expired\") ||\n    s.includes(\"does not exist\")\n  );\n}\n\nfunction looksLikeStructuredOutputUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  return (\n    s.includes(\"responseschema\") ||\n    s.includes(\"response schema\") ||\n    s.includes(\"response_schema\") ||\n    s.includes(\"responsemime\") ||\n    s.includes(\"response mime\") ||\n    s.includes(\"response_mime\") ||\n    s.includes(\"response_mime_type\") ||\n    s.includes(\"json_schema\") ||\n    s.includes(\"response_format\") ||\n    s.includes(\"text.format\")\n  );\n}\n\nfunction looksLikeWebSearchUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  if (!(s.includes(\"web_search\") || s.includes(\"google_search\") || s.includes(\"web search\") || s.includes(\"google search\"))) {\n    return false;\n  }\n  return (\n    s.includes(\"not supported\") ||\n    s.includes(\"unsupported\") ||\n    s.includes(\"unknown\") ||\n    s.includes(\"unrecognized\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"not enabled\") ||\n    s.includes(\"not available\")\n  );\n}\n\nfunction isGeminiServiceUnavailable(provider, result) {\n  if (provider !== PROVIDERS.GEMINI || result?.ok) return false;\n  if (result?.status === 503) return true;\n  if (result?.code !== \"API_ERROR\") return false;\n  const msg = toLowerMsg(result?.message);\n  if (!msg) return false;\n  return msg.includes(\"overloaded\") || msg.includes(\"service unavailable\") || msg.includes(\"unavailable\");\n}\n\nfunction ensureJsonInstruction(system) {\n  const suffix = \" Return valid JSON only.\";\n  if (!isNonEmptyString(system)) return \"Return valid JSON only.\";\n  const s = String(system).trim();\n  if (/json/i.test(s)) return s;\n  return s + suffix;\n}\n\nfunction extractFormulaFromText(text) {\n  if (!isNonEmptyString(text)) return \"\";\n  const raw = String(text).trim();\n  const match = raw.match(/=[^\\n\\r]+/);\n  const formula = (match ? match[0] : raw).trim();\n  if (!formula.startsWith(\"=\")) return \"\";\n  return formula;\n}\n\nfunction getFormulaForLog(fnName, text) {\n  if (fnName !== \"AI.FORMULA\") return \"\";\n  return extractFormulaFromText(text);\n}\n\nfunction resolveGeminiThinkingConfig(model, effort) {\n  const level = String(effort || \"\").trim().toLowerCase();\n  if (!level || level === \"auto\" || level === \"none\") return null;\n\n  const modelId = String(model || \"\").trim().toLowerCase();\n  if (!modelId.includes(\"gemini\")) return null;\n\n  if (modelId.includes(\"gemini-3\")) {\n    if (modelId.includes(\"flash\")) {\n      const allowed = new Set([\"minimal\", \"low\", \"medium\", \"high\"]);\n      const normalized = allowed.has(level) ? level : \"low\";\n      return { thinkingLevel: normalized.toUpperCase() };\n    }\n    const normalized = level === \"high\" || level === \"medium\" ? \"high\" : \"low\";\n    return { thinkingLevel: normalized.toUpperCase() };\n  }\n\n  if (modelId.includes(\"gemini-2.5\")) {\n    const budgets = {\n      minimal: 512,\n      low: 2048,\n      medium: 8192,\n      high: 24576\n    };\n    let budget = budgets[level];\n    if (!budget) return null;\n    if (modelId.includes(\"flash-lite\")) budget = Math.max(512, budget);\n    if (modelId.includes(\"pro\")) budget = Math.max(128, budget);\n    return { thinkingBudget: budget };\n  }\n\n  return null;\n}\n\n// ---- Public API ----\n\n/**\n * @typedef {Object} AIGenerateRequest\n * @property {string=} provider Optional override (should only be used by taskpane tests, not formulas).\n * @property {string=} system System instruction.\n * @property {string} user User prompt.\n * @property {boolean=} webSearch Enable provider web search tool.\n * @property {number=} maxOutputTokens Override max tokens (optional; normally from panel).\n * @property {number=} timeoutMs\n * @property {number=} retry\n * @property {boolean=} cache\n * @property {number=} cacheTtlSec\n * @property {string=} cachePrefix Explicit cache prefix (Gemini only, used by AI.BATCH).\n * @property {string=} cacheSuffix Explicit cache suffix (Gemini only, used by AI.BATCH).\n * @property {string=} responseMimeType e.g., \"application/json\"\n * @property {Object=} responseJsonSchema JSON schema (strict) for structured output.\n * @property {string=} functionName Name for diagnostics.\n * @property {string=} functionCall Excel-style function call for diagnostics.\n */\n\n/**\n * @typedef {Object} AIResult\n * @property {boolean} ok\n * @property {string=} text\n * @property {Array<{title?: string, url: string}>=} sources\n * @property {string=} provider\n * @property {string=} model\n * @property {Object=} usage\n * @property {number=} status\n * @property {string=} code\n * @property {string=} message\n * @property {string=} cacheHint\n * @property {number=} cacheStorageTokenHours\n */\n\nexport async function aiGenerate(req) {\n  const start = nowMs();\n  const provider = normalizeProvider(req?.provider) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n  const fnName = req?.functionName || \"aiGenerate\";\n  const functionCall = isNonEmptyString(req?.functionCall) ? String(req.functionCall) : \"\";\n  const reasoningEffort = provider === PROVIDERS.OPENAI ? await getOpenAIReasoningEffort() : \"\";\n  const geminiReasoningEffort = provider === PROVIDERS.GEMINI ? await getGeminiReasoningEffort() : \"\";\n  const reasoningEffortLabel = provider === PROVIDERS.OPENAI ? reasoningEffort : geminiReasoningEffort;\n\n  if (!apiKey) {\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      reasoningEffort: reasoningEffortLabel || undefined,\n      call: functionCall || undefined,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    });\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  const cachePrefix = isNonEmptyString(req?.cachePrefix) ? String(req.cachePrefix) : \"\";\n  const cacheSuffix = isNonEmptyString(req?.cacheSuffix) ? String(req.cacheSuffix) : \"\";\n  const user = cachePrefix ? cachePrefix + cacheSuffix : String(req?.user || \"\");\n  const system = isNonEmptyString(req?.system) ? String(req.system) : \"\";\n\n  const webSearch = normalizeBoolean(req?.webSearch, false);\n  const timeoutMs = normalizeTimeoutMs(req?.timeoutMs);\n  const retry = normalizeRetry(req?.retry);\n  const gemini503RetryMax = Math.min(retry, GEMINI_503_MAX_RETRIES);\n\n  const cfgMax = await getMaxOutputTokens();\n  const maxOutputTokens = normalizeMaxOutputTokens(req?.maxOutputTokens ?? cfgMax);\n  const thinkingConfig = provider === PROVIDERS.GEMINI ? resolveGeminiThinkingConfig(model, geminiReasoningEffort) : null;\n\n  const cacheEnabled = normalizeBoolean(req?.cache, DEFAULTS.cache);\n  const ttlSec = clampInt(\n    req?.cacheTtlSec ?? DEFAULTS.cacheTtlSec,\n    1,\n    365 * 24 * 3600,\n    DEFAULTS.cacheTtlSec\n  );\n  const allowPersistentCache = cacheEnabled && shouldUsePersistentCache();\n\n  await syncCacheClearMarker();\n\n  // Cache key (no temperature anywhere)\n  const cacheKeyPayload = {\n    v: 3,\n    provider,\n    model,\n    maxOutputTokens,\n    reasoningEffort,\n    geminiReasoningEffort,\n    webSearch,\n    system,\n    user,\n    responseMimeType: req?.responseMimeType || \"\",\n    responseJsonSchema: req?.responseJsonSchema || null\n  };\n\n  const cacheKey = await hashKey(cacheKeyPayload);\n\n  if (cacheEnabled) {\n    const cached = CACHE.get(cacheKey);\n    if (cached) {\n      const formula = getFormulaForLog(fnName, cached?.text);\n      const recorded = recordBatchResult({\n        provider,\n        model,\n        ok: true,\n        cached: true,\n        usage: null,\n        ms: nowMs() - start\n      });\n      if (!recorded) {\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: true,\n          ms: nowMs() - start,\n          cache: true,\n          cacheKind: \"memory\",\n          reasoningEffort: reasoningEffortLabel || undefined,\n          call: functionCall || undefined,\n          inputTokens: 0,\n          outputTokens: 0,\n          reasoningTokens: 0,\n          totalTokens: 0,\n          formula: formula || undefined\n        });\n      }\n      if (recorded) finalizeBatchIfIdle();\n      return { ...cached, cached: true, cacheKind: \"memory\" };\n    }\n    if (allowPersistentCache) {\n      const persisted = await getPersistentCache(cacheKey);\n      if (persisted) {\n        const formula = getFormulaForLog(fnName, persisted?.text);\n        CACHE.set(cacheKey, persisted, ttlSec * 1000);\n        const recorded = recordBatchResult({\n          provider,\n          model,\n          ok: true,\n          cached: true,\n          usage: null,\n          ms: nowMs() - start\n        });\n        if (!recorded) {\n          logRequest({\n            fn: fnName,\n            provider,\n            model,\n            ok: true,\n            ms: nowMs() - start,\n            cache: true,\n            cacheKind: \"persistent\",\n            reasoningEffort: reasoningEffortLabel || undefined,\n            call: functionCall || undefined,\n            inputTokens: 0,\n            outputTokens: 0,\n            reasoningTokens: 0,\n            totalTokens: 0,\n            formula: formula || undefined\n          });\n        }\n        if (recorded) finalizeBatchIfIdle();\n        return { ...persisted, cached: true, cacheKind: \"persistent\" };\n      }\n    }\n  }\n\n  if (INFLIGHT.has(cacheKey)) return INFLIGHT.get(cacheKey);\n\n  const p = withConcurrencyLimit(async () => {\n    let attempt = 0;\n    let lastErr = null;\n\n    const callProvider = async (opts) =>\n      provider === PROVIDERS.OPENAI ? callOpenAI(opts) : callGemini(opts);\n\n    while (attempt <= retry) {\n      attempt++;\n      try {\n        const baseOpts = {\n          apiKey,\n          model,\n          system,\n          user,\n          cachePrefix: cachePrefix || undefined,\n          cacheSuffix: cacheSuffix || undefined,\n          maxOutputTokens,\n          reasoningEffort,\n          thinkingConfig,\n          timeoutMs,\n          webSearch,\n          responseMimeType: req?.responseMimeType,\n          responseJsonSchema: req?.responseJsonSchema\n        };\n\n        let result = await callProvider(baseOpts);\n\n        if (!result.ok && !isGeminiServiceUnavailable(provider, result)) {\n          let opts = baseOpts;\n\n          // Fallback #1: if web search fails, retry without tools.\n          if (opts.webSearch) {\n            const shouldRetryNoWeb =\n              looksLikeWebSearchUnsupported(result.message) || result.code === \"API_ERROR\" || result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryNoWeb) {\n              opts = { ...opts, webSearch: false };\n              result = await callProvider(opts);\n            }\n          }\n\n          // Fallback #2: if structured output fails, retry without schema/responseMimeType.\n          const wantsStructured = opts.responseMimeType || opts.responseJsonSchema;\n          if (!result.ok && wantsStructured) {\n            const shouldRetryPlainJson =\n              looksLikeStructuredOutputUnsupported(result.message) ||\n              result.code === \"API_ERROR\" ||\n              result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryPlainJson) {\n              opts = {\n                ...opts,\n                responseMimeType: undefined,\n                responseJsonSchema: undefined,\n                system: ensureJsonInstruction(opts.system)\n              };\n              result = await callProvider(opts);\n            }\n          }\n        }\n\n        const shouldRetryServiceUnavailable =\n          isGeminiServiceUnavailable(provider, result) && attempt <= gemini503RetryMax;\n\n        // Log (best-effort)\n        let usage = normalizeUsage(result?.usage);\n        const cacheAdjusted = provider === PROVIDERS.GEMINI && usage.cachedInputTokens > 0;\n        if (cacheAdjusted) {\n          usage = {\n            ...usage,\n            inputTokens: Math.max(0, usage.inputTokens - usage.cachedInputTokens)\n          };\n        }\n        const formula = result.ok ? getFormulaForLog(fnName, result.text) : \"\";\n\n        if (shouldRetryServiceUnavailable) {\n          await sleep(GEMINI_503_RETRY_DELAY_MS);\n          continue;\n        }\n\n        const recorded = recordBatchResult({\n          provider,\n          model,\n          ok: result.ok,\n          cached: false,\n          usage,\n          ms: nowMs() - start,\n          cacheAdjusted\n        });\n        if (!recorded) {\n          logRequest({\n            fn: fnName,\n            provider,\n            model,\n            ok: result.ok,\n            ms: nowMs() - start,\n            attempt,\n            cache: false,\n            reasoningEffort: reasoningEffortLabel || undefined,\n            call: functionCall || undefined,\n            inputTokens: usage.inputTokens,\n            outputTokens: usage.outputTokens,\n            reasoningTokens: usage.reasoningTokens,\n            cachedInputTokens: usage.cachedInputTokens,\n            totalTokens: usage.totalTokens,\n            code: result.code,\n            message: result.message,\n            formula: formula || undefined,\n            cacheHint: result.cacheHint || undefined,\n            cacheStorageTokenHours: result.cacheStorageTokenHours || 0,\n            cacheAdjusted\n          });\n        }\n\n        if (result.ok && cacheEnabled) {\n          CACHE.set(cacheKey, result, ttlSec * 1000);\n          if (allowPersistentCache) {\n            await setPersistentCache(cacheKey, result, ttlSec * 1000, { provider, model });\n          }\n        }\n\n        return result;\n      } catch (e) {\n        lastErr = e;\n        if (attempt <= retry) await sleep(250 * attempt);\n      }\n    }\n\n    const timeout = isTimeoutError(lastErr);\n    const code = timeout ? \"TIMEOUT\" : \"API_ERROR\";\n    const rawMsg = timeout ? \"Dlai dpass (timeout).\" : (lastErr?.message ? String(lastErr.message) : \"Erreur inconnue.\");\n    const msg = redactSensitiveText(rawMsg);\n    const recorded = recordBatchResult({\n      provider,\n      model,\n      ok: false,\n      cached: false,\n      usage: null,\n      ms: nowMs() - start\n    });\n    if (!recorded) {\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: false,\n        ms: nowMs() - start,\n        cache: false,\n        reasoningEffort: reasoningEffortLabel || undefined,\n        call: functionCall || undefined,\n        code,\n        message: msg\n      });\n    }\n    return { ok: false, provider, model, code, message: msg };\n  });\n\n  INFLIGHT.set(cacheKey, p);\n\n  try {\n    const result = await p;\n    if (result?.code === \"QUEUE_CANCELLED\") {\n      const recorded = recordBatchResult({\n        provider,\n        model,\n        ok: false,\n        cached: false,\n        usage: null,\n        ms: nowMs() - start\n      });\n      if (!recorded) {\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: false,\n          ms: nowMs() - start,\n          cache: false,\n          reasoningEffort: reasoningEffortLabel || undefined,\n          call: functionCall || undefined,\n          inputTokens: 0,\n          outputTokens: 0,\n          reasoningTokens: 0,\n          cachedInputTokens: 0,\n          totalTokens: 0,\n          code: result.code,\n          message: result.message\n        });\n      }\n    }\n    return result;\n  } finally {\n    INFLIGHT.delete(cacheKey);\n  }\n}\n\n/**\n * Lightweight connectivity test for a provider (used from taskpane and AI.TEST()).\n */\nexport async function aiMinimalTest(providerOverride) {\n  const provider = normalizeProvider(providerOverride) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n\n  if (!apiKey) {\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  // Tiny request\n  return await aiGenerate({\n    provider,\n    system: \"You are a test endpoint. Reply with exactly: OK\",\n    user: \"OK\",\n    maxOutputTokens: 500,\n    cache: false,\n    webSearch: false,\n    functionName: \"AI.MINIMAL_TEST\"\n  });\n}\n\n// ---- Provider: Gemini (Google Generative Language API) ----\n\nfunction geminiEndpoint(model) {\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent`;\n}\n\nasync function callGemini({\n  apiKey,\n  model,\n  system,\n  user,\n  cachePrefix,\n  cacheSuffix,\n  maxOutputTokens,\n  thinkingConfig,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema,\n  disableCache = false\n}) {\n  const url = geminiEndpoint(model);\n  let cacheHint = \"\";\n  let cachedContentName = \"\";\n  let cachedContentKey = \"\";\n  let userText = user;\n\n  const systemText = isNonEmptyString(system)\n    ? ((responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system)\n    : \"\";\n\n  const shouldUseExplicitCache = !disableCache\n    && !webSearch\n    && isNonEmptyString(cachePrefix)\n    && isNonEmptyString(cacheSuffix)\n    && cacheSuffix.trim().length >= GEMINI_CACHED_CONTENT_MIN_SUFFIX_CHARS;\n\n  if (shouldUseExplicitCache) {\n    const cached = await ensureGeminiCachedContent({\n      apiKey,\n      model,\n      system: systemText,\n      prefix: cachePrefix,\n      ttlMs: GEMINI_CACHED_CONTENT_TTL_MS,\n      timeoutMs\n    });\n    if (cached?.name) {\n      cachedContentName = cached.name;\n      cachedContentKey = cached.cacheKey || \"\";\n      userText = cacheSuffix;\n      cacheHint = \"gemini_cached_content\";\n    }\n  }\n\n  const body = {\n    contents: [{ role: \"user\", parts: [{ text: userText }] }],\n    generationConfig: {\n      maxOutputTokens\n    }\n  };\n\n  if (thinkingConfig && typeof thinkingConfig === \"object\") {\n    body.generationConfig.thinkingConfig = thinkingConfig;\n  }\n\n  if (isNonEmptyString(systemText) && !cachedContentName) {\n    // API uses lowerCamelCase for this field in JSON representation\n    // Force explicit JSON instruction for robustness\n    body.systemInstruction = { role: \"system\", parts: [{ text: systemText }] };\n  }\n\n  // Structured output (JSON) when requested\n  if (responseMimeType) {\n    body.generationConfig.responseMimeType = responseMimeType;\n  }\n  if (responseJsonSchema) {\n    body.generationConfig.responseSchema = responseJsonSchema;\n  }\n\n  // Web grounding tool\n  if (webSearch) {\n    // For REST v1beta, the tool name is usually google_search (snake_case).\n    // Note: Some newer endpoints might respect googleSearch, but snake_case is safer for REST.\n    body.tools = [{ google_search: {} }];\n  }\n  if (cachedContentName) {\n    body.cachedContent = cachedContentName;\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-goog-api-key\": apiKey\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n  const errInfo = extractGeminiErrorInfo(json);\n\n  if (errInfo?.message) {\n    if (cachedContentKey && looksLikeCachedContentInvalid(errInfo.message)) {\n      GEMINI_CACHED_CONTENT.delete(cachedContentKey);\n      return await callGemini({\n        apiKey,\n        model,\n        system,\n        user,\n        cachePrefix,\n        cacheSuffix,\n        maxOutputTokens,\n        thinkingConfig,\n        timeoutMs,\n        webSearch,\n        responseMimeType,\n        responseJsonSchema,\n        disableCache: true\n      });\n    }\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: errInfo.status ?? res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(errInfo.message),\n      cacheHint\n    };\n  }\n\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    if (cachedContentKey && looksLikeCachedContentInvalid(msg)) {\n      GEMINI_CACHED_CONTENT.delete(cachedContentKey);\n      return await callGemini({\n        apiKey,\n        model,\n        system,\n        user,\n        cachePrefix,\n        cacheSuffix,\n        maxOutputTokens,\n        thinkingConfig,\n        timeoutMs,\n        webSearch,\n        responseMimeType,\n        responseJsonSchema,\n        disableCache: true\n      });\n    }\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(msg),\n      cacheHint\n    };\n  }\n\n  const text = extractGeminiText(json);\n  const sources = extractGeminiSources(json);\n  const usage = extractGeminiUsage(json);\n  let cacheStorageTokenHours = 0;\n\n  if (cacheHint === \"gemini_cached_content\" && cachedContentKey && usage?.cachedInputTokens > 0) {\n    const entry = GEMINI_CACHED_CONTENT.get(cachedContentKey);\n    const alreadyCharged = entry?.chargedTokenHours && entry.chargedTokenHours > 0;\n    if (!alreadyCharged) {\n      const createdAtMs = Number(entry?.createdAtMs) || 0;\n      const expiresAtMs = Number(entry?.expiresAtMs) || 0;\n      let ttlMs = 0;\n      if (createdAtMs > 0 && expiresAtMs > createdAtMs) {\n        ttlMs = expiresAtMs - createdAtMs;\n      } else {\n        ttlMs = GEMINI_CACHED_CONTENT_TTL_MS;\n      }\n      if (ttlMs > 0) {\n        const ttlHours = ttlMs / 3600000;\n        cacheStorageTokenHours = Math.max(0, Number(usage.cachedInputTokens) || 0) * ttlHours;\n        if (entry && cacheStorageTokenHours > 0) {\n          entry.chargedTokenHours = cacheStorageTokenHours;\n          GEMINI_CACHED_CONTENT.set(cachedContentKey, entry);\n        }\n      }\n    }\n  }\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide de Gemini.\",\n      cacheHint\n    };\n  }\n\n  return {\n    ok: true,\n    provider: PROVIDERS.GEMINI,\n    model,\n    text: text.trim(),\n    sources,\n    usage,\n    cacheHint,\n    cacheStorageTokenHours: cacheStorageTokenHours || 0\n  };\n}\n\nfunction extractGeminiText(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const parts = c?.content?.parts;\n    if (Array.isArray(parts)) {\n      return parts.map((p) => p?.text || \"\").join(\"\");\n    }\n    return \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiErrorInfo(json) {\n  try {\n    const err = json?.error;\n    if (!err) return null;\n    const msg = err?.message;\n    const statusCode = Number(err?.code);\n    return {\n      message: msg ? String(msg) : \"\",\n      status: Number.isFinite(statusCode) ? statusCode : undefined\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractGeminiSources(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const md = c?.groundingMetadata;\n    const chunks = md?.groundingChunks;\n    if (!Array.isArray(chunks)) return [];\n\n    const out = [];\n    for (const ch of chunks) {\n      const web = ch?.web;\n      if (!web?.uri) continue;\n      out.push({ title: web?.title || \"\", url: web.uri });\n    }\n\n    return dedupeSources(out);\n  } catch {\n    return [];\n  }\n}\n\n// ---- Provider: OpenAI (Responses API) ----\n\nasync function callOpenAI({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  reasoningEffort,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = \"https://api.openai.com/v1/responses\";\n\n  const body = {\n    model,\n    input: user, // Responses API uses 'input' (string or array of objects)\n    max_output_tokens: maxOutputTokens,\n    store: false\n  };\n\n  if (isNonEmptyString(reasoningEffort)) {\n    body.reasoning = { effort: reasoningEffort };\n  }\n\n  // System prompt\n  if (isNonEmptyString(system)) {\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.instructions = sysText;\n  }\n\n  // Structured output (JSON)\n  // - If a JSON schema is provided: use json_schema strict mode.\n  // - Else if responseMimeType is JSON: request a json_object.\n  if (responseJsonSchema) {\n    // For GPT-5 Mini / v1/responses, we try to use the most standard way if possible.\n    // If body.text format fails, we rely on the prompt.\n    // We kept the previous implementation but added prompt reinforcement.\n    body.text = {\n      format: {\n        type: \"json_schema\",\n        name: \"excel_ai_schema\",\n        strict: true,\n        schema: responseJsonSchema\n      }\n    };\n  } else if (responseMimeType === \"application/json\") {\n    body.text = { format: { type: \"json_object\" } };\n  }\n\n  // Web search tool\n  if (webSearch) {\n    body.tools = [{ type: \"web_search\" }];\n    body.include = [\"web_search_call.action.sources\"];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n\n  if (!res.ok) {\n    const msg = extractOpenAIError(json) || `OpenAI API error (${res.status}).`;\n    return { ok: false, provider: PROVIDERS.OPENAI, model, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n  }\n\n  const text = extractOpenAIText(json);\n  const sources = webSearch ? extractOpenAISources(json) : [];\n  const usage = extractOpenAIUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.OPENAI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide d'OpenAI.\"\n    };\n  }\n\n  return { ok: true, provider: PROVIDERS.OPENAI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractOpenAIText(json) {\n  // 1. Try direct output_text (common in simple Responses)\n  try {\n    if (typeof json?.output_text === \"string\" && json.output_text.trim()) {\n      return json.output_text;\n    }\n  } catch {\n    // ignore\n  }\n\n  // 2. Try iterating over 'output' items (complex/agentic responses)\n  try {\n    const out = json?.output;\n    if (Array.isArray(out)) {\n      const texts = [];\n      for (const item of out) {\n        if (typeof item?.text === \"string\" && item.text.trim()) texts.push(item.text);\n        if (typeof item?.output_text === \"string\" && item.output_text.trim()) texts.push(item.output_text);\n        if (item?.type === \"output_text\" && typeof item?.text === \"string\") texts.push(item.text);\n        if (item?.type === \"text\" && typeof item?.text === \"string\") texts.push(item.text);\n\n        // Standard message output\n        if (item?.type === \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n\n        if (item?.type !== \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n      }\n      if (texts.length > 0) return texts.join(\"\\n\").trim();\n    }\n  } catch {\n    // ignore\n  }\n\n  // 3. Fallback: Chat Completions style (just in case model acts differently)\n  try {\n    return json?.choices?.[0]?.message?.content || \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAIError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAISources(json) {\n  try {\n    const out = json?.output;\n    if (!Array.isArray(out)) return [];\n\n    const sources = [];\n    for (const item of out) {\n      if (item?.type !== \"web_search_call\") continue;\n      const s = item?.action?.sources;\n      if (!Array.isArray(s)) continue;\n      for (const src of s) {\n        if (!src?.url) continue;\n        sources.push({ title: src?.title || \"\", url: src.url });\n      }\n    }\n\n    return dedupeSources(sources);\n  } catch {\n    return [];\n  }\n}\n\nfunction extractGeminiUsage(json) {\n  try {\n    const u = json?.usageMetadata;\n    if (!u) return null;\n    return {\n      inputTokens: toInt(u?.promptTokenCount),\n      outputTokens: toInt(u?.candidatesTokenCount),\n      reasoningTokens: toInt(u?.thoughtsTokenCount),\n      totalTokens: toInt(u?.totalTokenCount),\n      cachedInputTokens: toInt(u?.cachedContentTokenCount)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractOpenAIUsage(json) {\n  try {\n    const u = json?.usage;\n    if (!u) return null;\n    const rawOutputTokens = toInt(u?.output_tokens);\n    const reasoningTokens = toInt(u?.output_tokens_details?.reasoning_tokens);\n    const outputTokens = Math.max(0, rawOutputTokens - reasoningTokens);\n    return {\n      inputTokens: toInt(u?.input_tokens),\n      outputTokens,\n      reasoningTokens,\n      totalTokens: toInt(u?.total_tokens),\n      cachedInputTokens: toInt(u?.input_tokens_details?.cached_tokens)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction normalizeUsage(usage) {\n  if (!usage || typeof usage !== \"object\") {\n    return { inputTokens: 0, outputTokens: 0, reasoningTokens: 0, totalTokens: 0, cachedInputTokens: 0 };\n  }\n  const inputTokens = toInt(usage.inputTokens);\n  const outputTokens = toInt(usage.outputTokens);\n  const reasoningTokens = toInt(usage.reasoningTokens);\n  const cachedInputTokens = toInt(usage.cachedInputTokens);\n  const reportedTotal = toInt(usage.totalTokens);\n  const computedTotal = inputTokens + outputTokens + reasoningTokens;\n  const totalTokens = Math.max(reportedTotal, computedTotal);\n  return {\n    inputTokens,\n    outputTokens,\n    reasoningTokens,\n    totalTokens,\n    cachedInputTokens\n  };\n}\n\nfunction toInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nexport async function clearAllCaches() {\n  CACHE.clear();\n  await clearPersistentCache();\n}\n\nexport async function listGeminiCachedContents(options = {}) {\n  const apiKey = await getApiKey(PROVIDERS.GEMINI);\n  if (!apiKey) {\n    return { ok: false, code: \"API_KEY_MISSING\", message: \"Cl API manquante pour Gemini.\" };\n  }\n  const pageSize = clampInt(options?.pageSize ?? 50, 1, 100, 50);\n  const maxPages = clampInt(options?.maxPages ?? 3, 1, 5, 3);\n  const allPages = !!options?.all;\n  let pageToken = isNonEmptyString(options?.pageToken) ? String(options.pageToken) : \"\";\n  let pages = 0;\n  const caches = [];\n\n  while (pages < maxPages) {\n    pages += 1;\n    const url = new URL(\"https://generativelanguage.googleapis.com/v1beta/cachedContents\");\n    url.searchParams.set(\"pageSize\", String(pageSize));\n    if (pageToken) url.searchParams.set(\"pageToken\", pageToken);\n\n    const res = await fetchWithTimeout(url.toString(), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-goog-api-key\": apiKey\n      }\n    }, 30000);\n\n    const json = await safeJson(res);\n    if (!res.ok) {\n      const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n      return { ok: false, status: res.status, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n    }\n\n    const list = Array.isArray(json?.cachedContents)\n      ? json.cachedContents\n      : (Array.isArray(json?.cachedContent) ? json.cachedContent : []);\n    caches.push(...list);\n\n    pageToken = isNonEmptyString(json?.nextPageToken) ? String(json.nextPageToken) : \"\";\n    if (!allPages || !pageToken) break;\n  }\n\n  return { ok: true, caches, nextPageToken: pageToken || \"\", pages };\n}\n\nexport async function deleteGeminiCachedContent(name) {\n  const apiKey = await getApiKey(PROVIDERS.GEMINI);\n  if (!apiKey) {\n    return { ok: false, code: \"API_KEY_MISSING\", message: \"Cl API manquante pour Gemini.\" };\n  }\n  const path = String(name || \"\").trim();\n  if (!path) return { ok: false, code: \"INVALID_NAME\", message: \"Nom de cache invalide.\" };\n\n  const url = `https://generativelanguage.googleapis.com/v1beta/${encodeURI(path)}`;\n  const res = await fetchWithTimeout(url, {\n    method: \"DELETE\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-goog-api-key\": apiKey\n    }\n  }, 30000);\n\n  const json = await safeJson(res);\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    return { ok: false, status: res.status, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n  }\n\n  for (const [key, entry] of GEMINI_CACHED_CONTENT.entries()) {\n    if (entry?.name && entry.name === path) {\n      GEMINI_CACHED_CONTENT.delete(key);\n    }\n  }\n\n  return { ok: true };\n}\n\nfunction dedupeSources(list) {\n  const seen = new Set();\n  const out = [];\n  for (const s of list || []) {\n    const url = String(s?.url || \"\").trim();\n    if (!url) continue;\n    const key = url.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push({ title: String(s?.title || \"\").trim(), url });\n  }\n  return out;\n}\n\n// ---- Helpers: fetch + timeout + JSON parsing ----\n\nasync function fetchWithTimeout(url, options, timeoutMs) {\n  const t = normalizeTimeoutMs(timeoutMs);\n\n  if (typeof AbortController === \"undefined\") {\n    // Basic fetch without cancellation (should be rare in modern Office runtimes)\n    return await fetch(url, options);\n  }\n\n  const ctrl = new AbortController();\n  const id = setTimeout(() => ctrl.abort(), t);\n\n  try {\n    return await fetch(url, { ...options, signal: ctrl.signal });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nasync function safeJson(res) {\n  try {\n    return await res.json();\n  } catch {\n    return {};\n  }\n}\n","// src/functions/functions.js\n// Custom Functions implementation.\n//\n// IMPORTANT: Formulas must NOT accept provider or sampling options.\n// - Provider is selected in the taskpane (default provider).\n// - No temperature/top-p are used anywhere.\n//\n// This file is bundled by webpack into dist/functions.js and loaded in the shared runtime.\n\nimport { aiGenerate, aiMinimalTest } from \"../shared/providers.js\";\nimport {\n  PROVIDERS,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getMaxOutputTokens,\n  storageBackendName,\n} from \"../shared/core.js\";\n\n// Excel cell text limit is 32,767 characters. Keep a safety margin.\nconst EXCEL_CELL_CHAR_LIMIT = 32000;\n\n// Defensive caps to avoid runaway prompts in spreadsheets.\nconst MAX_CONTEXT_CHARS = 9000;\nconst FORMULA_ARG_MAX = 120;\nconst MAX_LIST_ITEMS = 200;\nconst MAX_BATCH_CELLS = Number.POSITIVE_INFINITY; // for batch operations (CLASSIFY/TRANSLATE/etc.)\nconst DEFAULT_LANG = \"fr\";\n\nfunction getExcelLocale() {\n  try {\n    if (typeof Office !== \"undefined\" && Office?.context) {\n      const lang = Office.context.displayLanguage || Office.context.contentLanguage;\n      if (lang) return String(lang);\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    if (typeof navigator !== \"undefined\" && navigator?.language) {\n      return String(navigator.language);\n    }\n  } catch {\n    // ignore\n  }\n\n  return DEFAULT_LANG;\n}\n\nfunction isFrenchLocale(locale) {\n  return String(locale || \"\").toLowerCase().startsWith(\"fr\");\n}\n\nfunction isMatrix(v) {\n  return Array.isArray(v);\n}\n\nfunction normalizeToMatrix(v) {\n  if (Array.isArray(v)) {\n    if (v.length === 0) return [[]];\n    if (Array.isArray(v[0])) return v;\n    return [v];\n  }\n  return [[v]];\n}\n\nfunction toScalarString(v) {\n  if (v == null) return \"\";\n  if (typeof v === \"string\") return v;\n  if (typeof v === \"number\") return String(v);\n  if (typeof v === \"boolean\") return v ? \"TRUE\" : \"FALSE\";\n  try {\n    return String(v);\n  } catch {\n    return \"\";\n  }\n}\n\nfunction truncateForCell(text) {\n  const s = String(text || \"\");\n  if (s.length <= EXCEL_CELL_CHAR_LIMIT) return s;\n  return s.slice(0, EXCEL_CELL_CHAR_LIMIT - 1) + \"\";\n}\n\nfunction matrixToTSV(matrix, maxChars = MAX_CONTEXT_CHARS) {\n  const m = normalizeToMatrix(matrix);\n  const limit = Math.max(0, Number(maxChars) || 0);\n  const parts = [];\n  let length = 0;\n  let truncated = false;\n\n  const append = (chunk) => {\n    if (!chunk || truncated) return;\n    if (length + chunk.length <= limit) {\n      parts.push(chunk);\n      length += chunk.length;\n      return;\n    }\n    const remaining = Math.max(0, limit - length);\n    if (remaining > 0) {\n      parts.push(chunk.slice(0, remaining));\n      length += remaining;\n    }\n    truncated = true;\n  };\n\n  for (let i = 0; i < m.length && !truncated; i++) {\n    const row = Array.isArray(m[i]) ? m[i] : [m[i]];\n    if (i > 0) append(\"\\n\");\n    for (let j = 0; j < row.length && !truncated; j++) {\n      if (j > 0) append(\"\\t\");\n      append(toScalarString(row[j]));\n    }\n  }\n\n  let out = parts.join(\"\");\n  if (truncated) out += \"\\n\";\n  return out;\n}\n\nfunction formatFormulaText(value, maxChars = FORMULA_ARG_MAX) {\n  let s = String(value ?? \"\");\n  s = s.replace(/\\r?\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\");\n  if (s.length > maxChars) s = s.slice(0, Math.max(0, maxChars - 3)) + \"...\";\n  s = s.replace(/\"/g, '\"\"');\n  return `\"${s}\"`;\n}\n\nfunction formatFormulaArg(value) {\n  if (value === undefined || value === null) return \"\";\n  if (typeof value === \"number\" && Number.isFinite(value)) return String(value);\n  if (typeof value === \"boolean\") return value ? \"TRUE\" : \"FALSE\";\n  if (Array.isArray(value)) {\n    const preview = matrixToTSV(value, FORMULA_ARG_MAX).replace(//g, \"...\");\n    return formatFormulaText(preview, FORMULA_ARG_MAX);\n  }\n  return formatFormulaText(value, FORMULA_ARG_MAX);\n}\n\nfunction buildFormulaCall(name, args = []) {\n  const formatted = args.map(formatFormulaArg);\n  let last = formatted.length - 1;\n  while (last >= 0 && formatted[last] === \"\") last--;\n  const trimmed = formatted.slice(0, last + 1);\n  return `=${name}(${trimmed.join(\",\")})`;\n}\n\nfunction flattenMatrix(matrix, maxItems = MAX_LIST_ITEMS) {\n  const m = normalizeToMatrix(matrix);\n  const out = [];\n  for (const row of m) {\n    const r = Array.isArray(row) ? row : [row];\n    for (const cell of r) {\n      out.push(toScalarString(cell));\n      if (out.length >= maxItems) return out;\n    }\n  }\n  return out;\n}\n\nfunction parseShowSource(showSource) {\n  // Allowed \"options\" exception: 0/1 numeric flag for AI.WEB\n  const n = Number(showSource);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseSummarizeMode(mode) {\n  const n = Number(mode);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseLabels(labels) {\n  if (isMatrix(labels)) {\n    const flat = flattenMatrix(labels, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n    return dedupe(flat);\n  }\n\n  const s = toScalarString(labels);\n  const parts = s\n    .split(/[,\\|;\\n\\r]+/)\n    .map((x) => x.trim())\n    .filter(Boolean);\n  return dedupe(parts);\n}\n\nfunction dedupe(list) {\n  const seen = new Set();\n  const out = [];\n  for (const x of list) {\n    const k = x.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(x);\n  }\n  return out;\n}\n\nfunction makeSourcesBlock(sources, max = 8) {\n  const src = Array.isArray(sources) ? sources : [];\n  const list = src.slice(0, max);\n  if (!list.length) return \"\";\n\n  const lines = [\"\", \"Sources:\"];\n  let i = 1;\n  for (const s of list) {\n    const title = (s?.title || \"\").trim();\n    const url = (s?.url || \"\").trim();\n    if (!url) continue;\n    lines.push(`${i}. ${title ? title + \" - \" : \"\"}${url}`);\n    i++;\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction cfError(code, message) {\n  try {\n    if (typeof CustomFunctions !== \"undefined\" && CustomFunctions?.Error) {\n      const errCode = code || CustomFunctions.ErrorCode.invalidValue;\n      return new CustomFunctions.Error(errCode, message);\n    }\n  } catch {\n    // ignore\n  }\n  return `#ERROR: ${message}`;\n}\n\nfunction parseJsonSafe(text) {\n  const s = String(text || \"\").trim();\n\n  // 1. Try to find a markdown code block anywhere in the string\n  const codeBlockMatch = s.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n  if (codeBlockMatch) {\n    return JSON.parse(codeBlockMatch[1]);\n  }\n\n  // 2. If no code block, try to parse the whole string first.\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    // 3. Fallback: try to locate substring starting with {|[ and ending with }|]\n    // Simple heuristic: find first { and last }\n    const firstCurly = s.indexOf(\"{\");\n    const lastCurly = s.lastIndexOf(\"}\");\n    if (firstCurly !== -1 && lastCurly > firstCurly) {\n      try {\n        return JSON.parse(s.slice(firstCurly, lastCurly + 1));\n      } catch { } // ignore\n    }\n\n    const firstSquare = s.indexOf(\"[\");\n    const lastSquare = s.lastIndexOf(\"]\");\n    if (firstSquare !== -1 && lastSquare > firstSquare) {\n      try {\n        return JSON.parse(s.slice(firstSquare, lastSquare + 1));\n      } catch { }\n    }\n\n    throw e; // Original parse error\n  }\n}\n\n// ---- System prompts (no sampling controls) ----\n\nconst NO_CLARIFY = \"Never ask clarifying questions. If information is missing, make reasonable assumptions and proceed.\";\n\nfunction sysAsk(lang = \"fr\") {\n  return [\n    \"You are an assistant embedded in Microsoft Excel custom functions.\",\n    `Respond in ${lang}.`,\n    \"Return a clear and accurate answer suitable for an Excel cell.\",\n    NO_CLARIFY,\n    \"No Markdown. No code fences. No surrounding quotes.\",\n    \"If the question cannot be answered from the provided information, say so briefly.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTranslate(targetLang, expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  if (n > 1) {\n    return [\n      \"You are a translation engine.\",\n      `Translate each cell independently into ${targetLang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${n} strings in the same order as the provided cells.`,\n      \"Each item must contain ONLY the translated text for that cell.\",\n      \"Preserve numbers, units, and identifiers as-is unless they require translation.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not add any keys other than 'items'.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a translation engine.\",\n    `Translate the user text into ${targetLang}.`,\n    NO_CLARIFY,\n    \"Return only the translated text. No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClassify(labels, lang = \"en\") {\n  return [\n    \"You are a strict classifier.\",\n    `Return exactly one label from this set, using the label text verbatim: ${labels.join(\" | \")}`,\n    \"Do not translate, expand, or paraphrase labels.\",\n    \"If uncertain, return exactly: UNKNOWN\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    \"Return only the label.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClean(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You are a text normalizer for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Preserve the meaning of each cell independently.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not invent or merge content.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a text normalizer for spreadsheet cells.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return only the cleaned text.\",\n    \"No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysConsistent(lang = \"fr\", expectedItems) {\n  return [\n    \"You harmonize spreadsheet entries that refer to the same real-world value.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n    \"Normalize casing, accents, spacing, and fix obvious typos.\",\n    \"When several cells refer to the same entity, use ONE consistent, best-written value for all of them.\",\n    \"Keep outputs aligned with inputs; do not merge or reorder rows.\",\n    \"If an input is empty or whitespace-only, return an empty string for that position.\",\n    \"Do not invent new information beyond correcting the given values.\"\n  ].join(\"\\n\");\n}\n\nfunction sysSummarize(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You summarize text for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Summarize each cell independently; do not merge content across cells.\",\n      \"Use bullet points with '-' when it improves readability.\",\n      \"Keep outputs aligned with inputs. If an input is empty or whitespace-only, return an empty string for that position.\",\n      \"No Markdown headers. No code fences. No surrounding quotes.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You summarize text for a spreadsheet cell.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return a clear summary suitable for an Excel cell.\",\n    \"Use bullet points with '-' when it improves readability.\",\n    \"No Markdown headers. No code fences. No surrounding quotes.\"\n  ].join(\"\\n\");\n}\n\nfunction sysExtract(instruction, lang = \"fr\", expectedItems) {\n  const strictArray =\n    typeof expectedItems === \"number\" && expectedItems > 0\n      ? `Return an object with a single key 'items' which is an array of exactly ${expectedItems} strings, preserving order.`\n      : \"Return an object with a single key 'items' which is an array of strings.\";\n\n  return [\n    \"You are an expert extraction engine.\",\n    `Goal: Extract all entities matching this description: \"${instruction}\"`,\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Lightly normalize results (trim spaces, fix obvious email obfuscation like [at]/(at) -> @ and [dot]/(dot)/point -> .).\",\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    strictArray,\n    \"Example: { \\\"items\\\": [\\\"match1\\\", \\\"match2\\\"] }\",\n    typeof expectedItems === \"number\"\n      ? \"If a value is missing for a cell, return an empty string in that position.\"\n      : \"If nothing found, return { \\\"items\\\": [] }.\",\n    \"Extract exact values from the text without inventing data.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFill(lang = \"fr\", expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  const spec = n > 0\n    ? `Return an object with a single key 'values' containing exactly ${n} strings, in the same order as the target rows.`\n    : \"Return an object with a single key 'values' containing an array of strings.\";\n\n  return [\n    \"You are filling spreadsheet cells based on examples.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    spec,\n    \"Return only the values, in order, one per target row.\",\n    \"If a value is unknown, return an empty string for that row.\",\n    \"Do not add any keys other than 'values'.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFormula(lang) {\n  const isFr = (lang || \"\").toLowerCase().startsWith(\"fr\");\n  return [\n    \"You are an expert Excel formula generator.\",\n    \"Your goal is to output a VALID Excel formula string based on the user request.\",\n    \"Leverage advanced Excel capabilities (dynamic arrays, LET/LAMBDA, structured references, advanced date/time, lookup, statistics, financial functions) when relevant.\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    isFr\n      ? \"Use FRENCH Excel function names (e.g., SOMME, SI, RECHERCHEV...).\"\n      : \"Use ENGLISH Excel function names (e.g., SUM, IF, VLOOKUP...).\",\n    isFr ? \"Use SEMICOLON (;) as argument separator.\" : \"Use COMMA (,) as argument separator.\",\n    \"Return exactly one ready-to-use Excel formula with no surrounding text.\",\n    \"Return ONLY the formula starting with '='.\",\n    \"No Markdown. No code fences. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTable() {\n  return [\n    \"You generate tables for Excel.\",\n    NO_CLARIFY,\n    \"Return JSON that matches the provided schema.\",\n    \"Do not include any extra keys.\",\n    \"Use strings for all cell values.\"\n  ].join(\" \");\n}\nfunction sysWeb(lang = \"fr\") {\n  return [\n    \"You are a meticulous fact-finding assistant with access to reliable web knowledge.\",\n    NO_CLARIFY,\n    \"Return only one precise, up-to-date factual value plus the best authoritative source URL.\",\n    \"Never fabricate numbers or URLs. Use official or authoritative sources only.\",\n    \"Match the requested timeframe and scope exactly; ignore partial or approximate figures.\",\n    \"If the data cannot be confirmed with high confidence, return empty strings and explain why in a 'reason' field.\",\n    `Respond in ${lang}.`,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    'Schema: {\"value\": \"<concise value>\", \"source\": \"https://...\", \"reason\": \"<why unavailable>\"}.',\n    \"The value must mirror the source exactly and stay under 80 characters.\"\n  ].join(\"\\n\");\n}\n\n// ---- Custom Functions ----\n\nexport async function KEY_STATUS() {\n  try {\n    const provider = await getDefaultProvider();\n    const maxTok = await getMaxOutputTokens();\n\n    const gemKey = await getApiKey(PROVIDERS.GEMINI);\n    const oaiKey = await getApiKey(PROVIDERS.OPENAI);\n\n    const gemModel = await getModel(PROVIDERS.GEMINI);\n    const oaiModel = await getModel(PROVIDERS.OPENAI);\n\n    const lines = [\n      `Default provider: ${provider}`,\n      `Max output tokens: ${maxTok}`,\n      `Gemini: ${gemKey ? \"key set\" : \"key missing\"} / model: ${gemModel}`,\n      `OpenAI: ${oaiKey ? \"key set\" : \"key missing\"} / model: ${oaiModel}`,\n      `Storage: ${storageBackendName()}`\n    ];\n\n    return lines.join(\"\\n\");\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, e?.message || \"Erreur KEY_STATUS.\");\n  }\n}\n\nexport async function TEST() {\n  const r = await aiMinimalTest();\n  if (r.ok) return \"OK\";\n  return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Test chou.\");\n}\n\nexport async function ASK(prompt, contextRange) {\n  const q = toScalarString(prompt).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre prompt est vide.\");\n\n  const hasContext = contextRange != null && isMatrix(contextRange);\n  const context = hasContext ? matrixToTSV(contextRange) : \"\";\n\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nQuestion:\\n${q}`\n    : q;\n\n  const r = await aiGenerate({\n    system: sysAsk(DEFAULT_LANG),\n    user,\n    webSearch: false,\n    functionName: \"AI.ASK\",\n    functionCall: buildFormulaCall(\"AI.ASK\", [prompt, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.ASK.\");\n\n  // Strip markdown bold/italic/headers to force plain text for Excel\n  let text = r.text || \"\";\n  text = text.replace(/\\*\\*/g, \"\").replace(/##/g, \"\").replace(/__/g, \"\");\n  return truncateForCell(text);\n}\n\nexport async function BATCH(prompt, contextRange) {\n  const q = toScalarString(prompt).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre prompt est vide.\");\n\n  let context = \"\";\n  if (contextRange != null) {\n    if (isMatrix(contextRange)) context = matrixToTSV(contextRange);\n    else context = toScalarString(contextRange).trim();\n  }\n  const hasContext = !!context;\n  const cachePrefix = hasContext ? `${q}\\n\\nContexte (TSV):\\n` : \"\";\n  const cacheSuffix = hasContext ? context : \"\";\n  const user = hasContext ? cachePrefix + cacheSuffix : q;\n\n  const r = await aiGenerate({\n    system: sysAsk(DEFAULT_LANG),\n    user,\n    webSearch: false,\n    functionName: \"AI.BATCH\",\n    functionCall: buildFormulaCall(\"AI.BATCH\", [prompt, contextRange]),\n    cachePrefix: hasContext ? cachePrefix : undefined,\n    cacheSuffix: hasContext ? cacheSuffix : undefined\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.BATCH.\");\n\n  let text = r.text || \"\";\n  text = text.replace(/\\*\\*/g, \"\").replace(/##/g, \"\").replace(/__/g, \"\");\n  return truncateForCell(text);\n}\n\nexport async function WEB(query, focus, showSource) {\n  const q = toScalarString(query).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre query est vide.\");\n\n  const context = focus != null && isMatrix(focus) ? matrixToTSV(focus) : \"\";\n  const user = context ? `Contexte (TSV):\\n${context}\\n\\nRequte web:\\n${q}` : q;\n\n  const r = await aiGenerate({\n    system: sysWeb(DEFAULT_LANG),\n    user,\n    webSearch: true,\n    functionName: \"AI.WEB\",\n    functionCall: buildFormulaCall(\"AI.WEB\", [query, focus, showSource])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.WEB.\");\n\n  let text = r.text || \"\";\n  let sources = Array.isArray(r.sources) ? r.sources : [];\n  let value = text;\n\n  try {\n    const obj = parseJsonSafe(text);\n    if (obj && typeof obj === \"object\") {\n      const v = toScalarString(obj.value).trim();\n      const src = toScalarString(obj.source).trim();\n      const reason = toScalarString(obj.reason).trim();\n      if (v) value = v;\n      else if (reason) value = reason;\n      if (src) sources = [{ title: \"\", url: src }];\n    }\n  } catch {\n    // Fallback to raw text + provider sources\n  }\n\n  const withSources = parseShowSource(showSource) === 1 ? value + makeSourcesBlock(sources) : value;\n  return truncateForCell(withSources);\n}\n\nexport async function TRANSLATE(textOrRange, targetLang) {\n  const lang = toScalarString(targetLang).trim();\n  if (!lang) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La langue cible est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.TRANSLATE.`\n    );\n  }\n\n  // Batch translation in one call for performance.\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      `Translate each item to: ${lang}.`,\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Translate to ${lang}:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysTranslate(lang, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.TRANSLATE\",\n    functionCall: buildFormulaCall(\"AI.TRANSLATE\", [textOrRange, targetLang])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TRANSLATE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // fall back: best-effort split, but log if empty\n      if (!r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Rponse vide (TRANSLATE).\");\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  // Normalize length\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  // Rebuild matrix\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLASSIFY(textOrRange, labels) {\n  const allowed = parseLabels(labels);\n  if (!allowed.length) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La liste de labels est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLASSIFY.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const labelList = allowed.join(\" | \");\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n\n  const user = isBatch\n    ? [\n      \"Classify each item into exactly one label from the allowed list.\",\n      `Allowed labels: ${labelList}`,\n      `Return JSON with items array of length ${expectedItems}. Use UNKNOWN if unsure.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : [\n      \"Classify the following text into exactly one allowed label.\",\n      `Allowed labels: ${labelList}`,\n      \"\",\n      flat[0] || \"\"\n    ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysClassify(allowed, DEFAULT_LANG),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLASSIFY\",\n    functionCall: buildFormulaCall(\"AI.CLASSIFY\", [textOrRange, labels])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLASSIFY.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"UNKNOWN\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const allowedLower = new Map(allowed.map((l) => [l.toLowerCase(), l]));\n  items = items.map((it) => {\n    const key = it.toLowerCase();\n    return allowedLower.get(key) || (it ? it : \"UNKNOWN\");\n  });\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"UNKNOWN\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function EXTRACT(textOrRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.EXTRACT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  // Single cell: allow multiple extracted items and return a vertical spill\n  if (flat.length === 1) {\n    const user = [\n      `Instruction: ${instr}`,\n      \"Input:\",\n      flat[0]\n    ].join(\"\\n\\n\");\n\n    const r = await aiGenerate({\n      system: sysExtract(instr, DEFAULT_LANG),\n      user,\n      responseMimeType: \"application/json\",\n      responseJsonSchema: schema,\n      functionName: \"AI.EXTRACT\",\n      functionCall: buildFormulaCall(\"AI.EXTRACT\", [textOrRange, instruction])\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n    let items = [];\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim()).filter(Boolean);\n    } catch {\n      // Best effort\n      items = r.text.split(\"\\n\").map((x) => x.trim()).filter(Boolean);\n      if (items.length === 0 && r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, `JSON Error: ${r.text.slice(0, 100)}`);\n    }\n\n    if (!items.length) return [[\"\"]];\n    return items.map((x) => [truncateForCell(x)]);\n  }\n\n  // Range: return exactly one extracted value per cell (best-effort)\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    `Instruction: ${instr}`,\n    `Return JSON with items array of length ${flat.length}.`,\n    \"Each item must be the best extracted value for the corresponding input (or empty string if none).\",\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysExtract(instr, DEFAULT_LANG, flat.length),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.EXTRACT_BATCH\",\n    functionCall: buildFormulaCall(\"AI.EXTRACT\", [textOrRange, instruction])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLEAN(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLEAN.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Clean each item for Excel (whitespace, line breaks).\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Clean this text for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysClean(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLEAN\",\n    functionCall: buildFormulaCall(\"AI.CLEAN\", [textOrRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLEAN.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CONSISTENT(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CONSISTENT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    \"Normalize each item so that near-duplicates become identical.\",\n    `Return JSON with items array of length ${expectedItems}.`,\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysConsistent(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.CONSISTENT\",\n    functionCall: buildFormulaCall(\"AI.CONSISTENT\", [textOrRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CONSISTENT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function FORMULA(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nDescription:\\n${desc}`\n    : desc;\n\n  const locale = getExcelLocale();\n  const formulaLang = isFrenchLocale(locale) ? \"fr\" : \"en\";\n\n  const r = await aiGenerate({\n    system: sysFormula(formulaLang),\n    user,\n    webSearch: false,\n    functionName: \"AI.FORMULA\",\n    functionCall: buildFormulaCall(\"AI.FORMULA\", [description, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FORMULA.\");\n\n  // Extract first formula starting with \"=\"\n  const text = (r.text || \"\").trim();\n  const m1 = text.match(/=[^\\n\\r]+/);\n  const formula = (m1 ? m1[0] : text).trim();\n\n  if (!formula.startsWith(\"=\")) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"La rponse n'est pas une formule Excel valide.\");\n  }\n  return truncateForCell(formula);\n}\n\nexport async function TABLE(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"headers\", \"rows\"],\n    properties: {\n      headers: { type: \"array\", items: { type: \"string\" } },\n      rows: {\n        type: \"array\",\n        items: {\n          type: \"array\",\n          items: { type: \"string\" }\n        }\n      }\n    }\n  };\n\n  const user = [\n    \"Build a table for Excel based on the description and optional context.\",\n    \"Return JSON { headers: [...], rows: [[...], ...] }\",\n    context ? `\\nContext (TSV):\\n${context}` : \"\",\n    `\\nDescription:\\n${desc}`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysTable(),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.TABLE\",\n    functionCall: buildFormulaCall(\"AI.TABLE\", [description, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TABLE.\");\n\n  let obj = null;\n  try {\n    obj = parseJsonSafe(r.text);\n  } catch {\n    // If strict parsing fails, try to just find the first JSON-like object\n    try {\n      const match = r.text.match(/\\{[\\s\\S]*\\}/);\n      if (match) obj = JSON.parse(match[0]);\n      else throw new Error();\n    } catch {\n      return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"Impossible de parser le JSON renvoy par l'IA.\");\n    }\n  }\n\n  const headers = Array.isArray(obj?.headers) ? obj.headers.map((x) => truncateForCell(toScalarString(x))) : [];\n  const rows = Array.isArray(obj?.rows) ? obj.rows : [];\n\n  const width = headers.length || (Array.isArray(rows?.[0]) ? rows[0].length : 0) || 1;\n  const safeHeaders = headers.length ? headers : Array.from({ length: width }, (_, i) => `Col${i + 1}`);\n\n  const out = [safeHeaders];\n\n  for (const r0 of rows) {\n    const row = Array.isArray(r0) ? r0.map((x) => truncateForCell(toScalarString(x))) : [];\n    // pad / truncate to width\n    while (row.length < safeHeaders.length) row.push(\"\");\n    if (row.length > safeHeaders.length) row.length = safeHeaders.length;\n    out.push(row);\n  }\n\n  return out;\n}\n\nexport async function FILL(exampleRange, targetRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const ex = normalizeToMatrix(exampleRange);\n  const tgt = normalizeToMatrix(targetRange);\n\n  const nRows = tgt.length;\n  if (nRows <= 0) return [[\"\"]];\n\n  if (nRows > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage cible trop grande (max ${MAX_BATCH_CELLS} lignes) pour AI.FILL.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"values\"],\n    properties: {\n      values: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const user = [\n    `Instruction: ${instr}`,\n    \"\",\n    \"Examples (TSV):\",\n    matrixToTSV(ex, 6000),\n    \"\",\n    \"Target rows (TSV):\",\n    matrixToTSV(tgt, 6000),\n    \"\",\n    `Return JSON with values array of length ${nRows} (one value per target row).`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysFill(DEFAULT_LANG, nRows),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.FILL\",\n    functionCall: buildFormulaCall(\"AI.FILL\", [exampleRange, targetRange, instruction])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FILL.\");\n\n  let values = [];\n  try {\n    const obj = JSON.parse(r.text);\n    if (Array.isArray(obj?.values)) values = obj.values.map((x) => toScalarString(x));\n  } catch {\n    values = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (values.length < nRows) values.push(\"\");\n  if (values.length > nRows) values = values.slice(0, nRows);\n\n  return values.map((v) => [truncateForCell(v)]);\n}\n\nexport async function SUMMARIZE(textOrRange, mode) {\n  const summarizeMode = parseSummarizeMode(mode);\n  const m = normalizeToMatrix(textOrRange);\n\n  if (summarizeMode === 1) {\n    const flat = flattenMatrix(m, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n\n    if (!flat.length) return [[\"\"]];\n\n    const joined = flat.join(\"\\n\");\n    const user = `Content:\\n${joined}`;\n\n    const r = await aiGenerate({\n      system: sysSummarize(DEFAULT_LANG),\n      user,\n      webSearch: false,\n      functionName: \"AI.SUMMARIZE\",\n      functionCall: buildFormulaCall(\"AI.SUMMARIZE\", [textOrRange, mode])\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n    return [[truncateForCell(r.text)]];\n  }\n\n  const flat = flattenMatrix(m, 2000).map((s) => s.trim());\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (!expectedItems) return [[\"\"]];\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Summarize each item for Excel.\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Summarize for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysSummarize(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.SUMMARIZE\",\n    functionCall: buildFormulaCall(\"AI.SUMMARIZE\", [textOrRange, mode])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport function COUNT(range, value) {\n  try {\n    const m = normalizeToMatrix(range);\n    const needle = toScalarString(value).toLowerCase();\n\n    let count = 0;\n    for (const row of m) {\n      const r = Array.isArray(row) ? row : [row];\n      for (const cell of r) {\n        if (toScalarString(cell).toLowerCase() === needle) count++;\n      }\n    }\n    return count;\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.invalidValue, e?.message || \"Erreur AI.COUNT.\");\n  }\n}\n\n// ---- Registration (robust for shared runtime timing) ----\n\nfunction registerAll() {\n  // Associate function names exactly as used in functions.json (ids map to namespace AI.*)\n  try {\n    if (typeof CustomFunctions === \"undefined\" || !CustomFunctions?.associate) return false;\n\n    const safeAssociate = (id, fn) => {\n      try {\n        CustomFunctions.associate(id, fn);\n        return true;\n      } catch {\n        return false;\n      }\n    };\n\n    let ok = true;\n    ok = safeAssociate(\"AI.KEYSTATUS\", KEY_STATUS) && ok;\n    ok = safeAssociate(\"AI.TEST\", TEST) && ok;\n    ok = safeAssociate(\"AI.ASK\", ASK) && ok;\n    ok = safeAssociate(\"AI.BATCH\", BATCH) && ok;\n    ok = safeAssociate(\"AI.WEB\", WEB) && ok;\n    ok = safeAssociate(\"AI.TRANSLATE\", TRANSLATE) && ok;\n    ok = safeAssociate(\"AI.CLASSIFY\", CLASSIFY) && ok;\n    ok = safeAssociate(\"AI.EXTRACT\", EXTRACT) && ok;\n    ok = safeAssociate(\"AI.CLEAN\", CLEAN) && ok;\n    ok = safeAssociate(\"AI.CONSISTENT\", CONSISTENT) && ok;\n    ok = safeAssociate(\"AI.FORMULA\", FORMULA) && ok;\n    ok = safeAssociate(\"AI.TABLE\", TABLE) && ok;\n    ok = safeAssociate(\"AI.FILL\", FILL) && ok;\n    ok = safeAssociate(\"AI.SUMMARIZE\", SUMMARIZE) && ok;\n    ok = safeAssociate(\"AI.COUNT\", COUNT) && ok;\n\n    return ok;\n  } catch {\n    return false;\n  }\n}\n\n// Poll until CustomFunctions is available (Office.js loads after functions.js in taskpane.html)\nconst regTimer = setInterval(() => {\n  if (registerAll()) clearInterval(regTimer);\n}, 200);\n"],"names":["PROVIDERS","Object","freeze","GEMINI","OPENAI","DEFAULTS","provider","geminiModel","openaiModel","geminiReasoningEffort","openaiReasoningEffort","maxOutputTokens","concurrencyLimit","rpmLimit","retry","timeoutMs","cache","cacheTtlSec","STORAGE_KEYS","DEFAULT_PROVIDER","GEMINI_API_KEY","OPENAI_API_KEY","GEMINI_MODEL","OPENAI_MODEL","GEMINI_REASONING_EFFORT","OPENAI_REASONING_EFFORT","MAX_OUTPUT_TOKENS","CONCURRENCY_LIMIT","RPM_LIMIT","ONBOARDING_SEEN","ONBOARDING_KEYS_CONFIRMED","SECTION_ORDER","SECTION_HIDDEN","LICENSE","PRIVACY_MODE","MIGRATION_DONE","REQUEST_LOG","REQUEST_LOG_CLEAR_AT","USAGE_TOTALS","CACHE_INDEX","CACHE_CLEAR_AT","RUNTIME_STATUS","SENSITIVE_KEYS","Set","LEGACY_KEYS","DEFAULT_PROVIDER_V2","GEMINI_API_KEY_V2","OPENAI_API_KEY_V2","GEMINI_MODEL_V2","OPENAI_MODEL_V2","GEMINI_MAX_TOKENS_V2","OPENAI_MAX_TOKENS_V2","_migrationPromise","_officeStorageFailed","_privacyModeCache","_privacyModeCacheAt","SETTINGS_CACHE_TTL_MS","_defaultProviderCache","_defaultProviderCacheAt","_maxOutputTokensCache","_maxOutputTokensCacheAt","_geminiReasoningCache","_geminiReasoningCacheAt","_openaiReasoningCache","_openaiReasoningCacheAt","_apiKeyCache","gemini","openai","_apiKeyCacheAt","_modelCache","_modelCacheAt","markOfficeStorageFailed","MEMORY_STORAGE","kind","storage","mem","Map","async","getItem","k","has","get","setItem","v","set","String","removeItem","delete","getRuntimeStorage","OfficeRuntime","window","localStorage","getLocalStorageSafe","localGet","local","key","localSet","value","localRemove","rawGet","options","sensitive","isSensitiveKey","allowLocalFallback","result","localValue","rawSet","stored","ensureMigrated","normalizeProvider","legacyProvider","legacy","candidates","map","x","parseInt","trim","filter","n","Number","isFinite","migrated","length","Math","max","p","s","toLowerCase","GEMINI_REASONING_EFFORTS","OPENAI_REASONING_EFFORTS","getDefaultProvider","now","nowMs","getApiKey","keyKey","trimmed","getModel","cached","raw","modelKey","resolved","getMaxOutputTokens","clampInt","CONCURRENCY_OPTIONS","setRuntimeStatus","status","normalized","active","queued","rpm","ts","MAX_SAFE_INTEGER","JSON","stringify","getPrivacyMode","enabled","loadPrivacyMode","Date","sleep","ms","Promise","resolve","setTimeout","min","fallback","REDACT_PATTERNS","redactSensitiveText","text","pattern","replace","redactSensitiveValue","Array","isArray","out","entry","entries","parseTimestampMs","CACHE_ENTRY_PREFIX","CACHE_INDEX_MAX_BYTES","_cacheClearMs","syncCacheClearMarker","clearedAt","loadCacheIndex","arr","parse","saveCacheIndex","removeCacheEntry","removed","rawRemove","removeFromCacheIndex","index","next","item","setPersistentCache","cacheKey","ttlMs","meta","savedAtMs","expiresAtMs","size","TextEncoder","encode","estimateSizeBytes","model","updated","push","pruned","kept","removedKeys","savedAt","totalSize","sort","a","b","dropCount","list","slice","pruneCacheIndex","sortKeysDeep","prototype","toString","call","keys","hashKey","input","crypto","subtle","digest","bytes","from","Uint8Array","padStart","join","str","h","i","charCodeAt","imul","fnv1a32","REQUEST_LOG_TTL_MS","Infinity","_requestLog","_requestLogLoading","_requestLogLoaded","_requestLogLastLoadedMs","_requestLogClearMs","_logBuffer","_logFlushTimer","_logFlushPromise","_usageTotals","createEmptyUsageTotals","_usageTotalsLoading","_usageTotalsLoaded","_usageTotalsLastLoadedMs","_usageTotalsDirty","syncRequestLogClearMarker","reset","isErrorLogEntry","ok","pruneRequestLog","valid","e","normals","errors","concat","toNonNegInt","floor","toNonNegNumber","inputTokens","outputTokens","reasoningTokens","cachedInputTokens","cacheStorageTokenHours","requests","batchApplied","byProvider","models","pruneBatchApplied","loadUsageTotals","force","parsed","base","batchId","normalizedModels","label","normalizeBatchApplied","providers","rawProvider","target","rawModels","normalizeUsageTotals","applyUsageTotalsFromEntry","batch","batchModels","currentModels","modelLabel","mapKey","existing","touched","values","applyUsageDelta","previous","curr","prev","delta","hasUsageDelta","providerTotals","logRequest","logEntry","sanitizeLogEntry","replaced","flushLogBuffer","usageTouched","normal","coerceRequestLogArray","loadRequestLog","idx","findIndex","REQUEST_LOG_MAX_PER_TYPE","persistRequestLog","persistUsageTotals","CACHE","constructor","maxEntries","this","oldestKey","clear","_cacheClearLocalMs","INFLIGHT","GEMINI_CACHED_CONTENT_TTL_MS","GEMINI_CACHED_CONTENT","GEMINI_CACHED_INFLIGHT","QUEUE_CANCELLED","Symbol","QUEUE_CANCELLED_RESULT","code","message","concurrencyLimitCached","concurrencyLimitCachedAt","rpmLimitCached","rpmLimitCachedAt","rpmWindow","rpmGate","rpmStatusTimer","queue","_items","_head","shift","drain","pending","statusTimer","pendingStatus","lastStatusKey","BATCH_REQUEST_THRESHOLD","POSITIVE_INFINITY","batchState","totalPendingRequests","ensureBatchState","startedAt","id","random","endedAt","totalRequests","okCount","errorCount","cachedCount","msSum","msMax","msMin","peakQueued","peakActive","lastLogAt","createBatchState","updateBatchPeaks","recordBatchResult","usage","cacheAdjusted","duration","buildBatchLogEntry","maybeEmitBatchLog","isFinal","totalTokens","durationMs","avgMs","round","fn","batchLive","batchStats","error","maxMs","minMs","finalizeBatchIfIdle","getRpmCount","pruneRpmWindow","scheduleRuntimeStatusUpdate","snapshot","getConcurrencyLimitCached","includes","best","bestDiff","abs","option","diff","normalizeConcurrencyLimit","getConcurrencyLimit","getRpmLimitCached","normalizeRpmLimit","getRpmLimit","cutoff","ensureRpmStatusTimer","setInterval","count","clearInterval","isNonEmptyString","normalizeBoolean","def","normalizeTimeoutMs","toLowerMsg","toGeminiModelRef","startsWith","looksLikeCachedContentInvalid","looksLikeStructuredOutputUnsupported","looksLikeWebSearchUnsupported","isGeminiServiceUnavailable","msg","ensureJsonInstruction","system","test","getFormulaForLog","fnName","match","formula","extractFormulaFromText","aiGenerate","req","start","apiKey","functionName","functionCall","reasoningEffort","normalizeReasoningEffort","getOpenAIReasoningEffort","normalizeGeminiReasoningEffort","getGeminiReasoningEffort","reasoningEffortLabel","undefined","cachePrefix","cacheSuffix","user","webSearch","gemini503RetryMax","cfgMax","normalizeMaxOutputTokens","thinkingConfig","effort","level","modelId","thinkingLevel","toUpperCase","budget","minimal","low","medium","high","thinkingBudget","resolveGeminiThinkingConfig","cacheEnabled","ttlSec","allowPersistentCache","getCacheClearAt","cacheKeyPayload","responseMimeType","responseJsonSchema","recorded","cacheKind","persisted","Error","getPersistentCache","limit","then","waitMs","reserveRpmSlot","waitForRpmSlot","attempt","lastErr","callProvider","url","body","max_output_tokens","store","reasoning","sysText","instructions","format","type","name","strict","schema","tools","include","res","fetchWithTimeout","method","headers","Authorization","json","safeJson","extractOpenAIError","output_text","output","texts","content","part","choices","extractOpenAIText","sources","action","src","title","dedupeSources","extractOpenAISources","u","rawOutputTokens","toInt","output_tokens","output_tokens_details","reasoning_tokens","input_tokens","total_tokens","input_tokens_details","cached_tokens","extractOpenAIUsage","callOpenAI","opts","callGemini","baseOpts","wantsStructured","shouldRetryServiceUnavailable","normalizeUsage","cacheHint","timeout","err","isTimeoutError","withConcurrencyLimit","disableCache","encodeURIComponent","geminiEndpoint","cachedContentName","cachedContentKey","userText","systemText","prefix","pruneGeminiCachedContent","createdAtMs","chargedTokenHours","created","contents","role","parts","ttl","systemInstruction","expireTime","createGeminiCachedContent","ensureGeminiCachedContent","generationConfig","responseSchema","google_search","cachedContent","errInfo","statusCode","extractGeminiErrorInfo","extractGeminiError","c","extractGeminiText","md","groundingMetadata","chunks","groundingChunks","ch","web","uri","extractGeminiSources","usageMetadata","promptTokenCount","candidatesTokenCount","thoughtsTokenCount","totalTokenCount","cachedContentTokenCount","extractGeminiUsage","ttlHours","reportedTotal","computedTotal","seen","add","t","AbortController","fetch","ctrl","abort","signal","clearTimeout","MAX_BATCH_CELLS","DEFAULT_LANG","isMatrix","normalizeToMatrix","toScalarString","truncateForCell","EXCEL_CELL_CHAR_LIMIT","matrixToTSV","matrix","maxChars","m","truncated","append","chunk","remaining","row","j","formatFormulaText","FORMULA_ARG_MAX","formatFormulaArg","buildFormulaCall","args","formatted","last","flattenMatrix","maxItems","r","cell","dedupe","cfError","CustomFunctions","errCode","ErrorCode","invalidValue","parseJsonSafe","codeBlockMatch","firstCurly","indexOf","lastCurly","lastIndexOf","firstSquare","lastSquare","NO_CLARIFY","sysAsk","lang","sysTranslate","targetLang","expectedItems","sysClassify","labels","sysClean","sysConsistent","sysSummarize","sysExtract","instruction","sysFill","sysFormula","isFr","sysWeb","KEY_STATUS","maxTok","gemKey","oaiKey","gemModel","notAvailable","TEST","aiMinimalTest","ASK","prompt","contextRange","q","context","BATCH","hasContext","WEB","query","focus","showSource","obj","source","reason","withSources","parseShowSource","lines","makeSourcesBlock","TRANSLATE","textOrRange","flat","isBatch","additionalProperties","required","properties","items","split","CLASSIFY","allowed","Boolean","parseLabels","labelList","allowedLower","l","it","EXTRACT","instr","CLEAN","CONSISTENT","FORMULA","description","desc","formulaLang","locale","Office","displayLanguage","contentLanguage","navigator","language","getExcelLocale","m1","TABLE","rows","width","safeHeaders","_","r0","FILL","exampleRange","targetRange","ex","tgt","nRows","SUMMARIZE","mode","summarizeMode","parseSummarizeMode","COUNT","range","needle","regTimer","associate","safeAssociate","registerAll"],"sourceRoot":""}