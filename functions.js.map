{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-ai-gemini-addin/./src/shared/core.js","webpack://excel-ai-gemini-addin/./src/shared/providers.js","webpack://excel-ai-gemini-addin/./src/functions/functions.js"],"sourcesContent":["// src/shared/core.js\n// Shared utilities + persisted configuration for the AI.Native add-in.\n//\n// Key design goals:\n// - Two providers (Gemini + OpenAI) can coexist.\n// - The default provider is chosen in the taskpane (not in formulas).\n// - No temperature / sampling controls anywhere (per requirements).\n// - A single \"max output tokens\" setting applies to both providers.\n\nexport const PROVIDERS = Object.freeze({\n  GEMINI: \"gemini\",\n  OPENAI: \"openai\"\n});\n\nexport const DEFAULTS = Object.freeze({\n  provider: PROVIDERS.GEMINI,\n  // Default models (User specified future versions)\n  geminiModel: \"gemini-3-flash-preview\",\n  openaiModel: \"gpt-5-mini\",\n  openaiReasoningEffort: \"medium\",\n  maxOutputTokens: 1024,\n\n  // Execution / UX\n  retry: 2,\n  timeoutMs: 120000,\n\n  // In-memory cache (per runtime). Note: Office custom functions can run in a long-lived runtime.\n  cache: true,\n  cacheTtlSec: 7 * 24 * 3600, // 7 days\n  webCacheTtlSec: 3600 // 1 hour (web results change more often)\n});\n\nconst STORAGE_KEYS = Object.freeze({\n  DEFAULT_PROVIDER: \"AI_DEFAULT_PROVIDER_V3\",\n  GEMINI_API_KEY: \"AI_GEMINI_API_KEY_V3\",\n  OPENAI_API_KEY: \"AI_OPENAI_API_KEY_V3\",\n  GEMINI_MODEL: \"AI_GEMINI_MODEL_V3\",\n  OPENAI_MODEL: \"AI_OPENAI_MODEL_V3\",\n  OPENAI_REASONING_EFFORT: \"AI_OPENAI_REASONING_EFFORT_V3\",\n  MAX_OUTPUT_TOKENS: \"AI_MAX_OUTPUT_TOKENS_V3\",\n\n  // Prevent re-running migrations each time.\n  MIGRATION_DONE: \"AI_MIGRATION_DONE_V3\",\n\n  // Diagnostics + cache metadata\n  REQUEST_LOG: \"AI_REQUEST_LOG_V1\",\n  REQUEST_LOG_CLEAR_AT: \"AI_REQUEST_LOG_CLEAR_AT_V1\",\n  CACHE_INDEX: \"AI_CACHE_INDEX_V1\",\n  CACHE_CLEAR_AT: \"AI_CACHE_CLEAR_AT_V1\"\n});\n\n// Older keys used by previous versions (best-effort migration).\nconst LEGACY_KEYS = Object.freeze({\n  GEMINI_API_KEY: \"GEMINI_API_KEY\",\n  MAX_OUTPUT_TOKENS: \"MAX_OUTPUT_TOKENS\",\n\n  DEFAULT_PROVIDER_V2: \"AI_DEFAULT_PROVIDER_V2\",\n  GEMINI_API_KEY_V2: \"AI_GEMINI_API_KEY_V2\",\n  OPENAI_API_KEY_V2: \"AI_OPENAI_API_KEY_V2\",\n  GEMINI_MODEL_V2: \"AI_GEMINI_MODEL_V2\",\n  OPENAI_MODEL_V2: \"AI_OPENAI_MODEL_V2\",\n\n  GEMINI_MAX_TOKENS_V2: \"AI_GEMINI_MAX_OUTPUT_TOKENS_V2\",\n  OPENAI_MAX_TOKENS_V2: \"AI_OPENAI_MAX_OUTPUT_TOKENS_V2\"\n});\n\nlet _migrationPromise = null;\n\nfunction getRuntimeStorage() {\n  try {\n    if (typeof OfficeRuntime !== \"undefined\" && OfficeRuntime?.storage?.getItem) {\n      return { kind: \"office\", storage: OfficeRuntime.storage };\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return { kind: \"local\", storage: window.localStorage };\n    }\n  } catch {\n    // ignore\n  }\n\n  // Extremely defensive fallback (in-memory only).\n  const mem = new Map();\n  return {\n    kind: \"memory\",\n    storage: {\n      async getItem(k) {\n        return mem.has(k) ? mem.get(k) : null;\n      },\n      async setItem(k, v) {\n        mem.set(k, String(v));\n      },\n      async removeItem(k) {\n        mem.delete(k);\n      }\n    }\n  };\n}\n\nfunction getLocalStorageSafe() {\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return window.localStorage;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nexport function storageBackendName() {\n  return getRuntimeStorage().kind;\n}\n\nasync function rawGet(key) {\n  const { kind, storage } = getRuntimeStorage();\n  if (kind === \"local\") {\n    try {\n      return storage.getItem(key);\n    } catch {\n      return null;\n    }\n  }\n\n  if (kind === \"office\") {\n    try {\n      const result = await storage.getItem(key);\n      if (result == null) {\n        const local = getLocalStorageSafe();\n        if (!local) return null;\n        try {\n          const localValue = local.getItem(key);\n          return localValue == null ? null : localValue;\n        } catch {\n          return null;\n        }\n      }\n      return result;\n    } catch {\n      const local = getLocalStorageSafe();\n      if (!local) return null;\n      try {\n        return local.getItem(key);\n      } catch {\n        return null;\n      }\n    }\n  }\n\n  try {\n    return await storage.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nasync function rawSet(key, value) {\n  const { kind, storage } = getRuntimeStorage();\n  const v = value == null ? \"\" : String(value);\n  if (kind === \"local\") {\n    try {\n      storage.setItem(key, v);\n      return;\n    } catch {\n      return;\n    }\n  }\n\n  if (kind === \"office\") {\n    try {\n      await storage.setItem(key, v);\n    } catch {\n      // ignore and try local\n    }\n    const local = getLocalStorageSafe();\n    if (!local) return;\n    try {\n      local.setItem(key, v);\n    } catch {\n      // ignore\n    }\n    return;\n  }\n\n  try {\n    await storage.setItem(key, v);\n  } catch {\n    // ignore\n  }\n}\n\nasync function rawRemove(key) {\n  const { kind, storage } = getRuntimeStorage();\n  if (kind === \"local\") {\n    try {\n      storage.removeItem(key);\n      return;\n    } catch {\n      return;\n    }\n  }\n\n  if (kind === \"office\") {\n    try {\n      await storage.removeItem(key);\n    } catch {\n      // ignore and try local\n    }\n    const local = getLocalStorageSafe();\n    if (!local) return;\n    try {\n      local.removeItem(key);\n    } catch {\n      // ignore\n    }\n    return;\n  }\n\n  try {\n    await storage.removeItem(key);\n  } catch {\n    // ignore\n  }\n}\n\nasync function ensureMigrated() {\n  if (_migrationPromise) return _migrationPromise;\n\n  _migrationPromise = (async () => {\n    // Fast exit if already migrated\n    const done = await rawGet(STORAGE_KEYS.MIGRATION_DONE);\n    if (done === \"1\") return;\n\n    // Migrate provider\n    const currentProvider = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n    if (!currentProvider) {\n      const legacyProvider = normalizeProvider(await rawGet(LEGACY_KEYS.DEFAULT_PROVIDER_V2));\n      await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, legacyProvider || DEFAULTS.provider);\n    }\n\n    // Migrate keys\n    const gKey = await rawGet(STORAGE_KEYS.GEMINI_API_KEY);\n    if (!gKey) {\n      const legacy = (await rawGet(LEGACY_KEYS.GEMINI_API_KEY_V2)) || (await rawGet(LEGACY_KEYS.GEMINI_API_KEY));\n      if (legacy) await rawSet(STORAGE_KEYS.GEMINI_API_KEY, legacy);\n    }\n\n    const oKey = await rawGet(STORAGE_KEYS.OPENAI_API_KEY);\n    if (!oKey) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_API_KEY_V2);\n      if (legacy) await rawSet(STORAGE_KEYS.OPENAI_API_KEY, legacy);\n    }\n\n    // Migrate models\n    const gModel = await rawGet(STORAGE_KEYS.GEMINI_MODEL);\n    if (!gModel) {\n      const legacy = await rawGet(LEGACY_KEYS.GEMINI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.GEMINI_MODEL, legacy || DEFAULTS.geminiModel);\n    }\n\n    const oModel = await rawGet(STORAGE_KEYS.OPENAI_MODEL);\n    if (!oModel) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.OPENAI_MODEL, legacy || DEFAULTS.openaiModel);\n    }\n\n    // Migrate max tokens (unified)\n    const tok = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n    if (!tok) {\n      const legacyUnified = await rawGet(LEGACY_KEYS.MAX_OUTPUT_TOKENS);\n      const legacyGem = await rawGet(LEGACY_KEYS.GEMINI_MAX_TOKENS_V2);\n      const legacyOai = await rawGet(LEGACY_KEYS.OPENAI_MAX_TOKENS_V2);\n\n      const candidates = [legacyUnified, legacyGem, legacyOai]\n        .map((x) => parseInt(String(x || \"\").trim(), 10))\n        .filter((n) => Number.isFinite(n) && n > 0);\n\n      const migrated = candidates.length ? Math.max(...candidates) : DEFAULTS.maxOutputTokens;\n      await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(migrated));\n    }\n\n    await rawSet(STORAGE_KEYS.MIGRATION_DONE, \"1\");\n  })();\n\n  try {\n    await _migrationPromise;\n  } finally {\n    _migrationPromise = null;\n  }\n}\n\nexport function normalizeProvider(p) {\n  if (!p) return \"\";\n  const s = String(p).trim().toLowerCase();\n  if (s === PROVIDERS.GEMINI) return PROVIDERS.GEMINI;\n  if (s === PROVIDERS.OPENAI) return PROVIDERS.OPENAI;\n  // Common aliases (defensive)\n  if (s === \"google\" || s === \"gem\") return PROVIDERS.GEMINI;\n  if (s === \"oai\" || s === \"chatgpt\") return PROVIDERS.OPENAI;\n  return \"\";\n}\n\nconst OPENAI_REASONING_EFFORTS = new Set([\"none\", \"minimal\", \"low\", \"medium\", \"high\"]);\n\nfunction normalizeReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.openaiReasoningEffort;\n  return OPENAI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.openaiReasoningEffort;\n}\n\nexport async function getDefaultProvider() {\n  await ensureMigrated();\n  const p = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n  return p || DEFAULTS.provider;\n}\n\nexport async function setDefaultProvider(provider) {\n  const p = normalizeProvider(provider) || DEFAULTS.provider;\n  await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, p);\n  return p;\n}\n\nfunction keyKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_API_KEY;\n  return STORAGE_KEYS.GEMINI_API_KEY;\n}\n\nexport async function getApiKey(provider) {\n  await ensureMigrated();\n  const k = await rawGet(keyKey(provider));\n  return (k || \"\").trim();\n}\n\nexport async function setApiKey(provider, apiKey) {\n  const k = (apiKey || \"\").trim();\n  await rawSet(keyKey(provider), k);\n  return k;\n}\n\nexport async function clearApiKey(provider) {\n  await rawRemove(keyKey(provider));\n}\n\nfunction modelKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_MODEL;\n  return STORAGE_KEYS.GEMINI_MODEL;\n}\n\nexport async function getModel(provider) {\n  await ensureMigrated();\n  const p = normalizeProvider(provider);\n  const raw = await rawGet(modelKey(p));\n  if (raw && String(raw).trim()) return String(raw).trim();\n  return p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel;\n}\n\nexport async function getOpenAIReasoningEffort() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.OPENAI_REASONING_EFFORT);\n  return normalizeReasoningEffort(raw || DEFAULTS.openaiReasoningEffort);\n}\n\nexport async function setModel(provider, model) {\n  const p = normalizeProvider(provider);\n  const v = String(model || \"\").trim();\n  if (!v) {\n    // Reset to default if emptied\n    await rawSet(modelKey(p), p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel);\n    return;\n  }\n  await rawSet(modelKey(p), v);\n}\n\nexport async function setOpenAIReasoningEffort(value) {\n  const v = normalizeReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.OPENAI_REASONING_EFFORT, v);\n  return v;\n}\n\nexport async function getMaxOutputTokens() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return clampInt(n, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nexport async function setMaxOutputTokens(value) {\n  const n = clampInt(value, 1, 128000, DEFAULTS.maxOutputTokens);\n  await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(n));\n  return n;\n}\n\n// ---------- Small utilities ----------\nexport function nowMs() {\n  return Date.now();\n}\n\nexport function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function clamp(value, min, max, fallback = min) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nexport function clampInt(value, min, max, fallback = min) {\n  const n = parseInt(String(value), 10);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nfunction parseTimestampMs(raw) {\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return Number.isFinite(n) && n > 0 ? n : 0;\n}\n\n// ---------- LRU cache with TTL ----------\nexport class LRUCache {\n  constructor(maxEntries = 500) {\n    this.maxEntries = maxEntries;\n    this.map = new Map(); // key => {value, expiresAtMs}\n  }\n\n  get(key) {\n    if (!this.map.has(key)) return null;\n    const entry = this.map.get(key);\n\n    if (entry?.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      this.map.delete(key);\n      return null;\n    }\n\n    // Refresh key order (most recent)\n    this.map.delete(key);\n    this.map.set(key, entry);\n    return entry.value;\n  }\n\n  set(key, value, ttlMs) {\n    const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? nowMs() + ttlMs : null;\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, { value, expiresAtMs });\n\n    // Evict LRU\n    while (this.map.size > this.maxEntries) {\n      const oldestKey = this.map.keys().next().value;\n      this.map.delete(oldestKey);\n    }\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\n// ---------- Persistent cache (survives reloads) ----------\nconst CACHE_ENTRY_PREFIX = \"AI_CACHE_ENTRY_V1:\";\nconst CACHE_INDEX_MAX = 250;\nlet _cacheClearMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.CACHE_CLEAR_AT));\n  if (clearedAt > _cacheClearMs) _cacheClearMs = clearedAt;\n  return _cacheClearMs;\n}\n\nexport async function getCacheClearAt() {\n  return await syncCacheClearMarker();\n}\n\nasync function loadCacheIndex() {\n  const raw = await rawGet(STORAGE_KEYS.CACHE_INDEX);\n  if (!raw) return [];\n  try {\n    const arr = JSON.parse(raw);\n    return Array.isArray(arr) ? arr : [];\n  } catch {\n    return [];\n  }\n}\n\nasync function saveCacheIndex(entries) {\n  try {\n    await rawSet(STORAGE_KEYS.CACHE_INDEX, JSON.stringify(entries));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneCacheIndex(entries, clearedAt = 0) {\n  const now = nowMs();\n  const kept = [];\n  const removedKeys = [];\n\n  for (const entry of entries || []) {\n    if (!entry || !entry.key) continue;\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= now) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    kept.push(entry);\n  }\n\n  if (kept.length > CACHE_INDEX_MAX) {\n    kept.sort((a, b) => (a.savedAtMs || 0) - (b.savedAtMs || 0));\n    const over = kept.length - CACHE_INDEX_MAX;\n    const toRemove = kept.slice(0, over);\n    for (const r of toRemove) removedKeys.push(r.key);\n    return { list: kept.slice(over), removedKeys };\n  }\n\n  return { list: kept, removedKeys };\n}\n\nasync function removeCacheEntry(key) {\n  if (!key) return;\n  await rawRemove(CACHE_ENTRY_PREFIX + key);\n}\n\nasync function removeFromCacheIndex(key) {\n  const index = await loadCacheIndex();\n  const next = (index || []).filter((item) => item?.key !== key);\n  if (next.length !== index.length) await saveCacheIndex(next);\n}\n\nexport async function getPersistentCache(cacheKey) {\n  if (!cacheKey) return null;\n  const clearedAt = await syncCacheClearMarker();\n  const raw = await rawGet(CACHE_ENTRY_PREFIX + cacheKey);\n  if (!raw) {\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n\n  try {\n    const entry = JSON.parse(raw);\n    if (!entry || typeof entry !== \"object\") throw new Error(\"Invalid entry\");\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    return entry.value || null;\n  } catch {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n}\n\nexport async function setPersistentCache(cacheKey, value, ttlMs, meta = {}) {\n  if (!cacheKey) return;\n  const now = nowMs();\n  const clearedAt = await syncCacheClearMarker();\n  const savedAtMs = clearedAt && now <= clearedAt ? clearedAt + 1 : now;\n  const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? savedAtMs + ttlMs : null;\n  const entry = {\n    v: 1,\n    savedAtMs,\n    expiresAtMs,\n    value\n  };\n\n  const raw = JSON.stringify(entry);\n  await rawSet(CACHE_ENTRY_PREFIX + cacheKey, raw);\n\n  const index = await loadCacheIndex();\n  const provider = meta.provider || value?.provider || \"\";\n  const model = meta.model || value?.model || \"\";\n  const size = raw.length;\n\n  let updated = false;\n  const next = (index || []).map((item) => {\n    if (item?.key !== cacheKey) return item;\n    updated = true;\n    return {\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    };\n  });\n\n  if (!updated) {\n    next.push({\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    });\n  }\n\n  const pruned = pruneCacheIndex(next, clearedAt);\n  for (const key of pruned.removedKeys) await removeCacheEntry(key);\n  await saveCacheIndex(pruned.list);\n}\n\nexport async function clearPersistentCache() {\n  const clearedAt = nowMs();\n  _cacheClearMs = clearedAt;\n  await rawSet(STORAGE_KEYS.CACHE_CLEAR_AT, String(clearedAt));\n  const index = await loadCacheIndex();\n  for (const item of index || []) {\n    if (!item?.key) continue;\n    await removeCacheEntry(item.key);\n  }\n  await rawRemove(STORAGE_KEYS.CACHE_INDEX);\n}\n\nexport async function getPersistentCacheStats() {\n  const index = await loadCacheIndex();\n  const clearedAt = await syncCacheClearMarker();\n  const pruned = pruneCacheIndex(index, clearedAt);\n  if (pruned.removedKeys.length) {\n    for (const key of pruned.removedKeys) await removeCacheEntry(key);\n    await saveCacheIndex(pruned.list);\n  }\n\n  const stats = {\n    entries: 0,\n    sizeBytes: 0,\n    providers: {\n      gemini: { entries: 0, sizeBytes: 0 },\n      openai: { entries: 0, sizeBytes: 0 }\n    },\n    oldestMs: null,\n    newestMs: null\n  };\n\n  for (const item of pruned.list || []) {\n    if (!item?.key) continue;\n    stats.entries += 1;\n    stats.sizeBytes += Number(item.size || 0);\n    const provider = String(item.provider || \"\").toLowerCase();\n    if (provider === PROVIDERS.GEMINI) {\n      stats.providers.gemini.entries += 1;\n      stats.providers.gemini.sizeBytes += Number(item.size || 0);\n    } else if (provider === PROVIDERS.OPENAI) {\n      stats.providers.openai.entries += 1;\n      stats.providers.openai.sizeBytes += Number(item.size || 0);\n    }\n\n    const savedAt = Number(item.savedAtMs || 0);\n    if (savedAt) {\n      stats.oldestMs = stats.oldestMs == null ? savedAt : Math.min(stats.oldestMs, savedAt);\n      stats.newestMs = stats.newestMs == null ? savedAt : Math.max(stats.newestMs, savedAt);\n    }\n  }\n\n  return stats;\n}\n\n// ---------- Stable stringify + hashing (for cache keys) ----------\nfunction isPlainObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\n\nexport function stableStringify(value) {\n  return JSON.stringify(sortKeysDeep(value));\n}\n\nfunction sortKeysDeep(value) {\n  if (Array.isArray(value)) return value.map(sortKeysDeep);\n  if (isPlainObject(value)) {\n    const out = {};\n    for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);\n    return out;\n  }\n  return value;\n}\n\nfunction fnv1a32(str) {\n  let h = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  // Unsigned\n  return (h >>> 0).toString(16).padStart(8, \"0\");\n}\n\nexport async function hashKey(input) {\n  const text = typeof input === \"string\" ? input : stableStringify(input);\n\n  // Prefer SHA-256 when available (browser/Office runtime)\n  try {\n    if (typeof crypto !== \"undefined\" && crypto?.subtle?.digest && typeof TextEncoder !== \"undefined\") {\n      const enc = new TextEncoder();\n      const bytes = enc.encode(text);\n      const digest = await crypto.subtle.digest(\"SHA-256\", bytes);\n      const arr = Array.from(new Uint8Array(digest));\n      return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n  } catch {\n    // ignore and fallback\n  }\n\n  return `fnv1a:${fnv1a32(text)}`;\n}\n\n// ---------- Lightweight diagnostics log (persisted) ----------\nconst REQUEST_LOG_MAX = 500;\nconst REQUEST_LOG_TTL_MS = 24 * 60 * 60 * 1000; // 24h\nlet _requestLog = [];\nlet _requestLogLoading = null;\nlet _requestLogLoaded = false;\nlet _requestLogLastLoadedMs = 0;\nlet _requestLogClearMs = 0;\n\nasync function syncRequestLogClearMarker(options = {}) {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT));\n  if (clearedAt > _requestLogClearMs) {\n    _requestLogClearMs = clearedAt;\n    _requestLog = [];\n    if (options.reset) {\n      _requestLogLoaded = true;\n      _requestLogLoading = null;\n      _requestLogLastLoadedMs = nowMs();\n    } else {\n      _requestLogLoaded = false;\n    }\n  }\n  return _requestLogClearMs;\n}\n\nasync function loadRequestLog(force = false) {\n  if (_requestLogLoading) return _requestLogLoading;\n\n  _requestLogLoading = (async () => {\n    const clearedAt = await syncRequestLogClearMarker();\n    if (!force && _requestLogLoaded) return _requestLog;\n    const raw = await rawGet(STORAGE_KEYS.REQUEST_LOG);\n    let arr = [];\n    if (raw) {\n      try {\n        const parsed = JSON.parse(raw);\n        if (Array.isArray(parsed)) arr = parsed;\n      } catch {\n        arr = [];\n      }\n    }\n    const now = nowMs();\n    arr = arr\n      .map((e) => {\n        if (!e) return null;\n        let ts = e.ts;\n        if (typeof ts === \"string\") {\n          const parsed = Date.parse(ts);\n          if (Number.isFinite(parsed)) ts = parsed;\n        }\n        if (typeof ts !== \"number\") return null;\n        return { ...e, ts };\n      })\n      .filter((e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS);\n    _requestLog = arr.slice(-REQUEST_LOG_MAX);\n    _requestLogLoaded = true;\n    _requestLogLastLoadedMs = nowMs();\n    return _requestLog;\n  })();\n\n  try {\n    return await _requestLogLoading;\n  } finally {\n    _requestLogLoading = null;\n  }\n}\n\nasync function persistRequestLog() {\n  try {\n    await rawSet(STORAGE_KEYS.REQUEST_LOG, JSON.stringify(_requestLog.slice(-REQUEST_LOG_MAX)));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneRequestLog() {\n  const now = nowMs();\n  const clearedAt = _requestLogClearMs || 0;\n  _requestLog = (_requestLog || []).filter(\n    (e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS\n  );\n  if (_requestLog.length > REQUEST_LOG_MAX) {\n    _requestLog = _requestLog.slice(-REQUEST_LOG_MAX);\n  }\n}\n\nexport function logRequest(entry) {\n  void logRequestAsync(entry);\n}\n\nasync function logRequestAsync(entry) {\n  try {\n    await syncRequestLogClearMarker({ reset: true });\n    const logEntry = { ts: nowMs(), ...entry };\n\n    if (_requestLogLoaded) {\n      _requestLog.push(logEntry);\n      pruneRequestLog();\n      _requestLogLastLoadedMs = nowMs();\n      await persistRequestLog();\n      return;\n    }\n\n    await loadRequestLog();\n    _requestLog.push(logEntry);\n    pruneRequestLog();\n    _requestLogLastLoadedMs = nowMs();\n    await persistRequestLog();\n  } catch {\n    // ignore\n  }\n}\n\nexport async function getRequestLog(options = {}) {\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_requestLogLoaded || now - _requestLogLastLoadedMs > 1500) {\n    await loadRequestLog(true);\n  } else {\n    await loadRequestLog(false);\n  }\n  return _requestLog.slice();\n}\n\nexport async function clearRequestLog() {\n  const clearedAt = nowMs();\n  _requestLog = [];\n  _requestLogLoaded = true;\n  _requestLogLoading = null;\n  _requestLogClearMs = clearedAt;\n  _requestLogLastLoadedMs = clearedAt;\n  await rawSet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT, String(clearedAt));\n  await rawRemove(STORAGE_KEYS.REQUEST_LOG);\n}\n","// src/shared/providers.js\n// Provider implementations (Gemini + OpenAI) and shared request orchestration.\n//\n// Requirements implemented:\n// - Gemini 3 Flash (via Google Generative Language API)\n// - OpenAI GPT-5 Mini (via OpenAI Responses API)\n// - No temperature / sampling parameters are ever sent\n// - Provider selection happens via taskpane default provider (formulas cannot override)\n// - AI.WEB uses provider-native web search mechanisms:\n//   - Gemini: google_search tool\n//   - OpenAI: web_search tool\n\nimport {\n  PROVIDERS,\n  DEFAULTS,\n  normalizeProvider,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getOpenAIReasoningEffort,\n  getMaxOutputTokens,\n  clampInt,\n  nowMs,\n  sleep,\n  LRUCache,\n  hashKey,\n  logRequest,\n  getCacheClearAt,\n  getPersistentCache,\n  setPersistentCache,\n  clearPersistentCache\n} from \"./core.js\";\n\n// ---- In-memory cache (per runtime) ----\nconst CACHE = new LRUCache(800);\nlet _cacheClearLocalMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = await getCacheClearAt();\n  if (clearedAt > _cacheClearLocalMs) {\n    _cacheClearLocalMs = clearedAt;\n    CACHE.clear();\n  }\n}\n\n// Deduplicate in-flight identical requests to avoid bursts (per runtime)\nconst INFLIGHT = new Map(); // key => Promise<AIResult>\n\n// Basic concurrency limiter (per runtime)\nconst MAX_CONCURRENCY = 4;\nlet active = 0;\nconst queue = [];\n\nasync function withConcurrencyLimit(fn) {\n  if (active >= MAX_CONCURRENCY) await new Promise((resolve) => queue.push(resolve));\n  active++;\n  try {\n    return await fn();\n  } finally {\n    active--;\n    const next = queue.shift();\n    if (next) next();\n  }\n}\n\nfunction isNonEmptyString(s) {\n  return typeof s === \"string\" && s.trim().length > 0;\n}\n\nfunction normalizeBoolean(v, def = false) {\n  if (typeof v === \"boolean\") return v;\n  if (typeof v === \"number\") return v !== 0;\n  if (typeof v === \"string\") {\n    const s = v.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(s)) return true;\n    if ([\"0\", \"false\", \"no\", \"n\", \"off\"].includes(s)) return false;\n  }\n  return def;\n}\n\nfunction normalizeTimeoutMs(v) {\n  return clampInt(v, 1000, 120000, DEFAULTS.timeoutMs);\n}\n\nfunction normalizeRetry(v) {\n  return clampInt(v, 0, 5, DEFAULTS.retry);\n}\n\nfunction normalizeMaxOutputTokens(v) {\n  return clampInt(v, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nfunction toLowerMsg(v) {\n  return String(v || \"\").toLowerCase();\n}\n\nfunction looksLikeStructuredOutputUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  return (\n    s.includes(\"responseschema\") ||\n    s.includes(\"response schema\") ||\n    s.includes(\"response_schema\") ||\n    s.includes(\"responsemime\") ||\n    s.includes(\"response mime\") ||\n    s.includes(\"response_mime\") ||\n    s.includes(\"response_mime_type\") ||\n    s.includes(\"json_schema\") ||\n    s.includes(\"response_format\") ||\n    s.includes(\"text.format\")\n  );\n}\n\nfunction looksLikeWebSearchUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  if (!(s.includes(\"web_search\") || s.includes(\"google_search\") || s.includes(\"web search\") || s.includes(\"google search\"))) {\n    return false;\n  }\n  return (\n    s.includes(\"not supported\") ||\n    s.includes(\"unsupported\") ||\n    s.includes(\"unknown\") ||\n    s.includes(\"unrecognized\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"not enabled\") ||\n    s.includes(\"not available\")\n  );\n}\n\nfunction ensureJsonInstruction(system) {\n  const suffix = \" Return valid JSON only.\";\n  if (!isNonEmptyString(system)) return \"Return valid JSON only.\";\n  const s = String(system).trim();\n  if (/json/i.test(s)) return s;\n  return s + suffix;\n}\n\nfunction extractFormulaFromText(text) {\n  if (!isNonEmptyString(text)) return \"\";\n  const raw = String(text).trim();\n  const match = raw.match(/=[^\\n\\r]+/);\n  const formula = (match ? match[0] : raw).trim();\n  if (!formula.startsWith(\"=\")) return \"\";\n  return formula;\n}\n\nfunction getFormulaForLog(fnName, text) {\n  if (fnName !== \"AI.FORMULA\") return \"\";\n  return extractFormulaFromText(text);\n}\n\n// ---- Public API ----\n\n/**\n * @typedef {Object} AIGenerateRequest\n * @property {string=} provider Optional override (should only be used by taskpane tests, not formulas).\n * @property {string=} system System instruction.\n * @property {string} user User prompt.\n * @property {boolean=} webSearch Enable provider web search tool.\n * @property {number=} maxOutputTokens Override max tokens (optional; normally from panel).\n * @property {number=} timeoutMs\n * @property {number=} retry\n * @property {boolean=} cache\n * @property {number=} cacheTtlSec\n * @property {string=} responseMimeType e.g., \"application/json\"\n * @property {Object=} responseJsonSchema JSON schema (strict) for structured output.\n * @property {string=} functionName Name for diagnostics.\n */\n\n/**\n * @typedef {Object} AIResult\n * @property {boolean} ok\n * @property {string=} text\n * @property {Array<{title?: string, url: string}>=} sources\n * @property {string=} provider\n * @property {string=} model\n * @property {Object=} usage\n * @property {string=} code\n * @property {string=} message\n */\n\nexport async function aiGenerate(req) {\n  const start = nowMs();\n  const provider = normalizeProvider(req?.provider) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n  const fnName = req?.functionName || \"aiGenerate\";\n\n  if (!apiKey) {\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    });\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  const user = String(req?.user || \"\");\n  const system = isNonEmptyString(req?.system) ? String(req.system) : \"\";\n\n  const webSearch = normalizeBoolean(req?.webSearch, false);\n  const timeoutMs = normalizeTimeoutMs(req?.timeoutMs);\n  const retry = normalizeRetry(req?.retry);\n\n  const cfgMax = await getMaxOutputTokens();\n  const maxOutputTokens = normalizeMaxOutputTokens(req?.maxOutputTokens ?? cfgMax);\n  const reasoningEffort = provider === PROVIDERS.OPENAI ? await getOpenAIReasoningEffort() : \"\";\n\n  const cacheEnabled = normalizeBoolean(req?.cache, DEFAULTS.cache);\n  const ttlSec = clampInt(\n    req?.cacheTtlSec ?? (webSearch ? DEFAULTS.webCacheTtlSec : DEFAULTS.cacheTtlSec),\n    1,\n    365 * 24 * 3600,\n    webSearch ? DEFAULTS.webCacheTtlSec : DEFAULTS.cacheTtlSec\n  );\n\n  await syncCacheClearMarker();\n\n  // Cache key (no temperature anywhere)\n  const cacheKeyPayload = {\n    v: 3,\n    provider,\n    model,\n    maxOutputTokens,\n    reasoningEffort,\n    webSearch,\n    system,\n    user,\n    responseMimeType: req?.responseMimeType || \"\",\n    responseJsonSchema: req?.responseJsonSchema || null\n  };\n\n  const cacheKey = await hashKey(cacheKeyPayload);\n\n  if (cacheEnabled) {\n    const cached = CACHE.get(cacheKey);\n    if (cached) {\n      const formula = getFormulaForLog(fnName, cached?.text);\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: true,\n        ms: nowMs() - start,\n        cache: true,\n        cacheKind: \"memory\",\n        inputTokens: 0,\n        outputTokens: 0,\n        totalTokens: 0,\n        formula: formula || undefined\n      });\n      return { ...cached, cached: true, cacheKind: \"memory\" };\n    }\n    const persisted = await getPersistentCache(cacheKey);\n    if (persisted) {\n      const formula = getFormulaForLog(fnName, persisted?.text);\n      CACHE.set(cacheKey, persisted, ttlSec * 1000);\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: true,\n        ms: nowMs() - start,\n        cache: true,\n        cacheKind: \"persistent\",\n        inputTokens: 0,\n        outputTokens: 0,\n        totalTokens: 0,\n        formula: formula || undefined\n      });\n      return { ...persisted, cached: true, cacheKind: \"persistent\" };\n    }\n  }\n\n  if (INFLIGHT.has(cacheKey)) return INFLIGHT.get(cacheKey);\n\n  const p = withConcurrencyLimit(async () => {\n    let attempt = 0;\n    let lastErr = null;\n\n    const callProvider = async (opts) =>\n      provider === PROVIDERS.OPENAI ? callOpenAI(opts) : callGemini(opts);\n\n    while (attempt <= retry) {\n      attempt++;\n      try {\n        const baseOpts = {\n          apiKey,\n          model,\n          system,\n          user,\n          maxOutputTokens,\n          reasoningEffort,\n          timeoutMs,\n          webSearch,\n          responseMimeType: req?.responseMimeType,\n          responseJsonSchema: req?.responseJsonSchema\n        };\n\n        let result = await callProvider(baseOpts);\n\n        if (!result.ok) {\n          let opts = baseOpts;\n\n          // Fallback #1: if web search fails, retry without tools.\n          if (opts.webSearch) {\n            const shouldRetryNoWeb =\n              looksLikeWebSearchUnsupported(result.message) || result.code === \"API_ERROR\" || result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryNoWeb) {\n              opts = { ...opts, webSearch: false };\n              result = await callProvider(opts);\n            }\n          }\n\n          // Fallback #2: if structured output fails, retry without schema/responseMimeType.\n          const wantsStructured = opts.responseMimeType || opts.responseJsonSchema;\n          if (!result.ok && wantsStructured) {\n            const shouldRetryPlainJson =\n              looksLikeStructuredOutputUnsupported(result.message) ||\n              result.code === \"API_ERROR\" ||\n              result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryPlainJson) {\n              opts = {\n                ...opts,\n                responseMimeType: undefined,\n                responseJsonSchema: undefined,\n                system: ensureJsonInstruction(opts.system)\n              };\n              result = await callProvider(opts);\n            }\n          }\n        }\n\n        // Log (best-effort)\n        const usage = normalizeUsage(result?.usage);\n        const formula = result.ok ? getFormulaForLog(fnName, result.text) : \"\";\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: result.ok,\n          ms: nowMs() - start,\n          attempt,\n          cache: false,\n          inputTokens: usage.inputTokens,\n          outputTokens: usage.outputTokens,\n          cachedInputTokens: usage.cachedInputTokens,\n          totalTokens: usage.totalTokens,\n          code: result.code,\n          message: result.message,\n          formula: formula || undefined\n        });\n\n        if (result.ok && cacheEnabled) {\n          CACHE.set(cacheKey, result, ttlSec * 1000);\n          await setPersistentCache(cacheKey, result, ttlSec * 1000, { provider, model });\n        }\n\n        return result;\n      } catch (e) {\n        lastErr = e;\n        if (attempt <= retry) await sleep(250 * attempt);\n      }\n    }\n\n    const msg = lastErr?.message ? String(lastErr.message) : \"Erreur inconnue.\";\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      code: \"API_ERROR\",\n      message: msg\n    });\n    return { ok: false, provider, model, code: \"API_ERROR\", message: msg };\n  });\n\n  INFLIGHT.set(cacheKey, p);\n\n  try {\n    return await p;\n  } finally {\n    INFLIGHT.delete(cacheKey);\n  }\n}\n\n/**\n * Lightweight connectivity test for a provider (used from taskpane and AI.TEST()).\n */\nexport async function aiMinimalTest(providerOverride) {\n  const provider = normalizeProvider(providerOverride) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n\n  if (!apiKey) {\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  // Tiny request\n  return await aiGenerate({\n    provider,\n    system: \"You are a test endpoint. Reply with exactly: OK\",\n    user: \"OK\",\n    maxOutputTokens: 500,\n    cache: false,\n    webSearch: false,\n    functionName: \"AI.MINIMAL_TEST\"\n  });\n}\n\n// ---- Provider: Gemini (Google Generative Language API) ----\n\nfunction geminiEndpoint(model, apiKey) {\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${encodeURIComponent(apiKey)}`;\n}\n\nasync function callGemini({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = geminiEndpoint(model, apiKey);\n\n  const body = {\n    contents: [{ role: \"user\", parts: [{ text: user }] }],\n    generationConfig: {\n      maxOutputTokens\n    }\n  };\n\n  if (isNonEmptyString(system)) {\n    // API uses lowerCamelCase for this field in JSON representation\n    // Force explicit JSON instruction for robustness\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.systemInstruction = { role: \"system\", parts: [{ text: sysText }] };\n  }\n\n  // Structured output (JSON) when requested\n  if (responseMimeType) {\n    body.generationConfig.responseMimeType = responseMimeType;\n  }\n  if (responseJsonSchema) {\n    body.generationConfig.responseSchema = responseJsonSchema;\n  }\n\n  // Web grounding tool\n  if (webSearch) {\n    // For REST v1beta, the tool name is usually google_search (snake_case).\n    // Note: Some newer endpoints might respect googleSearch, but snake_case is safer for REST.\n    body.tools = [{ google_search: {} }];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    return { ok: false, provider: PROVIDERS.GEMINI, model, code: \"API_ERROR\", message: msg };\n  }\n\n  const text = extractGeminiText(json);\n  const sources = extractGeminiSources(json);\n  const usage = extractGeminiUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return { ok: false, provider: PROVIDERS.GEMINI, model, code: \"EMPTY_RESPONSE\", message: \"Rponse vide de Gemini.\" };\n  }\n\n  return { ok: true, provider: PROVIDERS.GEMINI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractGeminiText(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const parts = c?.content?.parts;\n    if (Array.isArray(parts)) {\n      return parts.map((p) => p?.text || \"\").join(\"\");\n    }\n    return \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiSources(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const md = c?.groundingMetadata;\n    const chunks = md?.groundingChunks;\n    if (!Array.isArray(chunks)) return [];\n\n    const out = [];\n    for (const ch of chunks) {\n      const web = ch?.web;\n      if (!web?.uri) continue;\n      out.push({ title: web?.title || \"\", url: web.uri });\n    }\n\n    return dedupeSources(out);\n  } catch {\n    return [];\n  }\n}\n\n// ---- Provider: OpenAI (Responses API) ----\n\nasync function callOpenAI({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  reasoningEffort,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = \"https://api.openai.com/v1/responses\";\n\n  const body = {\n    model,\n    input: user, // Responses API uses 'input' (string or array of objects)\n    max_output_tokens: maxOutputTokens,\n    store: false\n  };\n\n  if (isNonEmptyString(reasoningEffort)) {\n    body.reasoning = { effort: reasoningEffort };\n  }\n\n  // System prompt\n  if (isNonEmptyString(system)) {\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.instructions = sysText;\n  }\n\n  // Structured output (JSON)\n  // - If a JSON schema is provided: use json_schema strict mode.\n  // - Else if responseMimeType is JSON: request a json_object.\n  if (responseJsonSchema) {\n    // For GPT-5 Mini / v1/responses, we try to use the most standard way if possible.\n    // If body.text format fails, we rely on the prompt.\n    // We kept the previous implementation but added prompt reinforcement.\n    body.text = {\n      format: {\n        type: \"json_schema\",\n        name: \"excel_ai_schema\",\n        strict: true,\n        schema: responseJsonSchema\n      }\n    };\n  } else if (responseMimeType === \"application/json\") {\n    body.text = { format: { type: \"json_object\" } };\n  }\n\n  // Web search tool\n  if (webSearch) {\n    body.tools = [{ type: \"web_search\" }];\n    body.include = [\"web_search_call.action.sources\"];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n\n  if (!res.ok) {\n    const msg = extractOpenAIError(json) || `OpenAI API error (${res.status}).`;\n    return { ok: false, provider: PROVIDERS.OPENAI, model, code: \"API_ERROR\", message: msg };\n  }\n\n  const text = extractOpenAIText(json);\n  const sources = webSearch ? extractOpenAISources(json) : [];\n  const usage = extractOpenAIUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.OPENAI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide d'OpenAI.\"\n    };\n  }\n\n  return { ok: true, provider: PROVIDERS.OPENAI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractOpenAIText(json) {\n  // 1. Try direct output_text (common in simple Responses)\n  try {\n    if (typeof json?.output_text === \"string\" && json.output_text.trim()) {\n      return json.output_text;\n    }\n  } catch {\n    // ignore\n  }\n\n  // 2. Try iterating over 'output' items (complex/agentic responses)\n  try {\n    const out = json?.output;\n    if (Array.isArray(out)) {\n      const texts = [];\n      for (const item of out) {\n        if (typeof item?.text === \"string\" && item.text.trim()) texts.push(item.text);\n        if (typeof item?.output_text === \"string\" && item.output_text.trim()) texts.push(item.output_text);\n        if (item?.type === \"output_text\" && typeof item?.text === \"string\") texts.push(item.text);\n        if (item?.type === \"text\" && typeof item?.text === \"string\") texts.push(item.text);\n\n        // Standard message output\n        if (item?.type === \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n\n        if (item?.type !== \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n      }\n      if (texts.length > 0) return texts.join(\"\\n\").trim();\n    }\n  } catch {\n    // ignore\n  }\n\n  // 3. Fallback: Chat Completions style (just in case model acts differently)\n  try {\n    return json?.choices?.[0]?.message?.content || \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAIError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAISources(json) {\n  try {\n    const out = json?.output;\n    if (!Array.isArray(out)) return [];\n\n    const sources = [];\n    for (const item of out) {\n      if (item?.type !== \"web_search_call\") continue;\n      const s = item?.action?.sources;\n      if (!Array.isArray(s)) continue;\n      for (const src of s) {\n        if (!src?.url) continue;\n        sources.push({ title: src?.title || \"\", url: src.url });\n      }\n    }\n\n    return dedupeSources(sources);\n  } catch {\n    return [];\n  }\n}\n\nfunction extractGeminiUsage(json) {\n  try {\n    const u = json?.usageMetadata;\n    if (!u) return null;\n    return {\n      inputTokens: toInt(u?.promptTokenCount),\n      outputTokens: toInt(u?.candidatesTokenCount),\n      totalTokens: toInt(u?.totalTokenCount)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractOpenAIUsage(json) {\n  try {\n    const u = json?.usage;\n    if (!u) return null;\n    return {\n      inputTokens: toInt(u?.input_tokens),\n      outputTokens: toInt(u?.output_tokens),\n      totalTokens: toInt(u?.total_tokens),\n      cachedInputTokens: toInt(u?.input_tokens_details?.cached_tokens)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction normalizeUsage(usage) {\n  if (!usage || typeof usage !== \"object\") {\n    return { inputTokens: 0, outputTokens: 0, totalTokens: 0, cachedInputTokens: 0 };\n  }\n  return {\n    inputTokens: toInt(usage.inputTokens),\n    outputTokens: toInt(usage.outputTokens),\n    totalTokens: toInt(usage.totalTokens),\n    cachedInputTokens: toInt(usage.cachedInputTokens)\n  };\n}\n\nfunction toInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nexport async function clearAllCaches() {\n  CACHE.clear();\n  await clearPersistentCache();\n}\n\nfunction dedupeSources(list) {\n  const seen = new Set();\n  const out = [];\n  for (const s of list || []) {\n    const url = String(s?.url || \"\").trim();\n    if (!url) continue;\n    const key = url.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push({ title: String(s?.title || \"\").trim(), url });\n  }\n  return out;\n}\n\n// ---- Helpers: fetch + timeout + JSON parsing ----\n\nasync function fetchWithTimeout(url, options, timeoutMs) {\n  const t = normalizeTimeoutMs(timeoutMs);\n\n  if (typeof AbortController === \"undefined\") {\n    // Basic fetch without cancellation (should be rare in modern Office runtimes)\n    return await fetch(url, options);\n  }\n\n  const ctrl = new AbortController();\n  const id = setTimeout(() => ctrl.abort(), t);\n\n  try {\n    return await fetch(url, { ...options, signal: ctrl.signal });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nasync function safeJson(res) {\n  try {\n    return await res.json();\n  } catch {\n    return {};\n  }\n}\n","// src/functions/functions.js\n// Custom Functions implementation.\n//\n// IMPORTANT: Formulas must NOT accept provider or sampling options.\n// - Provider is selected in the taskpane (default provider).\n// - No temperature/top-p are used anywhere.\n//\n// This file is bundled by webpack into dist/functions.js and loaded in the shared runtime.\n\nimport { aiGenerate, aiMinimalTest } from \"../shared/providers.js\";\nimport {\n  PROVIDERS,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getMaxOutputTokens,\n  storageBackendName,\n} from \"../shared/core.js\";\n\n// Excel cell text limit is 32,767 characters. Keep a safety margin.\nconst EXCEL_CELL_CHAR_LIMIT = 32000;\n\n// Defensive caps to avoid runaway prompts in spreadsheets.\nconst MAX_CONTEXT_CHARS = 9000;\nconst MAX_LIST_ITEMS = 200;\nconst MAX_BATCH_CELLS = Number.POSITIVE_INFINITY; // for batch operations (CLASSIFY/TRANSLATE/etc.)\nconst DEFAULT_LANG = \"fr\";\n\nfunction getExcelLocale() {\n  try {\n    if (typeof Office !== \"undefined\" && Office?.context) {\n      const lang = Office.context.displayLanguage || Office.context.contentLanguage;\n      if (lang) return String(lang);\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    if (typeof navigator !== \"undefined\" && navigator?.language) {\n      return String(navigator.language);\n    }\n  } catch {\n    // ignore\n  }\n\n  return DEFAULT_LANG;\n}\n\nfunction isFrenchLocale(locale) {\n  return String(locale || \"\").toLowerCase().startsWith(\"fr\");\n}\n\nfunction isMatrix(v) {\n  return Array.isArray(v);\n}\n\nfunction normalizeToMatrix(v) {\n  if (Array.isArray(v)) {\n    if (v.length === 0) return [[]];\n    if (Array.isArray(v[0])) return v;\n    return [v];\n  }\n  return [[v]];\n}\n\nfunction toScalarString(v) {\n  if (v == null) return \"\";\n  if (typeof v === \"string\") return v;\n  if (typeof v === \"number\") return String(v);\n  if (typeof v === \"boolean\") return v ? \"TRUE\" : \"FALSE\";\n  try {\n    return String(v);\n  } catch {\n    return \"\";\n  }\n}\n\nfunction truncateForCell(text) {\n  const s = String(text || \"\");\n  if (s.length <= EXCEL_CELL_CHAR_LIMIT) return s;\n  return s.slice(0, EXCEL_CELL_CHAR_LIMIT - 1) + \"\";\n}\n\nfunction matrixToTSV(matrix, maxChars = MAX_CONTEXT_CHARS) {\n  const m = normalizeToMatrix(matrix);\n  const lines = [];\n  for (const row of m) {\n    const r = Array.isArray(row) ? row : [row];\n    lines.push(r.map(toScalarString).join(\"\\t\"));\n  }\n  let out = lines.join(\"\\n\");\n  if (out.length > maxChars) out = out.slice(0, maxChars) + \"\\n\";\n  return out;\n}\n\nfunction flattenMatrix(matrix, maxItems = MAX_LIST_ITEMS) {\n  const m = normalizeToMatrix(matrix);\n  const out = [];\n  for (const row of m) {\n    const r = Array.isArray(row) ? row : [row];\n    for (const cell of r) {\n      out.push(toScalarString(cell));\n      if (out.length >= maxItems) return out;\n    }\n  }\n  return out;\n}\n\nfunction parseShowSource(showSource) {\n  // Allowed \"options\" exception: 0/1 numeric flag for AI.WEB\n  const n = Number(showSource);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseSummarizeMode(mode) {\n  const n = Number(mode);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseLabels(labels) {\n  if (isMatrix(labels)) {\n    const flat = flattenMatrix(labels, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n    return dedupe(flat);\n  }\n\n  const s = toScalarString(labels);\n  const parts = s\n    .split(/[,\\|;\\n\\r]+/)\n    .map((x) => x.trim())\n    .filter(Boolean);\n  return dedupe(parts);\n}\n\nfunction dedupe(list) {\n  const seen = new Set();\n  const out = [];\n  for (const x of list) {\n    const k = x.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(x);\n  }\n  return out;\n}\n\nfunction makeSourcesBlock(sources, max = 8) {\n  const src = Array.isArray(sources) ? sources : [];\n  const list = src.slice(0, max);\n  if (!list.length) return \"\";\n\n  const lines = [\"\", \"Sources:\"];\n  let i = 1;\n  for (const s of list) {\n    const title = (s?.title || \"\").trim();\n    const url = (s?.url || \"\").trim();\n    if (!url) continue;\n    lines.push(`${i}. ${title ? title + \" - \" : \"\"}${url}`);\n    i++;\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction cfError(code, message) {\n  try {\n    if (typeof CustomFunctions !== \"undefined\" && CustomFunctions?.Error) {\n      const errCode = code || CustomFunctions.ErrorCode.invalidValue;\n      return new CustomFunctions.Error(errCode, message);\n    }\n  } catch {\n    // ignore\n  }\n  return `#ERROR: ${message}`;\n}\n\nfunction parseJsonSafe(text) {\n  const s = String(text || \"\").trim();\n\n  // 1. Try to find a markdown code block anywhere in the string\n  const codeBlockMatch = s.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n  if (codeBlockMatch) {\n    return JSON.parse(codeBlockMatch[1]);\n  }\n\n  // 2. If no code block, try to parse the whole string first.\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    // 3. Fallback: try to locate substring starting with {|[ and ending with }|]\n    // Simple heuristic: find first { and last }\n    const firstCurly = s.indexOf(\"{\");\n    const lastCurly = s.lastIndexOf(\"}\");\n    if (firstCurly !== -1 && lastCurly > firstCurly) {\n      try {\n        return JSON.parse(s.slice(firstCurly, lastCurly + 1));\n      } catch { } // ignore\n    }\n\n    const firstSquare = s.indexOf(\"[\");\n    const lastSquare = s.lastIndexOf(\"]\");\n    if (firstSquare !== -1 && lastSquare > firstSquare) {\n      try {\n        return JSON.parse(s.slice(firstSquare, lastSquare + 1));\n      } catch { }\n    }\n\n    throw e; // Original parse error\n  }\n}\n\n// ---- System prompts (no sampling controls) ----\n\nconst NO_CLARIFY = \"Never ask clarifying questions. If information is missing, make reasonable assumptions and proceed.\";\n\nfunction sysAsk(lang = \"fr\") {\n  return [\n    \"You are an assistant embedded in Microsoft Excel custom functions.\",\n    `Respond in ${lang}.`,\n    \"Return a clear and accurate answer suitable for an Excel cell.\",\n    NO_CLARIFY,\n    \"No Markdown. No code fences. No surrounding quotes.\",\n    \"If the question cannot be answered from the provided information, say so briefly.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTranslate(targetLang, expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  if (n > 1) {\n    return [\n      \"You are a translation engine.\",\n      `Translate each cell independently into ${targetLang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${n} strings in the same order as the provided cells.`,\n      \"Each item must contain ONLY the translated text for that cell.\",\n      \"Preserve numbers, units, and identifiers as-is unless they require translation.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not add any keys other than 'items'.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a translation engine.\",\n    `Translate the user text into ${targetLang}.`,\n    NO_CLARIFY,\n    \"Return only the translated text. No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClassify(labels, lang = \"en\") {\n  return [\n    \"You are a strict classifier.\",\n    `Return exactly one label from this set, using the label text verbatim: ${labels.join(\" | \")}`,\n    \"Do not translate, expand, or paraphrase labels.\",\n    \"If uncertain, return exactly: UNKNOWN\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    \"Return only the label.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClean(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You are a text normalizer for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Preserve the meaning of each cell independently.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not invent or merge content.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a text normalizer for spreadsheet cells.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return only the cleaned text.\",\n    \"No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysConsistent(lang = \"fr\", expectedItems) {\n  return [\n    \"You harmonize spreadsheet entries that refer to the same real-world value.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n    \"Normalize casing, accents, spacing, and fix obvious typos.\",\n    \"When several cells refer to the same entity, use ONE consistent, best-written value for all of them.\",\n    \"Keep outputs aligned with inputs; do not merge or reorder rows.\",\n    \"If an input is empty or whitespace-only, return an empty string for that position.\",\n    \"Do not invent new information beyond correcting the given values.\"\n  ].join(\"\\n\");\n}\n\nfunction sysSummarize(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You summarize text for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Summarize each cell independently; do not merge content across cells.\",\n      \"Use bullet points with '-' when it improves readability.\",\n      \"Keep outputs aligned with inputs. If an input is empty or whitespace-only, return an empty string for that position.\",\n      \"No Markdown headers. No code fences. No surrounding quotes.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You summarize text for a spreadsheet cell.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return a clear summary suitable for an Excel cell.\",\n    \"Use bullet points with '-' when it improves readability.\",\n    \"No Markdown headers. No code fences. No surrounding quotes.\"\n  ].join(\"\\n\");\n}\n\nfunction sysExtract(instruction, lang = \"fr\", expectedItems) {\n  const strictArray =\n    typeof expectedItems === \"number\" && expectedItems > 0\n      ? `Return an object with a single key 'items' which is an array of exactly ${expectedItems} strings, preserving order.`\n      : \"Return an object with a single key 'items' which is an array of strings.\";\n\n  return [\n    \"You are an expert extraction engine.\",\n    `Goal: Extract all entities matching this description: \"${instruction}\"`,\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Lightly normalize results (trim spaces, fix obvious email obfuscation like [at]/(at) -> @ and [dot]/(dot)/point -> .).\",\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    strictArray,\n    \"Example: { \\\"items\\\": [\\\"match1\\\", \\\"match2\\\"] }\",\n    typeof expectedItems === \"number\"\n      ? \"If a value is missing for a cell, return an empty string in that position.\"\n      : \"If nothing found, return { \\\"items\\\": [] }.\",\n    \"Extract exact values from the text without inventing data.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFill(lang = \"fr\", expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  const spec = n > 0\n    ? `Return an object with a single key 'values' containing exactly ${n} strings, in the same order as the target rows.`\n    : \"Return an object with a single key 'values' containing an array of strings.\";\n\n  return [\n    \"You are filling spreadsheet cells based on examples.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    spec,\n    \"Return only the values, in order, one per target row.\",\n    \"If a value is unknown, return an empty string for that row.\",\n    \"Do not add any keys other than 'values'.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFormula(lang) {\n  const isFr = (lang || \"\").toLowerCase().startsWith(\"fr\");\n  return [\n    \"You are an expert Excel formula generator.\",\n    \"Your goal is to output a VALID Excel formula string based on the user request.\",\n    \"Leverage advanced Excel capabilities (dynamic arrays, LET/LAMBDA, structured references, advanced date/time, lookup, statistics, financial functions) when relevant.\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    isFr\n      ? \"Use FRENCH Excel function names (e.g., SOMME, SI, RECHERCHEV...).\"\n      : \"Use ENGLISH Excel function names (e.g., SUM, IF, VLOOKUP...).\",\n    isFr ? \"Use SEMICOLON (;) as argument separator.\" : \"Use COMMA (,) as argument separator.\",\n    \"Return exactly one ready-to-use Excel formula with no surrounding text.\",\n    \"Return ONLY the formula starting with '='.\",\n    \"No Markdown. No code fences. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTable() {\n  return [\n    \"You generate tables for Excel.\",\n    NO_CLARIFY,\n    \"Return JSON that matches the provided schema.\",\n    \"Do not include any extra keys.\",\n    \"Use strings for all cell values.\"\n  ].join(\" \");\n}\nfunction sysWeb(lang = \"fr\") {\n  return [\n    \"You are a meticulous fact-finding assistant with access to reliable web knowledge.\",\n    NO_CLARIFY,\n    \"Return only one precise, up-to-date factual value plus the best authoritative source URL.\",\n    \"Never fabricate numbers or URLs. Use official or authoritative sources only.\",\n    \"Match the requested timeframe and scope exactly; ignore partial or approximate figures.\",\n    \"If the data cannot be confirmed with high confidence, return empty strings and explain why in a 'reason' field.\",\n    `Respond in ${lang}.`,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    'Schema: {\"value\": \"<concise value>\", \"source\": \"https://...\", \"reason\": \"<why unavailable>\"}.',\n    \"The value must mirror the source exactly and stay under 80 characters.\"\n  ].join(\"\\n\");\n}\n\n// ---- Custom Functions ----\n\nexport async function KEY_STATUS() {\n  try {\n    const provider = await getDefaultProvider();\n    const maxTok = await getMaxOutputTokens();\n\n    const gemKey = await getApiKey(PROVIDERS.GEMINI);\n    const oaiKey = await getApiKey(PROVIDERS.OPENAI);\n\n    const gemModel = await getModel(PROVIDERS.GEMINI);\n    const oaiModel = await getModel(PROVIDERS.OPENAI);\n\n    const lines = [\n      `Default provider: ${provider}`,\n      `Max output tokens: ${maxTok}`,\n      `Gemini: ${gemKey ? \"key set\" : \"key missing\"} / model: ${gemModel}`,\n      `OpenAI: ${oaiKey ? \"key set\" : \"key missing\"} / model: ${oaiModel}`,\n      `Storage: ${storageBackendName()}`\n    ];\n\n    return lines.join(\"\\n\");\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, e?.message || \"Erreur KEY_STATUS.\");\n  }\n}\n\nexport async function TEST() {\n  const r = await aiMinimalTest();\n  if (r.ok) return \"OK\";\n  return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Test chou.\");\n}\n\nexport async function ASK(prompt, contextRange) {\n  const q = toScalarString(prompt).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre prompt est vide.\");\n\n  const hasContext = contextRange != null && isMatrix(contextRange);\n  const context = hasContext ? matrixToTSV(contextRange) : \"\";\n\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nQuestion:\\n${q}`\n    : q;\n\n  const r = await aiGenerate({\n    system: sysAsk(DEFAULT_LANG),\n    user,\n    webSearch: false,\n    functionName: \"AI.ASK\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.ASK.\");\n\n  // Strip markdown bold/italic/headers to force plain text for Excel\n  let text = r.text || \"\";\n  text = text.replace(/\\*\\*/g, \"\").replace(/##/g, \"\").replace(/__/g, \"\");\n  return truncateForCell(text);\n}\n\nexport async function WEB(query, focus, showSource) {\n  const q = toScalarString(query).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre query est vide.\");\n\n  const context = focus != null && isMatrix(focus) ? matrixToTSV(focus) : \"\";\n  const user = context ? `Contexte (TSV):\\n${context}\\n\\nRequte web:\\n${q}` : q;\n\n  const r = await aiGenerate({\n    system: sysWeb(DEFAULT_LANG),\n    user,\n    webSearch: true,\n    functionName: \"AI.WEB\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.WEB.\");\n\n  let text = r.text || \"\";\n  let sources = Array.isArray(r.sources) ? r.sources : [];\n  let value = text;\n\n  try {\n    const obj = parseJsonSafe(text);\n    if (obj && typeof obj === \"object\") {\n      const v = toScalarString(obj.value).trim();\n      const src = toScalarString(obj.source).trim();\n      const reason = toScalarString(obj.reason).trim();\n      if (v) value = v;\n      else if (reason) value = reason;\n      if (src) sources = [{ title: \"\", url: src }];\n    }\n  } catch {\n    // Fallback to raw text + provider sources\n  }\n\n  const withSources = parseShowSource(showSource) === 1 ? value + makeSourcesBlock(sources) : value;\n  return truncateForCell(withSources);\n}\n\nexport async function TRANSLATE(textOrRange, targetLang) {\n  const lang = toScalarString(targetLang).trim();\n  if (!lang) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La langue cible est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.TRANSLATE.`\n    );\n  }\n\n  // Batch translation in one call for performance.\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      `Translate each item to: ${lang}.`,\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Translate to ${lang}:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysTranslate(lang, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.TRANSLATE\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TRANSLATE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // fall back: best-effort split, but log if empty\n      if (!r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Rponse vide (TRANSLATE).\");\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  // Normalize length\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  // Rebuild matrix\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLASSIFY(textOrRange, labels) {\n  const allowed = parseLabels(labels);\n  if (!allowed.length) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La liste de labels est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLASSIFY.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const labelList = allowed.join(\" | \");\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n\n  const user = isBatch\n    ? [\n      \"Classify each item into exactly one label from the allowed list.\",\n      `Allowed labels: ${labelList}`,\n      `Return JSON with items array of length ${expectedItems}. Use UNKNOWN if unsure.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : [\n      \"Classify the following text into exactly one allowed label.\",\n      `Allowed labels: ${labelList}`,\n      \"\",\n      flat[0] || \"\"\n    ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysClassify(allowed, DEFAULT_LANG),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLASSIFY\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLASSIFY.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"UNKNOWN\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const allowedLower = new Map(allowed.map((l) => [l.toLowerCase(), l]));\n  items = items.map((it) => {\n    const key = it.toLowerCase();\n    return allowedLower.get(key) || (it ? it : \"UNKNOWN\");\n  });\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"UNKNOWN\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function EXTRACT(textOrRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.EXTRACT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  // Single cell: allow multiple extracted items and return a vertical spill\n  if (flat.length === 1) {\n    const user = [\n      `Instruction: ${instr}`,\n      \"Input:\",\n      flat[0]\n    ].join(\"\\n\\n\");\n\n    const r = await aiGenerate({\n      system: sysExtract(instr, DEFAULT_LANG),\n      user,\n      responseMimeType: \"application/json\",\n      responseJsonSchema: schema,\n      functionName: \"AI.EXTRACT\"\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n    let items = [];\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim()).filter(Boolean);\n    } catch {\n      // Best effort\n      items = r.text.split(\"\\n\").map((x) => x.trim()).filter(Boolean);\n      if (items.length === 0 && r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, `JSON Error: ${r.text.slice(0, 100)}`);\n    }\n\n    if (!items.length) return [[\"\"]];\n    return items.map((x) => [truncateForCell(x)]);\n  }\n\n  // Range: return exactly one extracted value per cell (best-effort)\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    `Instruction: ${instr}`,\n    `Return JSON with items array of length ${flat.length}.`,\n    \"Each item must be the best extracted value for the corresponding input (or empty string if none).\",\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysExtract(instr, DEFAULT_LANG, flat.length),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.EXTRACT_BATCH\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLEAN(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLEAN.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Clean each item for Excel (whitespace, line breaks).\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Clean this text for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysClean(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLEAN\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLEAN.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CONSISTENT(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CONSISTENT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    \"Normalize each item so that near-duplicates become identical.\",\n    `Return JSON with items array of length ${expectedItems}.`,\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysConsistent(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.CONSISTENT\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CONSISTENT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function FORMULA(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nDescription:\\n${desc}`\n    : desc;\n\n  const locale = getExcelLocale();\n  const formulaLang = isFrenchLocale(locale) ? \"fr\" : \"en\";\n\n  const r = await aiGenerate({\n    system: sysFormula(formulaLang),\n    user,\n    webSearch: false,\n    functionName: \"AI.FORMULA\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FORMULA.\");\n\n  // Extract first formula starting with \"=\"\n  const text = (r.text || \"\").trim();\n  const m1 = text.match(/=[^\\n\\r]+/);\n  const formula = (m1 ? m1[0] : text).trim();\n\n  if (!formula.startsWith(\"=\")) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"La rponse n'est pas une formule Excel valide.\");\n  }\n  return truncateForCell(formula);\n}\n\nexport async function TABLE(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"headers\", \"rows\"],\n    properties: {\n      headers: { type: \"array\", items: { type: \"string\" } },\n      rows: {\n        type: \"array\",\n        items: {\n          type: \"array\",\n          items: { type: \"string\" }\n        }\n      }\n    }\n  };\n\n  const user = [\n    \"Build a table for Excel based on the description and optional context.\",\n    \"Return JSON { headers: [...], rows: [[...], ...] }\",\n    context ? `\\nContext (TSV):\\n${context}` : \"\",\n    `\\nDescription:\\n${desc}`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysTable(),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.TABLE\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TABLE.\");\n\n  let obj = null;\n  try {\n    obj = parseJsonSafe(r.text);\n  } catch {\n    // If strict parsing fails, try to just find the first JSON-like object\n    try {\n      const match = r.text.match(/\\{[\\s\\S]*\\}/);\n      if (match) obj = JSON.parse(match[0]);\n      else throw new Error();\n    } catch {\n      return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"Impossible de parser le JSON renvoy par l'IA.\");\n    }\n  }\n\n  const headers = Array.isArray(obj?.headers) ? obj.headers.map((x) => truncateForCell(toScalarString(x))) : [];\n  const rows = Array.isArray(obj?.rows) ? obj.rows : [];\n\n  const width = headers.length || (Array.isArray(rows?.[0]) ? rows[0].length : 0) || 1;\n  const safeHeaders = headers.length ? headers : Array.from({ length: width }, (_, i) => `Col${i + 1}`);\n\n  const out = [safeHeaders];\n\n  for (const r0 of rows) {\n    const row = Array.isArray(r0) ? r0.map((x) => truncateForCell(toScalarString(x))) : [];\n    // pad / truncate to width\n    while (row.length < safeHeaders.length) row.push(\"\");\n    if (row.length > safeHeaders.length) row.length = safeHeaders.length;\n    out.push(row);\n  }\n\n  return out;\n}\n\nexport async function FILL(exampleRange, targetRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const ex = normalizeToMatrix(exampleRange);\n  const tgt = normalizeToMatrix(targetRange);\n\n  const nRows = tgt.length;\n  if (nRows <= 0) return [[\"\"]];\n\n  if (nRows > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage cible trop grande (max ${MAX_BATCH_CELLS} lignes) pour AI.FILL.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"values\"],\n    properties: {\n      values: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const user = [\n    `Instruction: ${instr}`,\n    \"\",\n    \"Examples (TSV):\",\n    matrixToTSV(ex, 6000),\n    \"\",\n    \"Target rows (TSV):\",\n    matrixToTSV(tgt, 6000),\n    \"\",\n    `Return JSON with values array of length ${nRows} (one value per target row).`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysFill(DEFAULT_LANG, nRows),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.FILL\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FILL.\");\n\n  let values = [];\n  try {\n    const obj = JSON.parse(r.text);\n    if (Array.isArray(obj?.values)) values = obj.values.map((x) => toScalarString(x));\n  } catch {\n    values = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (values.length < nRows) values.push(\"\");\n  if (values.length > nRows) values = values.slice(0, nRows);\n\n  return values.map((v) => [truncateForCell(v)]);\n}\n\nexport async function SUMMARIZE(textOrRange, mode) {\n  const summarizeMode = parseSummarizeMode(mode);\n  const m = normalizeToMatrix(textOrRange);\n\n  if (summarizeMode === 1) {\n    const flat = flattenMatrix(m, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n\n    if (!flat.length) return [[\"\"]];\n\n    const joined = flat.join(\"\\n\");\n    const user = `Content:\\n${joined}`;\n\n    const r = await aiGenerate({\n      system: sysSummarize(DEFAULT_LANG),\n      user,\n      webSearch: false,\n      functionName: \"AI.SUMMARIZE\"\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n    return [[truncateForCell(r.text)]];\n  }\n\n  const flat = flattenMatrix(m, 2000).map((s) => s.trim());\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (!expectedItems) return [[\"\"]];\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Summarize each item for Excel.\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Summarize for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysSummarize(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.SUMMARIZE\"\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport function COUNT(range, value) {\n  try {\n    const m = normalizeToMatrix(range);\n    const needle = toScalarString(value).toLowerCase();\n\n    let count = 0;\n    for (const row of m) {\n      const r = Array.isArray(row) ? row : [row];\n      for (const cell of r) {\n        if (toScalarString(cell).toLowerCase() === needle) count++;\n      }\n    }\n    return count;\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.invalidValue, e?.message || \"Erreur AI.COUNT.\");\n  }\n}\n\n// ---- Registration (robust for shared runtime timing) ----\n\nfunction registerAll() {\n  // Associate function names exactly as used in functions.json (ids map to namespace AI.*)\n  try {\n    if (typeof CustomFunctions === \"undefined\" || !CustomFunctions?.associate) return false;\n\n    const safeAssociate = (id, fn) => {\n      try {\n        CustomFunctions.associate(id, fn);\n        return true;\n      } catch {\n        return false;\n      }\n    };\n\n    let ok = true;\n    ok = safeAssociate(\"AI.KEYSTATUS\", KEY_STATUS) && ok;\n    ok = safeAssociate(\"AI.TEST\", TEST) && ok;\n    ok = safeAssociate(\"AI.ASK\", ASK) && ok;\n    ok = safeAssociate(\"AI.WEB\", WEB) && ok;\n    ok = safeAssociate(\"AI.TRANSLATE\", TRANSLATE) && ok;\n    ok = safeAssociate(\"AI.CLASSIFY\", CLASSIFY) && ok;\n    ok = safeAssociate(\"AI.EXTRACT\", EXTRACT) && ok;\n    ok = safeAssociate(\"AI.CLEAN\", CLEAN) && ok;\n    ok = safeAssociate(\"AI.CONSISTENT\", CONSISTENT) && ok;\n    ok = safeAssociate(\"AI.FORMULA\", FORMULA) && ok;\n    ok = safeAssociate(\"AI.TABLE\", TABLE) && ok;\n    ok = safeAssociate(\"AI.FILL\", FILL) && ok;\n    ok = safeAssociate(\"AI.SUMMARIZE\", SUMMARIZE) && ok;\n    ok = safeAssociate(\"AI.COUNT\", COUNT) && ok;\n\n    return ok;\n  } catch {\n    return false;\n  }\n}\n\n// Poll until CustomFunctions is available (Office.js loads after functions.js in taskpane.html)\nconst regTimer = setInterval(() => {\n  if (registerAll()) clearInterval(regTimer);\n}, 200);\n"],"names":["PROVIDERS","Object","freeze","GEMINI","OPENAI","DEFAULTS","provider","geminiModel","openaiModel","openaiReasoningEffort","maxOutputTokens","retry","timeoutMs","cache","cacheTtlSec","webCacheTtlSec","STORAGE_KEYS","DEFAULT_PROVIDER","GEMINI_API_KEY","OPENAI_API_KEY","GEMINI_MODEL","OPENAI_MODEL","OPENAI_REASONING_EFFORT","MAX_OUTPUT_TOKENS","MIGRATION_DONE","REQUEST_LOG","REQUEST_LOG_CLEAR_AT","CACHE_INDEX","CACHE_CLEAR_AT","LEGACY_KEYS","DEFAULT_PROVIDER_V2","GEMINI_API_KEY_V2","OPENAI_API_KEY_V2","GEMINI_MODEL_V2","OPENAI_MODEL_V2","GEMINI_MAX_TOKENS_V2","OPENAI_MAX_TOKENS_V2","_migrationPromise","getRuntimeStorage","OfficeRuntime","storage","getItem","kind","window","localStorage","mem","Map","async","k","has","get","setItem","v","set","String","removeItem","delete","getLocalStorageSafe","rawGet","key","result","local","localValue","rawSet","value","ensureMigrated","normalizeProvider","legacyProvider","legacy","candidates","map","x","parseInt","trim","filter","n","Number","isFinite","migrated","length","Math","max","p","s","toLowerCase","OPENAI_REASONING_EFFORTS","Set","getDefaultProvider","getApiKey","keyKey","getModel","raw","modelKey","getMaxOutputTokens","clampInt","nowMs","Date","now","sleep","ms","Promise","resolve","setTimeout","min","fallback","parseTimestampMs","CACHE_ENTRY_PREFIX","_cacheClearMs","syncCacheClearMarker","clearedAt","loadCacheIndex","arr","JSON","parse","Array","isArray","saveCacheIndex","entries","stringify","removeCacheEntry","rawRemove","removeFromCacheIndex","index","next","item","setPersistentCache","cacheKey","ttlMs","meta","savedAtMs","expiresAtMs","entry","model","size","updated","push","pruned","kept","removedKeys","savedAt","sort","a","b","over","toRemove","slice","r","list","pruneCacheIndex","sortKeysDeep","prototype","toString","call","out","keys","REQUEST_LOG_TTL_MS","_requestLog","_requestLogLoading","_requestLogLoaded","_requestLogLastLoadedMs","_requestLogClearMs","syncRequestLogClearMarker","options","reset","persistRequestLog","pruneRequestLog","e","ts","logRequest","logEntry","force","parsed","loadRequestLog","logRequestAsync","CACHE","constructor","maxEntries","this","oldestKey","clear","_cacheClearLocalMs","INFLIGHT","active","queue","isNonEmptyString","normalizeBoolean","def","includes","normalizeTimeoutMs","toLowerMsg","looksLikeStructuredOutputUnsupported","message","looksLikeWebSearchUnsupported","ensureJsonInstruction","system","test","getFormulaForLog","fnName","text","match","formula","startsWith","extractFormulaFromText","aiGenerate","req","start","apiKey","functionName","fn","ok","code","user","webSearch","cfgMax","normalizeMaxOutputTokens","reasoningEffort","normalizeReasoningEffort","getOpenAIReasoningEffort","cacheEnabled","ttlSec","getCacheClearAt","cacheKeyPayload","responseMimeType","responseJsonSchema","input","crypto","subtle","digest","TextEncoder","bytes","encode","from","Uint8Array","padStart","join","str","h","i","charCodeAt","imul","fnv1a32","hashKey","cached","cacheKind","inputTokens","outputTokens","totalTokens","undefined","persisted","Error","getPersistentCache","attempt","lastErr","callProvider","url","body","max_output_tokens","store","reasoning","effort","sysText","instructions","format","type","name","strict","schema","tools","include","res","fetchWithTimeout","method","headers","Authorization","json","safeJson","msg","error","extractOpenAIError","status","output_text","output","texts","content","part","choices","extractOpenAIText","sources","action","src","title","dedupeSources","extractOpenAISources","usage","u","toInt","input_tokens","output_tokens","total_tokens","cachedInputTokens","input_tokens_details","cached_tokens","extractOpenAIUsage","callOpenAI","opts","encodeURIComponent","geminiEndpoint","contents","role","parts","generationConfig","systemInstruction","responseSchema","google_search","extractGeminiError","c","extractGeminiText","md","groundingMetadata","chunks","groundingChunks","ch","web","uri","extractGeminiSources","usageMetadata","promptTokenCount","candidatesTokenCount","totalTokenCount","extractGeminiUsage","callGemini","baseOpts","wantsStructured","normalizeUsage","shift","withConcurrencyLimit","floor","seen","add","t","AbortController","fetch","ctrl","id","abort","signal","clearTimeout","MAX_BATCH_CELLS","POSITIVE_INFINITY","DEFAULT_LANG","isMatrix","normalizeToMatrix","toScalarString","truncateForCell","EXCEL_CELL_CHAR_LIMIT","matrixToTSV","matrix","maxChars","m","lines","row","flattenMatrix","maxItems","cell","dedupe","cfError","CustomFunctions","errCode","ErrorCode","invalidValue","parseJsonSafe","codeBlockMatch","firstCurly","indexOf","lastCurly","lastIndexOf","firstSquare","lastSquare","NO_CLARIFY","sysAsk","lang","sysTranslate","targetLang","expectedItems","sysClassify","labels","sysClean","sysConsistent","sysSummarize","sysExtract","instruction","sysFill","sysFormula","isFr","sysWeb","KEY_STATUS","maxTok","gemKey","oaiKey","gemModel","notAvailable","TEST","aiMinimalTest","ASK","prompt","contextRange","q","context","replace","WEB","query","focus","showSource","obj","source","reason","withSources","parseShowSource","makeSourcesBlock","TRANSLATE","textOrRange","flat","isBatch","additionalProperties","required","properties","items","split","j","CLASSIFY","allowed","Boolean","parseLabels","labelList","allowedLower","l","it","EXTRACT","instr","CLEAN","CONSISTENT","FORMULA","description","desc","formulaLang","locale","Office","displayLanguage","contentLanguage","navigator","language","getExcelLocale","m1","TABLE","rows","width","safeHeaders","_","r0","FILL","exampleRange","targetRange","ex","tgt","nRows","values","SUMMARIZE","mode","summarizeMode","parseSummarizeMode","COUNT","range","needle","count","regTimer","setInterval","associate","safeAssociate","registerAll","clearInterval"],"ignoreList":[],"sourceRoot":""}