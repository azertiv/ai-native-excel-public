{"version":3,"file":"functions.js","mappings":"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","sources":["webpack://excel-ai-gemini-addin/./src/shared/core.js","webpack://excel-ai-gemini-addin/./src/shared/providers.js","webpack://excel-ai-gemini-addin/./src/functions/functions.js"],"sourcesContent":["// src/shared/core.js\n// Shared utilities + persisted configuration for the Neurow add-in.\n//\n// Key design goals:\n// - Two providers (Gemini + OpenAI) can coexist.\n// - The default provider is chosen in the taskpane (not in formulas).\n// - No temperature / sampling controls anywhere (per requirements).\n// - A single \"max output tokens\" setting applies to both providers.\n\nexport const PROVIDERS = Object.freeze({\n  GEMINI: \"gemini\",\n  OPENAI: \"openai\"\n});\n\nexport const DEFAULTS = Object.freeze({\n  provider: PROVIDERS.GEMINI,\n  // Default models (User specified future versions)\n  geminiModel: \"gemini-3-flash-preview\",\n  openaiModel: \"gpt-5-mini\",\n  geminiReasoningEffort: \"minimal\",\n  openaiReasoningEffort: \"low\",\n  maxOutputTokens: 4096,\n  concurrencyLimit: 4,\n\n  // Execution / UX\n  retry: 2,\n  timeoutMs: 120000,\n\n  // In-memory cache (per runtime). Note: Office custom functions can run in a long-lived runtime.\n  cache: true,\n  cacheTtlSec: 7 * 24 * 3600, // 7 days\n  webCacheTtlSec: 3600 // 1 hour (web results change more often)\n});\n\nconst STORAGE_KEYS = Object.freeze({\n  DEFAULT_PROVIDER: \"AI_DEFAULT_PROVIDER_V3\",\n  GEMINI_API_KEY: \"AI_GEMINI_API_KEY_V3\",\n  OPENAI_API_KEY: \"AI_OPENAI_API_KEY_V3\",\n  GEMINI_MODEL: \"AI_GEMINI_MODEL_V3\",\n  OPENAI_MODEL: \"AI_OPENAI_MODEL_V3\",\n  GEMINI_REASONING_EFFORT: \"AI_GEMINI_REASONING_EFFORT_V3\",\n  OPENAI_REASONING_EFFORT: \"AI_OPENAI_REASONING_EFFORT_V3\",\n  MAX_OUTPUT_TOKENS: \"AI_MAX_OUTPUT_TOKENS_V3\",\n  CONCURRENCY_LIMIT: \"AI_CONCURRENCY_LIMIT_V1\",\n  ONBOARDING_SEEN: \"AI_ONBOARDING_SEEN_V1\",\n  ONBOARDING_KEYS_CONFIRMED: \"AI_ONBOARDING_KEYS_CONFIRMED_V1\",\n  SECTION_ORDER: \"AI_SECTION_ORDER_V1\",\n  SECTION_HIDDEN: \"AI_SECTION_HIDDEN_V1\",\n  LICENSE: \"AI_LICENSE_V1\",\n  PRIVACY_MODE: \"AI_PRIVACY_MODE_V1\",\n\n  // Prevent re-running migrations each time.\n  MIGRATION_DONE: \"AI_MIGRATION_DONE_V3\",\n\n  // Diagnostics + cache metadata\n  REQUEST_LOG: \"AI_REQUEST_LOG_V1\",\n  REQUEST_LOG_CLEAR_AT: \"AI_REQUEST_LOG_CLEAR_AT_V1\",\n  USAGE_TOTALS: \"AI_USAGE_TOTALS_V1\",\n  CACHE_INDEX: \"AI_CACHE_INDEX_V1\",\n  CACHE_CLEAR_AT: \"AI_CACHE_CLEAR_AT_V1\",\n  RUNTIME_STATUS: \"AI_RUNTIME_STATUS_V1\"\n});\n\nconst SENSITIVE_KEYS = new Set([STORAGE_KEYS.GEMINI_API_KEY, STORAGE_KEYS.OPENAI_API_KEY, STORAGE_KEYS.LICENSE]);\n\n// Older keys used by previous versions (best-effort migration).\nconst LEGACY_KEYS = Object.freeze({\n  GEMINI_API_KEY: \"GEMINI_API_KEY\",\n  MAX_OUTPUT_TOKENS: \"MAX_OUTPUT_TOKENS\",\n\n  DEFAULT_PROVIDER_V2: \"AI_DEFAULT_PROVIDER_V2\",\n  GEMINI_API_KEY_V2: \"AI_GEMINI_API_KEY_V2\",\n  OPENAI_API_KEY_V2: \"AI_OPENAI_API_KEY_V2\",\n  GEMINI_MODEL_V2: \"AI_GEMINI_MODEL_V2\",\n  OPENAI_MODEL_V2: \"AI_OPENAI_MODEL_V2\",\n\n  GEMINI_MAX_TOKENS_V2: \"AI_GEMINI_MAX_OUTPUT_TOKENS_V2\",\n  OPENAI_MAX_TOKENS_V2: \"AI_OPENAI_MAX_OUTPUT_TOKENS_V2\"\n});\n\nlet _migrationPromise = null;\nlet _officeStorageFailed = false;\nlet _privacyModeCache = null;\nlet _privacyModeCacheAt = 0;\n\nfunction markOfficeStorageFailed() {\n  _officeStorageFailed = true;\n}\n\nfunction isSensitiveKey(key) {\n  return SENSITIVE_KEYS.has(key);\n}\n\nfunction getRuntimeStorage() {\n  if (!_officeStorageFailed) {\n    try {\n      if (typeof OfficeRuntime !== \"undefined\" && OfficeRuntime?.storage?.getItem) {\n        return { kind: \"office\", storage: OfficeRuntime.storage };\n      }\n    } catch {\n      // ignore\n    }\n  }\n\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return { kind: \"local\", storage: window.localStorage };\n    }\n  } catch {\n    // ignore\n  }\n\n  // Extremely defensive fallback (in-memory only).\n  const mem = new Map();\n  return {\n    kind: \"memory\",\n    storage: {\n      async getItem(k) {\n        return mem.has(k) ? mem.get(k) : null;\n      },\n      async setItem(k, v) {\n        mem.set(k, String(v));\n      },\n      async removeItem(k) {\n        mem.delete(k);\n      }\n    }\n  };\n}\n\nfunction getLocalStorageSafe() {\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return window.localStorage;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nfunction localGet(local, key) {\n  try {\n    return local.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nfunction localSet(local, key, value) {\n  try {\n    local.setItem(key, value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction localRemove(local, key) {\n  try {\n    local.removeItem(key);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function storageBackendName() {\n  return getRuntimeStorage().kind;\n}\n\nasync function rawGet(key, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const sensitive = options.sensitive ?? isSensitiveKey(key);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    return localGet(storage, key);\n  }\n\n  if (kind === \"office\") {\n    let result = null;\n    try {\n      result = await storage.getItem(key);\n    } catch {\n      markOfficeStorageFailed();\n    }\n    if (result != null) {\n      if (sensitive) {\n        const local = getLocalStorageSafe();\n        if (local) localRemove(local, key);\n      }\n      return result;\n    }\n    if (!allowLocalFallback) return null;\n\n    const local = getLocalStorageSafe();\n    if (!local) return null;\n    const localValue = localGet(local, key);\n    if (localValue == null) return null;\n\n    if (!_officeStorageFailed) {\n      try {\n        await storage.setItem(key, String(localValue));\n        localRemove(local, key);\n      } catch {\n        markOfficeStorageFailed();\n      }\n    }\n\n    return localValue;\n  }\n\n  try {\n    return await storage.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nasync function rawSet(key, value, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const v = value == null ? \"\" : String(value);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    localSet(storage, key, v);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let stored = false;\n    try {\n      await storage.setItem(key, v);\n      stored = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (stored) {\n      if (local) localRemove(local, key);\n      return;\n    }\n\n    if (!allowLocalFallback || !local) return;\n    localSet(local, key, v);\n    return;\n  }\n\n  try {\n    await storage.setItem(key, v);\n  } catch {\n    // ignore\n  }\n}\n\nasync function rawRemove(key) {\n  const { kind, storage } = getRuntimeStorage();\n\n  if (kind === \"local\") {\n    localRemove(storage, key);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let removed = false;\n    try {\n      await storage.removeItem(key);\n      removed = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (local) localRemove(local, key);\n    return;\n  }\n\n  try {\n    await storage.removeItem(key);\n  } catch {\n    // ignore\n  }\n}\n\nasync function ensureMigrated() {\n  if (_migrationPromise) return _migrationPromise;\n\n  _migrationPromise = (async () => {\n    // Fast exit if already migrated\n    const done = await rawGet(STORAGE_KEYS.MIGRATION_DONE);\n    if (done === \"1\") return;\n\n    // Migrate provider\n    const currentProvider = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n    if (!currentProvider) {\n      const legacyProvider = normalizeProvider(await rawGet(LEGACY_KEYS.DEFAULT_PROVIDER_V2));\n      await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, legacyProvider || DEFAULTS.provider);\n    }\n\n    // Migrate keys\n    const gKey = await rawGet(STORAGE_KEYS.GEMINI_API_KEY);\n    if (!gKey) {\n      const legacy = (await rawGet(LEGACY_KEYS.GEMINI_API_KEY_V2)) || (await rawGet(LEGACY_KEYS.GEMINI_API_KEY));\n      if (legacy) await rawSet(STORAGE_KEYS.GEMINI_API_KEY, legacy);\n    }\n\n    const oKey = await rawGet(STORAGE_KEYS.OPENAI_API_KEY);\n    if (!oKey) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_API_KEY_V2);\n      if (legacy) await rawSet(STORAGE_KEYS.OPENAI_API_KEY, legacy);\n    }\n\n    // Migrate models\n    const gModel = await rawGet(STORAGE_KEYS.GEMINI_MODEL);\n    if (!gModel) {\n      const legacy = await rawGet(LEGACY_KEYS.GEMINI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.GEMINI_MODEL, legacy || DEFAULTS.geminiModel);\n    }\n\n    const oModel = await rawGet(STORAGE_KEYS.OPENAI_MODEL);\n    if (!oModel) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.OPENAI_MODEL, legacy || DEFAULTS.openaiModel);\n    }\n\n    // Migrate max tokens (unified)\n    const tok = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n    if (!tok) {\n      const legacyUnified = await rawGet(LEGACY_KEYS.MAX_OUTPUT_TOKENS);\n      const legacyGem = await rawGet(LEGACY_KEYS.GEMINI_MAX_TOKENS_V2);\n      const legacyOai = await rawGet(LEGACY_KEYS.OPENAI_MAX_TOKENS_V2);\n\n      const candidates = [legacyUnified, legacyGem, legacyOai]\n        .map((x) => parseInt(String(x || \"\").trim(), 10))\n        .filter((n) => Number.isFinite(n) && n > 0);\n\n      const migrated = candidates.length ? Math.max(...candidates) : DEFAULTS.maxOutputTokens;\n      await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(migrated));\n    }\n\n    await rawSet(STORAGE_KEYS.MIGRATION_DONE, \"1\");\n  })();\n\n  try {\n    await _migrationPromise;\n  } finally {\n    _migrationPromise = null;\n  }\n}\n\nexport function normalizeProvider(p) {\n  if (!p) return \"\";\n  const s = String(p).trim().toLowerCase();\n  if (s === PROVIDERS.GEMINI) return PROVIDERS.GEMINI;\n  if (s === PROVIDERS.OPENAI) return PROVIDERS.OPENAI;\n  // Common aliases (defensive)\n  if (s === \"google\" || s === \"gem\") return PROVIDERS.GEMINI;\n  if (s === \"oai\" || s === \"chatgpt\") return PROVIDERS.OPENAI;\n  return \"\";\n}\n\nconst GEMINI_REASONING_EFFORTS = new Set([\"auto\", \"minimal\", \"low\", \"medium\", \"high\"]);\nconst OPENAI_REASONING_EFFORTS = new Set([\"none\", \"minimal\", \"low\", \"medium\", \"high\"]);\n\nfunction normalizeGeminiReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.geminiReasoningEffort;\n  return GEMINI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.geminiReasoningEffort;\n}\n\nfunction normalizeReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.openaiReasoningEffort;\n  return OPENAI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.openaiReasoningEffort;\n}\n\nexport async function getDefaultProvider() {\n  await ensureMigrated();\n  const p = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n  return p || DEFAULTS.provider;\n}\n\nexport async function setDefaultProvider(provider) {\n  const p = normalizeProvider(provider) || DEFAULTS.provider;\n  await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, p);\n  return p;\n}\n\nfunction keyKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_API_KEY;\n  return STORAGE_KEYS.GEMINI_API_KEY;\n}\n\nexport async function getApiKey(provider) {\n  await ensureMigrated();\n  const k = await rawGet(keyKey(provider));\n  return (k || \"\").trim();\n}\n\nexport async function hasApiKey(provider) {\n  const k = await getApiKey(provider);\n  return !!k;\n}\n\nexport async function setApiKey(provider, apiKey) {\n  const k = (apiKey || \"\").trim();\n  await rawSet(keyKey(provider), k);\n  return k;\n}\n\nexport async function clearApiKey(provider) {\n  await rawRemove(keyKey(provider));\n}\n\nfunction modelKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_MODEL;\n  return STORAGE_KEYS.GEMINI_MODEL;\n}\n\nexport async function getModel(provider) {\n  await ensureMigrated();\n  const p = normalizeProvider(provider);\n  const raw = await rawGet(modelKey(p));\n  if (raw && String(raw).trim()) return String(raw).trim();\n  return p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel;\n}\n\nexport async function getGeminiReasoningEffort() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.GEMINI_REASONING_EFFORT);\n  return normalizeGeminiReasoningEffort(raw || DEFAULTS.geminiReasoningEffort);\n}\n\nexport async function getOpenAIReasoningEffort() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.OPENAI_REASONING_EFFORT);\n  return normalizeReasoningEffort(raw || DEFAULTS.openaiReasoningEffort);\n}\n\nexport async function setModel(provider, model) {\n  const p = normalizeProvider(provider);\n  const v = String(model || \"\").trim();\n  if (!v) {\n    // Reset to default if emptied\n    await rawSet(modelKey(p), p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel);\n    return;\n  }\n  await rawSet(modelKey(p), v);\n}\n\nexport async function setOpenAIReasoningEffort(value) {\n  const v = normalizeReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.OPENAI_REASONING_EFFORT, v);\n  return v;\n}\n\nexport async function setGeminiReasoningEffort(value) {\n  const v = normalizeGeminiReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.GEMINI_REASONING_EFFORT, v);\n  return v;\n}\n\nexport async function getMaxOutputTokens() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return clampInt(n, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nexport async function setMaxOutputTokens(value) {\n  const n = clampInt(value, 1, 128000, DEFAULTS.maxOutputTokens);\n  await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(n));\n  return n;\n}\n\nconst CONCURRENCY_OPTIONS = [4, 8, 16, 32, 64];\n\nfunction normalizeConcurrencyLimit(value) {\n  const base = clampInt(\n    value,\n    CONCURRENCY_OPTIONS[0],\n    CONCURRENCY_OPTIONS[CONCURRENCY_OPTIONS.length - 1],\n    DEFAULTS.concurrencyLimit\n  );\n  if (CONCURRENCY_OPTIONS.includes(base)) return base;\n  let best = CONCURRENCY_OPTIONS[0];\n  let bestDiff = Math.abs(base - best);\n  for (const option of CONCURRENCY_OPTIONS.slice(1)) {\n    const diff = Math.abs(base - option);\n    if (diff < bestDiff) {\n      best = option;\n      bestDiff = diff;\n    }\n  }\n  return best;\n}\n\nexport async function getConcurrencyLimit() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.CONCURRENCY_LIMIT);\n  return normalizeConcurrencyLimit(raw);\n}\n\nexport async function setConcurrencyLimit(value) {\n  const normalized = normalizeConcurrencyLimit(value);\n  await rawSet(STORAGE_KEYS.CONCURRENCY_LIMIT, String(normalized));\n  return normalized;\n}\n\nexport async function getOnboardingSeen() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_SEEN);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingSeen(seen = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_SEEN, seen ? \"1\" : \"0\");\n  return seen;\n}\n\nexport async function getOnboardingKeysConfirmed() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingKeysConfirmed(confirmed = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED, confirmed ? \"1\" : \"0\");\n  return confirmed;\n}\n\nfunction normalizeRuntimeStatus(raw) {\n  const base = { active: 0, queued: 0, ts: 0 };\n  if (!raw || typeof raw !== \"object\") return base;\n  const active = clampInt(raw.active, 0, 100000, 0);\n  const queued = clampInt(raw.queued, 0, 100000, 0);\n  const ts = clampInt(raw.ts, 0, Number.MAX_SAFE_INTEGER, 0);\n  return { active, queued, ts };\n}\n\nexport async function getRuntimeStatus() {\n  const raw = await rawGet(STORAGE_KEYS.RUNTIME_STATUS);\n  if (!raw) return normalizeRuntimeStatus(null);\n  try {\n    return normalizeRuntimeStatus(JSON.parse(raw));\n  } catch {\n    return normalizeRuntimeStatus(null);\n  }\n}\n\nexport async function setRuntimeStatus(status) {\n  const normalized = normalizeRuntimeStatus(status);\n  await rawSet(STORAGE_KEYS.RUNTIME_STATUS, JSON.stringify(normalized));\n  return normalized;\n}\n\nconst PRIVACY_MODE_CACHE_TTL_MS = 2000;\n\nasync function loadPrivacyMode() {\n  const now = nowMs();\n  if (_privacyModeCache != null && now - _privacyModeCacheAt < PRIVACY_MODE_CACHE_TTL_MS) {\n    return _privacyModeCache;\n  }\n  const raw = await rawGet(STORAGE_KEYS.PRIVACY_MODE);\n  const enabled = raw === \"1\";\n  _privacyModeCache = enabled;\n  _privacyModeCacheAt = now;\n  return enabled;\n}\n\nexport async function getPrivacyMode() {\n  return await loadPrivacyMode();\n}\n\nexport async function setPrivacyMode(enabled = false) {\n  const next = !!enabled;\n  _privacyModeCache = next;\n  _privacyModeCacheAt = nowMs();\n  await rawSet(STORAGE_KEYS.PRIVACY_MODE, next ? \"1\" : \"0\");\n  return next;\n}\n\nfunction normalizeSectionList(value) {\n  if (!Array.isArray(value)) return [];\n  const out = [];\n  const seen = new Set();\n  for (const item of value) {\n    const key = String(item || \"\").trim();\n    if (!key || seen.has(key)) continue;\n    seen.add(key);\n    out.push(key);\n  }\n  return out;\n}\n\nexport async function getSectionOrder() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_ORDER);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setSectionOrder(order) {\n  const normalized = normalizeSectionList(order);\n  await rawSet(STORAGE_KEYS.SECTION_ORDER, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getHiddenSections() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_HIDDEN);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setHiddenSections(list) {\n  const normalized = normalizeSectionList(list);\n  await rawSet(STORAGE_KEYS.SECTION_HIDDEN, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getLicense() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.LICENSE);\n  if (!raw) return null;\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}\n\nexport async function setLicense(license) {\n  if (!license) {\n    await rawRemove(STORAGE_KEYS.LICENSE);\n    return null;\n  }\n  await rawSet(STORAGE_KEYS.LICENSE, JSON.stringify(license));\n  return license;\n}\n\nexport async function clearLicense() {\n  await rawRemove(STORAGE_KEYS.LICENSE);\n}\n\n// ---------- Small utilities ----------\nexport function nowMs() {\n  return Date.now();\n}\n\nexport function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function clamp(value, min, max, fallback = min) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nexport function clampInt(value, min, max, fallback = min) {\n  const n = parseInt(String(value), 10);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nconst REDACT_PATTERNS = [\n  /\\bsk-[A-Za-z0-9-_]{1,}\\b/gi,\n  /\\bAIza[0-9A-Za-z_-]{1,}\\b/gi,\n  /\\b[A-Z0-9]{4}(?:-[A-Z0-9]{4}){1,3}\\b/gi\n];\n\nexport function redactSensitiveText(value) {\n  if (value == null) return \"\";\n  let text = String(value);\n  for (const pattern of REDACT_PATTERNS) {\n    text = text.replace(pattern, \"[REDACTED]\");\n  }\n  return text;\n}\n\nexport function redactSensitiveValue(value) {\n  if (value == null) return value;\n  if (typeof value === \"string\") return redactSensitiveText(value);\n  if (Array.isArray(value)) return value.map(redactSensitiveValue);\n  if (typeof value === \"object\") {\n    const out = {};\n    for (const [key, entry] of Object.entries(value)) {\n      out[key] = redactSensitiveValue(entry);\n    }\n    return out;\n  }\n  return value;\n}\n\nfunction parseTimestampMs(raw) {\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return Number.isFinite(n) && n > 0 ? n : 0;\n}\n\n// ---------- LRU cache with TTL ----------\nexport class LRUCache {\n  constructor(maxEntries = 500) {\n    this.maxEntries = maxEntries;\n    this.map = new Map(); // key => {value, expiresAtMs}\n  }\n\n  get(key) {\n    if (!this.map.has(key)) return null;\n    const entry = this.map.get(key);\n\n    if (entry?.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      this.map.delete(key);\n      return null;\n    }\n\n    // Refresh key order (most recent)\n    this.map.delete(key);\n    this.map.set(key, entry);\n    return entry.value;\n  }\n\n  set(key, value, ttlMs) {\n    const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? nowMs() + ttlMs : null;\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, { value, expiresAtMs });\n\n    // Evict LRU\n    while (this.map.size > this.maxEntries) {\n      const oldestKey = this.map.keys().next().value;\n      this.map.delete(oldestKey);\n    }\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\n// ---------- Persistent cache (survives reloads) ----------\nconst CACHE_ENTRY_PREFIX = \"AI_CACHE_ENTRY_V1:\";\nconst CACHE_INDEX_MAX = 250;\nlet _cacheClearMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.CACHE_CLEAR_AT));\n  if (clearedAt > _cacheClearMs) _cacheClearMs = clearedAt;\n  return _cacheClearMs;\n}\n\nexport async function getCacheClearAt() {\n  return await syncCacheClearMarker();\n}\n\nasync function loadCacheIndex() {\n  const raw = await rawGet(STORAGE_KEYS.CACHE_INDEX);\n  if (!raw) return [];\n  try {\n    const arr = JSON.parse(raw);\n    return Array.isArray(arr) ? arr : [];\n  } catch {\n    return [];\n  }\n}\n\nasync function saveCacheIndex(entries) {\n  try {\n    await rawSet(STORAGE_KEYS.CACHE_INDEX, JSON.stringify(entries));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneCacheIndex(entries, clearedAt = 0) {\n  const now = nowMs();\n  const kept = [];\n  const removedKeys = [];\n\n  for (const entry of entries || []) {\n    if (!entry || !entry.key) continue;\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= now) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    kept.push(entry);\n  }\n\n  if (kept.length > CACHE_INDEX_MAX) {\n    kept.sort((a, b) => (a.savedAtMs || 0) - (b.savedAtMs || 0));\n    const over = kept.length - CACHE_INDEX_MAX;\n    const toRemove = kept.slice(0, over);\n    for (const r of toRemove) removedKeys.push(r.key);\n    return { list: kept.slice(over), removedKeys };\n  }\n\n  return { list: kept, removedKeys };\n}\n\nasync function removeCacheEntry(key) {\n  if (!key) return;\n  await rawRemove(CACHE_ENTRY_PREFIX + key);\n}\n\nasync function removeFromCacheIndex(key) {\n  const index = await loadCacheIndex();\n  const next = (index || []).filter((item) => item?.key !== key);\n  if (next.length !== index.length) await saveCacheIndex(next);\n}\n\nexport async function getPersistentCache(cacheKey) {\n  if (!cacheKey) return null;\n  if (await getPrivacyMode()) return null;\n  const clearedAt = await syncCacheClearMarker();\n  const raw = await rawGet(CACHE_ENTRY_PREFIX + cacheKey);\n  if (!raw) {\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n\n  try {\n    const entry = JSON.parse(raw);\n    if (!entry || typeof entry !== \"object\") throw new Error(\"Invalid entry\");\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    return entry.value || null;\n  } catch {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n}\n\nexport async function setPersistentCache(cacheKey, value, ttlMs, meta = {}) {\n  if (!cacheKey) return;\n  if (await getPrivacyMode()) return;\n  const now = nowMs();\n  const clearedAt = await syncCacheClearMarker();\n  const savedAtMs = clearedAt && now <= clearedAt ? clearedAt + 1 : now;\n  const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? savedAtMs + ttlMs : null;\n  const entry = {\n    v: 1,\n    savedAtMs,\n    expiresAtMs,\n    value\n  };\n\n  const raw = JSON.stringify(entry);\n  await rawSet(CACHE_ENTRY_PREFIX + cacheKey, raw);\n\n  const index = await loadCacheIndex();\n  const provider = meta.provider || value?.provider || \"\";\n  const model = meta.model || value?.model || \"\";\n  const size = raw.length;\n\n  let updated = false;\n  const next = (index || []).map((item) => {\n    if (item?.key !== cacheKey) return item;\n    updated = true;\n    return {\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    };\n  });\n\n  if (!updated) {\n    next.push({\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    });\n  }\n\n  const pruned = pruneCacheIndex(next, clearedAt);\n  for (const key of pruned.removedKeys) await removeCacheEntry(key);\n  await saveCacheIndex(pruned.list);\n}\n\nexport async function clearPersistentCache() {\n  const clearedAt = nowMs();\n  _cacheClearMs = clearedAt;\n  await rawSet(STORAGE_KEYS.CACHE_CLEAR_AT, String(clearedAt));\n  const index = await loadCacheIndex();\n  for (const item of index || []) {\n    if (!item?.key) continue;\n    await removeCacheEntry(item.key);\n  }\n  await rawRemove(STORAGE_KEYS.CACHE_INDEX);\n}\n\nexport async function getPersistentCacheStats() {\n  if (await getPrivacyMode()) {\n    return {\n      entries: 0,\n      sizeBytes: 0,\n      providers: {\n        gemini: { entries: 0, sizeBytes: 0 },\n        openai: { entries: 0, sizeBytes: 0 }\n      },\n      oldestMs: null,\n      newestMs: null\n    };\n  }\n  const index = await loadCacheIndex();\n  const clearedAt = await syncCacheClearMarker();\n  const pruned = pruneCacheIndex(index, clearedAt);\n  if (pruned.removedKeys.length) {\n    for (const key of pruned.removedKeys) await removeCacheEntry(key);\n    await saveCacheIndex(pruned.list);\n  }\n\n  const stats = {\n    entries: 0,\n    sizeBytes: 0,\n    providers: {\n      gemini: { entries: 0, sizeBytes: 0 },\n      openai: { entries: 0, sizeBytes: 0 }\n    },\n    oldestMs: null,\n    newestMs: null\n  };\n\n  for (const item of pruned.list || []) {\n    if (!item?.key) continue;\n    stats.entries += 1;\n    stats.sizeBytes += Number(item.size || 0);\n    const provider = String(item.provider || \"\").toLowerCase();\n    if (provider === PROVIDERS.GEMINI) {\n      stats.providers.gemini.entries += 1;\n      stats.providers.gemini.sizeBytes += Number(item.size || 0);\n    } else if (provider === PROVIDERS.OPENAI) {\n      stats.providers.openai.entries += 1;\n      stats.providers.openai.sizeBytes += Number(item.size || 0);\n    }\n\n    const savedAt = Number(item.savedAtMs || 0);\n    if (savedAt) {\n      stats.oldestMs = stats.oldestMs == null ? savedAt : Math.min(stats.oldestMs, savedAt);\n      stats.newestMs = stats.newestMs == null ? savedAt : Math.max(stats.newestMs, savedAt);\n    }\n  }\n\n  return stats;\n}\n\n// ---------- Stable stringify + hashing (for cache keys) ----------\nfunction isPlainObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\n\nexport function stableStringify(value) {\n  return JSON.stringify(sortKeysDeep(value));\n}\n\nfunction sortKeysDeep(value) {\n  if (Array.isArray(value)) return value.map(sortKeysDeep);\n  if (isPlainObject(value)) {\n    const out = {};\n    for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);\n    return out;\n  }\n  return value;\n}\n\nfunction fnv1a32(str) {\n  let h = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  // Unsigned\n  return (h >>> 0).toString(16).padStart(8, \"0\");\n}\n\nexport async function hashKey(input) {\n  const text = typeof input === \"string\" ? input : stableStringify(input);\n\n  // Prefer SHA-256 when available (browser/Office runtime)\n  try {\n    if (typeof crypto !== \"undefined\" && crypto?.subtle?.digest && typeof TextEncoder !== \"undefined\") {\n      const enc = new TextEncoder();\n      const bytes = enc.encode(text);\n      const digest = await crypto.subtle.digest(\"SHA-256\", bytes);\n      const arr = Array.from(new Uint8Array(digest));\n      return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n  } catch {\n    // ignore and fallback\n  }\n\n  return `fnv1a:${fnv1a32(text)}`;\n}\n\n// ---------- Lightweight diagnostics log (persisted) ----------\nconst REQUEST_LOG_MAX_PER_TYPE = 50;\nconst REQUEST_LOG_MAX_TOTAL = REQUEST_LOG_MAX_PER_TYPE * 2;\nconst REQUEST_LOG_TTL_MS = Infinity; // Kept until manual reset (capped by count)\nlet _requestLog = [];\nlet _requestLogLoading = null;\nlet _requestLogLoaded = false;\nlet _requestLogLastLoadedMs = 0;\nlet _requestLogClearMs = 0;\nconst USAGE_TOTALS_CACHE_TTL_MS = 1500;\nlet _usageTotals = createEmptyUsageTotals();\nlet _usageTotalsLoading = null;\nlet _usageTotalsLoaded = false;\nlet _usageTotalsLastLoadedMs = 0;\n\nasync function syncRequestLogClearMarker(options = {}) {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT));\n  if (clearedAt > _requestLogClearMs) {\n    _requestLogClearMs = clearedAt;\n    _requestLog = [];\n    if (options.reset) {\n      _requestLogLoaded = true;\n      _requestLogLoading = null;\n      _requestLogLastLoadedMs = nowMs();\n    } else {\n      _requestLogLoaded = false;\n    }\n  }\n  return _requestLogClearMs;\n}\n\nfunction coerceRequestLogArray(value) {\n  if (Array.isArray(value)) return value;\n  if (value && typeof value === \"object\") {\n    const normal = Array.isArray(value.normal) ? value.normal : [];\n    const errors = Array.isArray(value.errors) ? value.errors : [];\n    return normal.concat(errors);\n  }\n  return [];\n}\n\nfunction isErrorLogEntry(entry) {\n  return !!entry && entry.ok === false;\n}\n\nasync function loadRequestLog(force = false) {\n  if (_requestLogLoading) return _requestLogLoading;\n\n  _requestLogLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_requestLogLoaded) {\n        _requestLogLoaded = true;\n        _requestLogLastLoadedMs = nowMs();\n      }\n      return _requestLog;\n    }\n    const clearedAt = await syncRequestLogClearMarker();\n    if (!force && _requestLogLoaded) return _requestLog;\n    const raw = await rawGet(STORAGE_KEYS.REQUEST_LOG);\n    let arr = [];\n    if (raw) {\n      try {\n        const parsed = JSON.parse(raw);\n        arr = coerceRequestLogArray(parsed);\n      } catch {\n        arr = [];\n      }\n    }\n    const now = nowMs();\n    arr = arr\n      .map((e) => {\n        if (!e) return null;\n        let ts = e.ts;\n        if (typeof ts === \"string\") {\n          const parsed = Date.parse(ts);\n          if (Number.isFinite(parsed)) ts = parsed;\n        }\n        if (typeof ts !== \"number\") return null;\n        return { ...e, ts };\n      })\n      .filter((e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS)\n      .map((e) => sanitizeLogEntry(e));\n    _requestLog = arr;\n    pruneRequestLog();\n    _requestLogLoaded = true;\n    _requestLogLastLoadedMs = nowMs();\n    return _requestLog;\n  })();\n\n  try {\n    return await _requestLogLoading;\n  } finally {\n    _requestLogLoading = null;\n  }\n}\n\nasync function persistRequestLog() {\n  try {\n    if (await getPrivacyMode()) return;\n    pruneRequestLog();\n    await rawSet(STORAGE_KEYS.REQUEST_LOG, JSON.stringify(_requestLog.slice(-REQUEST_LOG_MAX_TOTAL)));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneRequestLog() {\n  const now = nowMs();\n  const clearedAt = _requestLogClearMs || 0;\n  const valid = (_requestLog || []).filter(\n    (e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS\n  );\n  const normals = [];\n  const errors = [];\n  for (const entry of valid) {\n    if (isErrorLogEntry(entry)) errors.push(entry);\n    else normals.push(entry);\n  }\n  normals.sort((a, b) => a.ts - b.ts);\n  errors.sort((a, b) => a.ts - b.ts);\n  const pruned = normals.slice(-REQUEST_LOG_MAX_PER_TYPE).concat(errors.slice(-REQUEST_LOG_MAX_PER_TYPE));\n  pruned.sort((a, b) => a.ts - b.ts);\n  _requestLog = pruned;\n}\n\n// ---------- Persistent usage totals ----------\nfunction toNonNegInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nfunction createEmptyUsageTotals() {\n  return {\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    requests: 0,\n    byProvider: {\n      [PROVIDERS.GEMINI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        requests: 0,\n        models: {}\n      },\n      [PROVIDERS.OPENAI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        requests: 0,\n        models: {}\n      }\n    }\n  };\n}\n\nfunction normalizeUsageTotals(raw) {\n  const base = createEmptyUsageTotals();\n  if (!raw || typeof raw !== \"object\") return base;\n\n  base.inputTokens = toNonNegInt(raw.inputTokens);\n  base.outputTokens = toNonNegInt(raw.outputTokens);\n  base.reasoningTokens = toNonNegInt(raw.reasoningTokens);\n  base.cachedInputTokens = toNonNegInt(raw.cachedInputTokens);\n  base.requests = toNonNegInt(raw.requests);\n\n  const providers = raw.byProvider && typeof raw.byProvider === \"object\" ? raw.byProvider : {};\n  for (const provider of [PROVIDERS.GEMINI, PROVIDERS.OPENAI]) {\n    const rawProvider = providers[provider];\n    if (!rawProvider || typeof rawProvider !== \"object\") continue;\n    const target = base.byProvider[provider];\n    target.inputTokens = toNonNegInt(rawProvider.inputTokens);\n    target.outputTokens = toNonNegInt(rawProvider.outputTokens);\n    target.reasoningTokens = toNonNegInt(rawProvider.reasoningTokens);\n    target.cachedInputTokens = toNonNegInt(rawProvider.cachedInputTokens);\n    target.requests = toNonNegInt(rawProvider.requests);\n\n    const rawModels = rawProvider.models && typeof rawProvider.models === \"object\" ? rawProvider.models : {};\n    for (const [key, value] of Object.entries(rawModels)) {\n      if (!value || typeof value !== \"object\") continue;\n      const label = typeof value.label === \"string\" ? value.label : String(key || \"\");\n      const modelKey = String(key || label || \"\").toLowerCase();\n      if (!modelKey) continue;\n      target.models[modelKey] = {\n        label,\n        inputTokens: toNonNegInt(value.inputTokens),\n        outputTokens: toNonNegInt(value.outputTokens),\n        reasoningTokens: toNonNegInt(value.reasoningTokens),\n        cachedInputTokens: toNonNegInt(value.cachedInputTokens),\n        requests: toNonNegInt(value.requests)\n      };\n    }\n  }\n\n  return base;\n}\n\nfunction cloneUsageTotals(value) {\n  try {\n    return JSON.parse(JSON.stringify(value || createEmptyUsageTotals()));\n  } catch {\n    return createEmptyUsageTotals();\n  }\n}\n\nasync function loadUsageTotals(force = false) {\n  if (_usageTotalsLoading) return _usageTotalsLoading;\n\n  _usageTotalsLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_usageTotalsLoaded) {\n        _usageTotalsLoaded = true;\n        _usageTotalsLastLoadedMs = nowMs();\n      }\n      return _usageTotals;\n    }\n\n    if (!force && _usageTotalsLoaded) return _usageTotals;\n\n    const raw = await rawGet(STORAGE_KEYS.USAGE_TOTALS);\n    let parsed = null;\n    if (raw) {\n      try {\n        parsed = JSON.parse(raw);\n      } catch {\n        parsed = null;\n      }\n    }\n\n    _usageTotals = normalizeUsageTotals(parsed);\n    _usageTotalsLoaded = true;\n    _usageTotalsLastLoadedMs = nowMs();\n    return _usageTotals;\n  })();\n\n  try {\n    return await _usageTotalsLoading;\n  } finally {\n    _usageTotalsLoading = null;\n  }\n}\n\nasync function persistUsageTotals() {\n  try {\n    if (await getPrivacyMode()) return;\n    await rawSet(STORAGE_KEYS.USAGE_TOTALS, JSON.stringify(_usageTotals));\n  } catch {\n    // ignore\n  }\n}\n\nasync function updateUsageTotals(entry) {\n  try {\n    if (!entry || typeof entry !== \"object\") return;\n\n    const inputTokens = toNonNegInt(entry.inputTokens);\n    const outputTokens = toNonNegInt(entry.outputTokens);\n    const reasoningTokens = toNonNegInt(entry.reasoningTokens);\n    const cachedInputTokens = toNonNegInt(entry.cachedInputTokens);\n    const hasUsage = inputTokens + outputTokens + reasoningTokens + cachedInputTokens > 0;\n    if (!hasUsage) return;\n\n    const provider = String(entry.provider || \"\").toLowerCase();\n    if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) return;\n\n    const modelLabel = String(entry.model || \"\").trim();\n    const modelKey = (modelLabel || \"unknown\").toLowerCase();\n\n    await loadUsageTotals();\n\n    _usageTotals.inputTokens += inputTokens;\n    _usageTotals.outputTokens += outputTokens;\n    _usageTotals.reasoningTokens += reasoningTokens;\n    _usageTotals.cachedInputTokens += cachedInputTokens;\n    _usageTotals.requests += 1;\n\n    const providerTotals = _usageTotals.byProvider[provider];\n    providerTotals.inputTokens += inputTokens;\n    providerTotals.outputTokens += outputTokens;\n    providerTotals.reasoningTokens += reasoningTokens;\n    providerTotals.cachedInputTokens += cachedInputTokens;\n    providerTotals.requests += 1;\n\n    const models = providerTotals.models || {};\n    const existing = models[modelKey] || {\n      label: modelLabel,\n      inputTokens: 0,\n      outputTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0,\n      requests: 0\n    };\n    if (!existing.label && modelLabel) existing.label = modelLabel;\n    existing.inputTokens += inputTokens;\n    existing.outputTokens += outputTokens;\n    existing.reasoningTokens += reasoningTokens;\n    existing.cachedInputTokens += cachedInputTokens;\n    existing.requests += 1;\n    models[modelKey] = existing;\n    providerTotals.models = models;\n\n    _usageTotalsLastLoadedMs = nowMs();\n    await persistUsageTotals();\n  } catch {\n    // ignore\n  }\n}\n\nexport async function getUsageTotals(options = {}) {\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_usageTotalsLoaded || now - _usageTotalsLastLoadedMs > USAGE_TOTALS_CACHE_TTL_MS) {\n    await loadUsageTotals(true);\n  } else {\n    await loadUsageTotals(false);\n  }\n  return cloneUsageTotals(_usageTotals);\n}\n\nexport async function clearUsageTotals() {\n  _usageTotals = createEmptyUsageTotals();\n  _usageTotalsLoaded = true;\n  _usageTotalsLoading = null;\n  _usageTotalsLastLoadedMs = nowMs();\n  await rawRemove(STORAGE_KEYS.USAGE_TOTALS);\n}\n\nexport function logRequest(entry) {\n  void logRequestAsync(entry);\n}\n\nfunction sanitizeLogEntry(entry) {\n  if (!entry || typeof entry !== \"object\") return entry;\n  return redactSensitiveValue(entry);\n}\n\nasync function logRequestAsync(entry) {\n  try {\n    const logEntry = sanitizeLogEntry({ ts: nowMs(), ...entry });\n    await updateUsageTotals(logEntry);\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      _requestLog.push(logEntry);\n      pruneRequestLog();\n      _requestLogLoaded = true;\n      _requestLogLastLoadedMs = nowMs();\n      return;\n    }\n\n    await syncRequestLogClearMarker({ reset: true });\n\n    if (_requestLogLoaded) {\n      _requestLog.push(logEntry);\n      pruneRequestLog();\n      _requestLogLastLoadedMs = nowMs();\n      await persistRequestLog();\n      return;\n    }\n\n    await loadRequestLog();\n    _requestLog.push(logEntry);\n    pruneRequestLog();\n    _requestLogLastLoadedMs = nowMs();\n    await persistRequestLog();\n  } catch {\n    // ignore\n  }\n}\n\nexport async function getRequestLog(options = {}) {\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_requestLogLoaded || now - _requestLogLastLoadedMs > 1500) {\n    await loadRequestLog(true);\n  } else {\n    await loadRequestLog(false);\n  }\n  return _requestLog.slice();\n}\n\nexport async function clearRequestLog() {\n  const clearedAt = nowMs();\n  _requestLog = [];\n  _requestLogLoaded = true;\n  _requestLogLoading = null;\n  _requestLogClearMs = clearedAt;\n  _requestLogLastLoadedMs = clearedAt;\n  await rawSet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT, String(clearedAt));\n  await rawRemove(STORAGE_KEYS.REQUEST_LOG);\n}\n","// src/shared/providers.js\n// Provider implementations (Gemini + OpenAI) and shared request orchestration.\n//\n// Requirements implemented:\n// - Gemini 3 Flash (via Google Generative Language API)\n// - OpenAI GPT-5 Mini (via OpenAI Responses API)\n// - No temperature / sampling parameters are ever sent\n// - Provider selection happens via taskpane default provider (formulas cannot override)\n// - AI.WEB uses provider-native web search mechanisms:\n//   - Gemini: google_search tool\n//   - OpenAI: web_search tool\n\nimport {\n  PROVIDERS,\n  DEFAULTS,\n  normalizeProvider,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getGeminiReasoningEffort,\n  getOpenAIReasoningEffort,\n  getMaxOutputTokens,\n  getConcurrencyLimit,\n  clampInt,\n  nowMs,\n  sleep,\n  LRUCache,\n  hashKey,\n  logRequest,\n  setRuntimeStatus,\n  getCacheClearAt,\n  getPersistentCache,\n  setPersistentCache,\n  clearPersistentCache,\n  redactSensitiveText\n} from \"./core.js\";\n\n// ---- In-memory cache (per runtime) ----\nconst CACHE = new LRUCache(800);\nlet _cacheClearLocalMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = await getCacheClearAt();\n  if (clearedAt > _cacheClearLocalMs) {\n    _cacheClearLocalMs = clearedAt;\n    CACHE.clear();\n  }\n}\n\n// Deduplicate in-flight identical requests to avoid bursts (per runtime)\nconst INFLIGHT = new Map(); // key => Promise<AIResult>\n\nconst GEMINI_503_RETRY_DELAY_MS = 10000;\nconst GEMINI_503_MAX_RETRIES = 2;\n\n// Concurrency limiter (per runtime)\nconst QUEUE_CANCELLED = Symbol(\"queue_cancelled\");\nconst QUEUE_CANCELLED_RESULT = { ok: false, code: \"QUEUE_CANCELLED\", message: \"File d'attente arrte.\" };\nconst CONCURRENCY_CACHE_TTL_MS = 1500;\nlet concurrencyLimitCached = DEFAULTS.concurrencyLimit;\nlet concurrencyLimitCachedAt = 0;\n\nlet active = 0;\nconst queue = [];\nlet statusTimer = null;\nlet pendingStatus = null;\nlet lastStatusKey = \"\";\n\nfunction snapshotQueueStatus() {\n  return { active, queued: queue.length };\n}\n\nfunction scheduleRuntimeStatusUpdate() {\n  const snapshot = snapshotQueueStatus();\n  pendingStatus = snapshot;\n  if (statusTimer) return;\n  statusTimer = setTimeout(() => {\n    statusTimer = null;\n    const status = pendingStatus;\n    pendingStatus = null;\n    if (!status) return;\n    const key = `${status.active}:${status.queued}`;\n    if (key === lastStatusKey) return;\n    lastStatusKey = key;\n    void setRuntimeStatus({ ...status, ts: nowMs() });\n  }, 120);\n}\n\nasync function getConcurrencyLimitCached() {\n  const now = nowMs();\n  if (now - concurrencyLimitCachedAt < CONCURRENCY_CACHE_TTL_MS) return concurrencyLimitCached;\n  const value = await getConcurrencyLimit();\n  concurrencyLimitCached = value;\n  concurrencyLimitCachedAt = now;\n  return value;\n}\n\nexport function stopQueuedRequests() {\n  if (!queue.length) return 0;\n  const pending = queue.splice(0, queue.length);\n  for (const resolve of pending) {\n    resolve(QUEUE_CANCELLED);\n  }\n  scheduleRuntimeStatusUpdate();\n  return pending.length;\n}\n\nasync function withConcurrencyLimit(fn) {\n  while (true) {\n    const limit = await getConcurrencyLimitCached();\n    if (active < limit) break;\n    const gate = await new Promise((resolve) => {\n      queue.push(resolve);\n      scheduleRuntimeStatusUpdate();\n    });\n    if (gate === QUEUE_CANCELLED) return { ...QUEUE_CANCELLED_RESULT };\n  }\n  active++;\n  scheduleRuntimeStatusUpdate();\n  try {\n    return await fn();\n  } finally {\n    active--;\n    const next = queue.shift();\n    if (next) next();\n    scheduleRuntimeStatusUpdate();\n  }\n}\n\n// Reset runtime status on load to avoid stale UI.\nvoid setRuntimeStatus({ active: 0, queued: 0, ts: nowMs() });\n\nfunction isNonEmptyString(s) {\n  return typeof s === \"string\" && s.trim().length > 0;\n}\n\nfunction normalizeBoolean(v, def = false) {\n  if (typeof v === \"boolean\") return v;\n  if (typeof v === \"number\") return v !== 0;\n  if (typeof v === \"string\") {\n    const s = v.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(s)) return true;\n    if ([\"0\", \"false\", \"no\", \"n\", \"off\"].includes(s)) return false;\n  }\n  return def;\n}\n\nfunction normalizeTimeoutMs(v) {\n  return clampInt(v, 1000, 120000, DEFAULTS.timeoutMs);\n}\n\nfunction normalizeRetry(v) {\n  return clampInt(v, 0, 5, DEFAULTS.retry);\n}\n\nfunction normalizeMaxOutputTokens(v) {\n  return clampInt(v, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nfunction toLowerMsg(v) {\n  return String(v || \"\").toLowerCase();\n}\n\nfunction looksLikeStructuredOutputUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  return (\n    s.includes(\"responseschema\") ||\n    s.includes(\"response schema\") ||\n    s.includes(\"response_schema\") ||\n    s.includes(\"responsemime\") ||\n    s.includes(\"response mime\") ||\n    s.includes(\"response_mime\") ||\n    s.includes(\"response_mime_type\") ||\n    s.includes(\"json_schema\") ||\n    s.includes(\"response_format\") ||\n    s.includes(\"text.format\")\n  );\n}\n\nfunction looksLikeWebSearchUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  if (!(s.includes(\"web_search\") || s.includes(\"google_search\") || s.includes(\"web search\") || s.includes(\"google search\"))) {\n    return false;\n  }\n  return (\n    s.includes(\"not supported\") ||\n    s.includes(\"unsupported\") ||\n    s.includes(\"unknown\") ||\n    s.includes(\"unrecognized\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"not enabled\") ||\n    s.includes(\"not available\")\n  );\n}\n\nfunction isGeminiServiceUnavailable(provider, result) {\n  if (provider !== PROVIDERS.GEMINI || result?.ok) return false;\n  if (result?.status === 503) return true;\n  if (result?.code !== \"API_ERROR\") return false;\n  const msg = toLowerMsg(result?.message);\n  if (!msg) return false;\n  return msg.includes(\"overloaded\") || msg.includes(\"service unavailable\") || msg.includes(\"unavailable\");\n}\n\nfunction ensureJsonInstruction(system) {\n  const suffix = \" Return valid JSON only.\";\n  if (!isNonEmptyString(system)) return \"Return valid JSON only.\";\n  const s = String(system).trim();\n  if (/json/i.test(s)) return s;\n  return s + suffix;\n}\n\nfunction extractFormulaFromText(text) {\n  if (!isNonEmptyString(text)) return \"\";\n  const raw = String(text).trim();\n  const match = raw.match(/=[^\\n\\r]+/);\n  const formula = (match ? match[0] : raw).trim();\n  if (!formula.startsWith(\"=\")) return \"\";\n  return formula;\n}\n\nfunction getFormulaForLog(fnName, text) {\n  if (fnName !== \"AI.FORMULA\") return \"\";\n  return extractFormulaFromText(text);\n}\n\nfunction resolveGeminiThinkingConfig(model, effort) {\n  const level = String(effort || \"\").trim().toLowerCase();\n  if (!level || level === \"auto\" || level === \"none\") return null;\n\n  const modelId = String(model || \"\").trim().toLowerCase();\n  if (!modelId.includes(\"gemini\")) return null;\n\n  if (modelId.includes(\"gemini-3\")) {\n    if (modelId.includes(\"flash\")) {\n      const allowed = new Set([\"minimal\", \"low\", \"medium\", \"high\"]);\n      const normalized = allowed.has(level) ? level : \"low\";\n      return { thinkingLevel: normalized.toUpperCase() };\n    }\n    const normalized = level === \"high\" || level === \"medium\" ? \"high\" : \"low\";\n    return { thinkingLevel: normalized.toUpperCase() };\n  }\n\n  if (modelId.includes(\"gemini-2.5\")) {\n    const budgets = {\n      minimal: 512,\n      low: 2048,\n      medium: 8192,\n      high: 24576\n    };\n    let budget = budgets[level];\n    if (!budget) return null;\n    if (modelId.includes(\"flash-lite\")) budget = Math.max(512, budget);\n    if (modelId.includes(\"pro\")) budget = Math.max(128, budget);\n    return { thinkingBudget: budget };\n  }\n\n  return null;\n}\n\n// ---- Public API ----\n\n/**\n * @typedef {Object} AIGenerateRequest\n * @property {string=} provider Optional override (should only be used by taskpane tests, not formulas).\n * @property {string=} system System instruction.\n * @property {string} user User prompt.\n * @property {boolean=} webSearch Enable provider web search tool.\n * @property {number=} maxOutputTokens Override max tokens (optional; normally from panel).\n * @property {number=} timeoutMs\n * @property {number=} retry\n * @property {boolean=} cache\n * @property {number=} cacheTtlSec\n * @property {string=} responseMimeType e.g., \"application/json\"\n * @property {Object=} responseJsonSchema JSON schema (strict) for structured output.\n * @property {string=} functionName Name for diagnostics.\n * @property {string=} functionCall Excel-style function call for diagnostics.\n */\n\n/**\n * @typedef {Object} AIResult\n * @property {boolean} ok\n * @property {string=} text\n * @property {Array<{title?: string, url: string}>=} sources\n * @property {string=} provider\n * @property {string=} model\n * @property {Object=} usage\n * @property {number=} status\n * @property {string=} code\n * @property {string=} message\n */\n\nexport async function aiGenerate(req) {\n  const start = nowMs();\n  const provider = normalizeProvider(req?.provider) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n  const fnName = req?.functionName || \"aiGenerate\";\n  const functionCall = isNonEmptyString(req?.functionCall) ? String(req.functionCall) : \"\";\n  const reasoningEffort = provider === PROVIDERS.OPENAI ? await getOpenAIReasoningEffort() : \"\";\n  const geminiReasoningEffort = provider === PROVIDERS.GEMINI ? await getGeminiReasoningEffort() : \"\";\n  const reasoningEffortLabel = provider === PROVIDERS.OPENAI ? reasoningEffort : geminiReasoningEffort;\n\n  if (!apiKey) {\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      reasoningEffort: reasoningEffortLabel || undefined,\n      call: functionCall || undefined,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    });\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  const user = String(req?.user || \"\");\n  const system = isNonEmptyString(req?.system) ? String(req.system) : \"\";\n\n  const webSearch = normalizeBoolean(req?.webSearch, false);\n  const timeoutMs = normalizeTimeoutMs(req?.timeoutMs);\n  const retry = normalizeRetry(req?.retry);\n  const gemini503RetryMax = Math.min(retry, GEMINI_503_MAX_RETRIES);\n\n  const cfgMax = await getMaxOutputTokens();\n  const maxOutputTokens = normalizeMaxOutputTokens(req?.maxOutputTokens ?? cfgMax);\n  const thinkingConfig = provider === PROVIDERS.GEMINI ? resolveGeminiThinkingConfig(model, geminiReasoningEffort) : null;\n\n  const cacheEnabled = normalizeBoolean(req?.cache, DEFAULTS.cache);\n  const ttlSec = clampInt(\n    req?.cacheTtlSec ?? (webSearch ? DEFAULTS.webCacheTtlSec : DEFAULTS.cacheTtlSec),\n    1,\n    365 * 24 * 3600,\n    webSearch ? DEFAULTS.webCacheTtlSec : DEFAULTS.cacheTtlSec\n  );\n\n  await syncCacheClearMarker();\n\n  // Cache key (no temperature anywhere)\n  const cacheKeyPayload = {\n    v: 3,\n    provider,\n    model,\n    maxOutputTokens,\n    reasoningEffort,\n    geminiReasoningEffort,\n    webSearch,\n    system,\n    user,\n    responseMimeType: req?.responseMimeType || \"\",\n    responseJsonSchema: req?.responseJsonSchema || null\n  };\n\n  const cacheKey = await hashKey(cacheKeyPayload);\n\n  if (cacheEnabled) {\n    const cached = CACHE.get(cacheKey);\n    if (cached) {\n      const formula = getFormulaForLog(fnName, cached?.text);\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: true,\n        ms: nowMs() - start,\n        cache: true,\n        cacheKind: \"memory\",\n        reasoningEffort: reasoningEffortLabel || undefined,\n        call: functionCall || undefined,\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        totalTokens: 0,\n        formula: formula || undefined\n      });\n      return { ...cached, cached: true, cacheKind: \"memory\" };\n    }\n    const persisted = await getPersistentCache(cacheKey);\n    if (persisted) {\n      const formula = getFormulaForLog(fnName, persisted?.text);\n      CACHE.set(cacheKey, persisted, ttlSec * 1000);\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: true,\n        ms: nowMs() - start,\n        cache: true,\n        cacheKind: \"persistent\",\n        reasoningEffort: reasoningEffortLabel || undefined,\n        call: functionCall || undefined,\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        totalTokens: 0,\n        formula: formula || undefined\n      });\n      return { ...persisted, cached: true, cacheKind: \"persistent\" };\n    }\n  }\n\n  if (INFLIGHT.has(cacheKey)) return INFLIGHT.get(cacheKey);\n\n  const p = withConcurrencyLimit(async () => {\n    let attempt = 0;\n    let lastErr = null;\n\n    const callProvider = async (opts) =>\n      provider === PROVIDERS.OPENAI ? callOpenAI(opts) : callGemini(opts);\n\n    while (attempt <= retry) {\n      attempt++;\n      try {\n        const baseOpts = {\n          apiKey,\n          model,\n          system,\n          user,\n          maxOutputTokens,\n          reasoningEffort,\n          thinkingConfig,\n          timeoutMs,\n          webSearch,\n          responseMimeType: req?.responseMimeType,\n          responseJsonSchema: req?.responseJsonSchema\n        };\n\n        let result = await callProvider(baseOpts);\n\n        if (!result.ok && !isGeminiServiceUnavailable(provider, result)) {\n          let opts = baseOpts;\n\n          // Fallback #1: if web search fails, retry without tools.\n          if (opts.webSearch) {\n            const shouldRetryNoWeb =\n              looksLikeWebSearchUnsupported(result.message) || result.code === \"API_ERROR\" || result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryNoWeb) {\n              opts = { ...opts, webSearch: false };\n              result = await callProvider(opts);\n            }\n          }\n\n          // Fallback #2: if structured output fails, retry without schema/responseMimeType.\n          const wantsStructured = opts.responseMimeType || opts.responseJsonSchema;\n          if (!result.ok && wantsStructured) {\n            const shouldRetryPlainJson =\n              looksLikeStructuredOutputUnsupported(result.message) ||\n              result.code === \"API_ERROR\" ||\n              result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryPlainJson) {\n              opts = {\n                ...opts,\n                responseMimeType: undefined,\n                responseJsonSchema: undefined,\n                system: ensureJsonInstruction(opts.system)\n              };\n              result = await callProvider(opts);\n            }\n          }\n        }\n\n        const shouldRetryServiceUnavailable =\n          isGeminiServiceUnavailable(provider, result) && attempt <= gemini503RetryMax;\n\n        // Log (best-effort)\n        const usage = normalizeUsage(result?.usage);\n        const formula = result.ok ? getFormulaForLog(fnName, result.text) : \"\";\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: result.ok,\n          ms: nowMs() - start,\n          attempt,\n          cache: false,\n          reasoningEffort: reasoningEffortLabel || undefined,\n          call: functionCall || undefined,\n          inputTokens: usage.inputTokens,\n          outputTokens: usage.outputTokens,\n          reasoningTokens: usage.reasoningTokens,\n          cachedInputTokens: usage.cachedInputTokens,\n          totalTokens: usage.totalTokens,\n          code: result.code,\n          message: result.message,\n          formula: formula || undefined\n        });\n\n        if (shouldRetryServiceUnavailable) {\n          await sleep(GEMINI_503_RETRY_DELAY_MS);\n          continue;\n        }\n\n        if (result.ok && cacheEnabled) {\n          CACHE.set(cacheKey, result, ttlSec * 1000);\n          await setPersistentCache(cacheKey, result, ttlSec * 1000, { provider, model });\n        }\n\n        return result;\n      } catch (e) {\n        lastErr = e;\n        if (attempt <= retry) await sleep(250 * attempt);\n      }\n    }\n\n    const msg = redactSensitiveText(lastErr?.message ? String(lastErr.message) : \"Erreur inconnue.\");\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      reasoningEffort: reasoningEffortLabel || undefined,\n      call: functionCall || undefined,\n      code: \"API_ERROR\",\n      message: msg\n    });\n    return { ok: false, provider, model, code: \"API_ERROR\", message: msg };\n  });\n\n  INFLIGHT.set(cacheKey, p);\n\n  try {\n    const result = await p;\n    if (result?.code === \"QUEUE_CANCELLED\") {\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: false,\n        ms: nowMs() - start,\n        cache: false,\n        reasoningEffort: reasoningEffortLabel || undefined,\n        call: functionCall || undefined,\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        totalTokens: 0,\n        code: result.code,\n        message: result.message\n      });\n    }\n    return result;\n  } finally {\n    INFLIGHT.delete(cacheKey);\n  }\n}\n\n/**\n * Lightweight connectivity test for a provider (used from taskpane and AI.TEST()).\n */\nexport async function aiMinimalTest(providerOverride) {\n  const provider = normalizeProvider(providerOverride) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n\n  if (!apiKey) {\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  // Tiny request\n  return await aiGenerate({\n    provider,\n    system: \"You are a test endpoint. Reply with exactly: OK\",\n    user: \"OK\",\n    maxOutputTokens: 500,\n    cache: false,\n    webSearch: false,\n    functionName: \"AI.MINIMAL_TEST\"\n  });\n}\n\n// ---- Provider: Gemini (Google Generative Language API) ----\n\nfunction geminiEndpoint(model) {\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent`;\n}\n\nasync function callGemini({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  thinkingConfig,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = geminiEndpoint(model);\n\n  const body = {\n    contents: [{ role: \"user\", parts: [{ text: user }] }],\n    generationConfig: {\n      maxOutputTokens\n    }\n  };\n\n  if (thinkingConfig && typeof thinkingConfig === \"object\") {\n    body.generationConfig.thinkingConfig = thinkingConfig;\n  }\n\n  if (isNonEmptyString(system)) {\n    // API uses lowerCamelCase for this field in JSON representation\n    // Force explicit JSON instruction for robustness\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.systemInstruction = { role: \"system\", parts: [{ text: sysText }] };\n  }\n\n  // Structured output (JSON) when requested\n  if (responseMimeType) {\n    body.generationConfig.responseMimeType = responseMimeType;\n  }\n  if (responseJsonSchema) {\n    body.generationConfig.responseSchema = responseJsonSchema;\n  }\n\n  // Web grounding tool\n  if (webSearch) {\n    // For REST v1beta, the tool name is usually google_search (snake_case).\n    // Note: Some newer endpoints might respect googleSearch, but snake_case is safer for REST.\n    body.tools = [{ google_search: {} }];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-goog-api-key\": apiKey\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n  const errInfo = extractGeminiErrorInfo(json);\n\n  if (errInfo?.message) {\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: errInfo.status ?? res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(errInfo.message)\n    };\n  }\n\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(msg)\n    };\n  }\n\n  const text = extractGeminiText(json);\n  const sources = extractGeminiSources(json);\n  const usage = extractGeminiUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return { ok: false, provider: PROVIDERS.GEMINI, model, code: \"EMPTY_RESPONSE\", message: \"Rponse vide de Gemini.\" };\n  }\n\n  return { ok: true, provider: PROVIDERS.GEMINI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractGeminiText(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const parts = c?.content?.parts;\n    if (Array.isArray(parts)) {\n      return parts.map((p) => p?.text || \"\").join(\"\");\n    }\n    return \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiErrorInfo(json) {\n  try {\n    const err = json?.error;\n    if (!err) return null;\n    const msg = err?.message;\n    const statusCode = Number(err?.code);\n    return {\n      message: msg ? String(msg) : \"\",\n      status: Number.isFinite(statusCode) ? statusCode : undefined\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractGeminiSources(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const md = c?.groundingMetadata;\n    const chunks = md?.groundingChunks;\n    if (!Array.isArray(chunks)) return [];\n\n    const out = [];\n    for (const ch of chunks) {\n      const web = ch?.web;\n      if (!web?.uri) continue;\n      out.push({ title: web?.title || \"\", url: web.uri });\n    }\n\n    return dedupeSources(out);\n  } catch {\n    return [];\n  }\n}\n\n// ---- Provider: OpenAI (Responses API) ----\n\nasync function callOpenAI({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  reasoningEffort,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = \"https://api.openai.com/v1/responses\";\n\n  const body = {\n    model,\n    input: user, // Responses API uses 'input' (string or array of objects)\n    max_output_tokens: maxOutputTokens,\n    store: false\n  };\n\n  if (isNonEmptyString(reasoningEffort)) {\n    body.reasoning = { effort: reasoningEffort };\n  }\n\n  // System prompt\n  if (isNonEmptyString(system)) {\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.instructions = sysText;\n  }\n\n  // Structured output (JSON)\n  // - If a JSON schema is provided: use json_schema strict mode.\n  // - Else if responseMimeType is JSON: request a json_object.\n  if (responseJsonSchema) {\n    // For GPT-5 Mini / v1/responses, we try to use the most standard way if possible.\n    // If body.text format fails, we rely on the prompt.\n    // We kept the previous implementation but added prompt reinforcement.\n    body.text = {\n      format: {\n        type: \"json_schema\",\n        name: \"excel_ai_schema\",\n        strict: true,\n        schema: responseJsonSchema\n      }\n    };\n  } else if (responseMimeType === \"application/json\") {\n    body.text = { format: { type: \"json_object\" } };\n  }\n\n  // Web search tool\n  if (webSearch) {\n    body.tools = [{ type: \"web_search\" }];\n    body.include = [\"web_search_call.action.sources\"];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n\n  if (!res.ok) {\n    const msg = extractOpenAIError(json) || `OpenAI API error (${res.status}).`;\n    return { ok: false, provider: PROVIDERS.OPENAI, model, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n  }\n\n  const text = extractOpenAIText(json);\n  const sources = webSearch ? extractOpenAISources(json) : [];\n  const usage = extractOpenAIUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.OPENAI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide d'OpenAI.\"\n    };\n  }\n\n  return { ok: true, provider: PROVIDERS.OPENAI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractOpenAIText(json) {\n  // 1. Try direct output_text (common in simple Responses)\n  try {\n    if (typeof json?.output_text === \"string\" && json.output_text.trim()) {\n      return json.output_text;\n    }\n  } catch {\n    // ignore\n  }\n\n  // 2. Try iterating over 'output' items (complex/agentic responses)\n  try {\n    const out = json?.output;\n    if (Array.isArray(out)) {\n      const texts = [];\n      for (const item of out) {\n        if (typeof item?.text === \"string\" && item.text.trim()) texts.push(item.text);\n        if (typeof item?.output_text === \"string\" && item.output_text.trim()) texts.push(item.output_text);\n        if (item?.type === \"output_text\" && typeof item?.text === \"string\") texts.push(item.text);\n        if (item?.type === \"text\" && typeof item?.text === \"string\") texts.push(item.text);\n\n        // Standard message output\n        if (item?.type === \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n\n        if (item?.type !== \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n      }\n      if (texts.length > 0) return texts.join(\"\\n\").trim();\n    }\n  } catch {\n    // ignore\n  }\n\n  // 3. Fallback: Chat Completions style (just in case model acts differently)\n  try {\n    return json?.choices?.[0]?.message?.content || \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAIError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAISources(json) {\n  try {\n    const out = json?.output;\n    if (!Array.isArray(out)) return [];\n\n    const sources = [];\n    for (const item of out) {\n      if (item?.type !== \"web_search_call\") continue;\n      const s = item?.action?.sources;\n      if (!Array.isArray(s)) continue;\n      for (const src of s) {\n        if (!src?.url) continue;\n        sources.push({ title: src?.title || \"\", url: src.url });\n      }\n    }\n\n    return dedupeSources(sources);\n  } catch {\n    return [];\n  }\n}\n\nfunction extractGeminiUsage(json) {\n  try {\n    const u = json?.usageMetadata;\n    if (!u) return null;\n    return {\n      inputTokens: toInt(u?.promptTokenCount),\n      outputTokens: toInt(u?.candidatesTokenCount),\n      reasoningTokens: toInt(u?.thoughtsTokenCount),\n      totalTokens: toInt(u?.totalTokenCount),\n      cachedInputTokens: toInt(u?.cachedContentTokenCount)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractOpenAIUsage(json) {\n  try {\n    const u = json?.usage;\n    if (!u) return null;\n    const rawOutputTokens = toInt(u?.output_tokens);\n    const reasoningTokens = toInt(u?.output_tokens_details?.reasoning_tokens);\n    const outputTokens = Math.max(0, rawOutputTokens - reasoningTokens);\n    return {\n      inputTokens: toInt(u?.input_tokens),\n      outputTokens,\n      reasoningTokens,\n      totalTokens: toInt(u?.total_tokens),\n      cachedInputTokens: toInt(u?.input_tokens_details?.cached_tokens)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction normalizeUsage(usage) {\n  if (!usage || typeof usage !== \"object\") {\n    return { inputTokens: 0, outputTokens: 0, reasoningTokens: 0, totalTokens: 0, cachedInputTokens: 0 };\n  }\n  const inputTokens = toInt(usage.inputTokens);\n  const outputTokens = toInt(usage.outputTokens);\n  const reasoningTokens = toInt(usage.reasoningTokens);\n  const cachedInputTokens = toInt(usage.cachedInputTokens);\n  const reportedTotal = toInt(usage.totalTokens);\n  const computedTotal = inputTokens + outputTokens + reasoningTokens;\n  const totalTokens = Math.max(reportedTotal, computedTotal);\n  return {\n    inputTokens,\n    outputTokens,\n    reasoningTokens,\n    totalTokens,\n    cachedInputTokens\n  };\n}\n\nfunction toInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nexport async function clearAllCaches() {\n  CACHE.clear();\n  await clearPersistentCache();\n}\n\nfunction dedupeSources(list) {\n  const seen = new Set();\n  const out = [];\n  for (const s of list || []) {\n    const url = String(s?.url || \"\").trim();\n    if (!url) continue;\n    const key = url.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push({ title: String(s?.title || \"\").trim(), url });\n  }\n  return out;\n}\n\n// ---- Helpers: fetch + timeout + JSON parsing ----\n\nasync function fetchWithTimeout(url, options, timeoutMs) {\n  const t = normalizeTimeoutMs(timeoutMs);\n\n  if (typeof AbortController === \"undefined\") {\n    // Basic fetch without cancellation (should be rare in modern Office runtimes)\n    return await fetch(url, options);\n  }\n\n  const ctrl = new AbortController();\n  const id = setTimeout(() => ctrl.abort(), t);\n\n  try {\n    return await fetch(url, { ...options, signal: ctrl.signal });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nasync function safeJson(res) {\n  try {\n    return await res.json();\n  } catch {\n    return {};\n  }\n}\n","// src/functions/functions.js\n// Custom Functions implementation.\n//\n// IMPORTANT: Formulas must NOT accept provider or sampling options.\n// - Provider is selected in the taskpane (default provider).\n// - No temperature/top-p are used anywhere.\n//\n// This file is bundled by webpack into dist/functions.js and loaded in the shared runtime.\n\nimport { aiGenerate, aiMinimalTest } from \"../shared/providers.js\";\nimport {\n  PROVIDERS,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getMaxOutputTokens,\n  storageBackendName,\n} from \"../shared/core.js\";\n\n// Excel cell text limit is 32,767 characters. Keep a safety margin.\nconst EXCEL_CELL_CHAR_LIMIT = 32000;\n\n// Defensive caps to avoid runaway prompts in spreadsheets.\nconst MAX_CONTEXT_CHARS = 9000;\nconst FORMULA_ARG_MAX = 120;\nconst MAX_LIST_ITEMS = 200;\nconst MAX_BATCH_CELLS = Number.POSITIVE_INFINITY; // for batch operations (CLASSIFY/TRANSLATE/etc.)\nconst DEFAULT_LANG = \"fr\";\n\nfunction getExcelLocale() {\n  try {\n    if (typeof Office !== \"undefined\" && Office?.context) {\n      const lang = Office.context.displayLanguage || Office.context.contentLanguage;\n      if (lang) return String(lang);\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    if (typeof navigator !== \"undefined\" && navigator?.language) {\n      return String(navigator.language);\n    }\n  } catch {\n    // ignore\n  }\n\n  return DEFAULT_LANG;\n}\n\nfunction isFrenchLocale(locale) {\n  return String(locale || \"\").toLowerCase().startsWith(\"fr\");\n}\n\nfunction isMatrix(v) {\n  return Array.isArray(v);\n}\n\nfunction normalizeToMatrix(v) {\n  if (Array.isArray(v)) {\n    if (v.length === 0) return [[]];\n    if (Array.isArray(v[0])) return v;\n    return [v];\n  }\n  return [[v]];\n}\n\nfunction toScalarString(v) {\n  if (v == null) return \"\";\n  if (typeof v === \"string\") return v;\n  if (typeof v === \"number\") return String(v);\n  if (typeof v === \"boolean\") return v ? \"TRUE\" : \"FALSE\";\n  try {\n    return String(v);\n  } catch {\n    return \"\";\n  }\n}\n\nfunction truncateForCell(text) {\n  const s = String(text || \"\");\n  if (s.length <= EXCEL_CELL_CHAR_LIMIT) return s;\n  return s.slice(0, EXCEL_CELL_CHAR_LIMIT - 1) + \"\";\n}\n\nfunction matrixToTSV(matrix, maxChars = MAX_CONTEXT_CHARS) {\n  const m = normalizeToMatrix(matrix);\n  const lines = [];\n  for (const row of m) {\n    const r = Array.isArray(row) ? row : [row];\n    lines.push(r.map(toScalarString).join(\"\\t\"));\n  }\n  let out = lines.join(\"\\n\");\n  if (out.length > maxChars) out = out.slice(0, maxChars) + \"\\n\";\n  return out;\n}\n\nfunction formatFormulaText(value, maxChars = FORMULA_ARG_MAX) {\n  let s = String(value ?? \"\");\n  s = s.replace(/\\r?\\n/g, \"\\\\n\").replace(/\\t/g, \"\\\\t\");\n  if (s.length > maxChars) s = s.slice(0, Math.max(0, maxChars - 3)) + \"...\";\n  s = s.replace(/\"/g, '\"\"');\n  return `\"${s}\"`;\n}\n\nfunction formatFormulaArg(value) {\n  if (value === undefined || value === null) return \"\";\n  if (typeof value === \"number\" && Number.isFinite(value)) return String(value);\n  if (typeof value === \"boolean\") return value ? \"TRUE\" : \"FALSE\";\n  if (Array.isArray(value)) {\n    const preview = matrixToTSV(value, FORMULA_ARG_MAX).replace(//g, \"...\");\n    return formatFormulaText(preview, FORMULA_ARG_MAX);\n  }\n  return formatFormulaText(value, FORMULA_ARG_MAX);\n}\n\nfunction buildFormulaCall(name, args = []) {\n  const formatted = args.map(formatFormulaArg);\n  let last = formatted.length - 1;\n  while (last >= 0 && formatted[last] === \"\") last--;\n  const trimmed = formatted.slice(0, last + 1);\n  return `=${name}(${trimmed.join(\",\")})`;\n}\n\nfunction flattenMatrix(matrix, maxItems = MAX_LIST_ITEMS) {\n  const m = normalizeToMatrix(matrix);\n  const out = [];\n  for (const row of m) {\n    const r = Array.isArray(row) ? row : [row];\n    for (const cell of r) {\n      out.push(toScalarString(cell));\n      if (out.length >= maxItems) return out;\n    }\n  }\n  return out;\n}\n\nfunction parseShowSource(showSource) {\n  // Allowed \"options\" exception: 0/1 numeric flag for AI.WEB\n  const n = Number(showSource);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseSummarizeMode(mode) {\n  const n = Number(mode);\n  if (!Number.isFinite(n)) return 0;\n  return n === 1 ? 1 : 0;\n}\n\nfunction parseLabels(labels) {\n  if (isMatrix(labels)) {\n    const flat = flattenMatrix(labels, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n    return dedupe(flat);\n  }\n\n  const s = toScalarString(labels);\n  const parts = s\n    .split(/[,\\|;\\n\\r]+/)\n    .map((x) => x.trim())\n    .filter(Boolean);\n  return dedupe(parts);\n}\n\nfunction dedupe(list) {\n  const seen = new Set();\n  const out = [];\n  for (const x of list) {\n    const k = x.toLowerCase();\n    if (seen.has(k)) continue;\n    seen.add(k);\n    out.push(x);\n  }\n  return out;\n}\n\nfunction makeSourcesBlock(sources, max = 8) {\n  const src = Array.isArray(sources) ? sources : [];\n  const list = src.slice(0, max);\n  if (!list.length) return \"\";\n\n  const lines = [\"\", \"Sources:\"];\n  let i = 1;\n  for (const s of list) {\n    const title = (s?.title || \"\").trim();\n    const url = (s?.url || \"\").trim();\n    if (!url) continue;\n    lines.push(`${i}. ${title ? title + \" - \" : \"\"}${url}`);\n    i++;\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction cfError(code, message) {\n  try {\n    if (typeof CustomFunctions !== \"undefined\" && CustomFunctions?.Error) {\n      const errCode = code || CustomFunctions.ErrorCode.invalidValue;\n      return new CustomFunctions.Error(errCode, message);\n    }\n  } catch {\n    // ignore\n  }\n  return `#ERROR: ${message}`;\n}\n\nfunction parseJsonSafe(text) {\n  const s = String(text || \"\").trim();\n\n  // 1. Try to find a markdown code block anywhere in the string\n  const codeBlockMatch = s.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n  if (codeBlockMatch) {\n    return JSON.parse(codeBlockMatch[1]);\n  }\n\n  // 2. If no code block, try to parse the whole string first.\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    // 3. Fallback: try to locate substring starting with {|[ and ending with }|]\n    // Simple heuristic: find first { and last }\n    const firstCurly = s.indexOf(\"{\");\n    const lastCurly = s.lastIndexOf(\"}\");\n    if (firstCurly !== -1 && lastCurly > firstCurly) {\n      try {\n        return JSON.parse(s.slice(firstCurly, lastCurly + 1));\n      } catch { } // ignore\n    }\n\n    const firstSquare = s.indexOf(\"[\");\n    const lastSquare = s.lastIndexOf(\"]\");\n    if (firstSquare !== -1 && lastSquare > firstSquare) {\n      try {\n        return JSON.parse(s.slice(firstSquare, lastSquare + 1));\n      } catch { }\n    }\n\n    throw e; // Original parse error\n  }\n}\n\n// ---- System prompts (no sampling controls) ----\n\nconst NO_CLARIFY = \"Never ask clarifying questions. If information is missing, make reasonable assumptions and proceed.\";\n\nfunction sysAsk(lang = \"fr\") {\n  return [\n    \"You are an assistant embedded in Microsoft Excel custom functions.\",\n    `Respond in ${lang}.`,\n    \"Return a clear and accurate answer suitable for an Excel cell.\",\n    NO_CLARIFY,\n    \"No Markdown. No code fences. No surrounding quotes.\",\n    \"If the question cannot be answered from the provided information, say so briefly.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTranslate(targetLang, expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  if (n > 1) {\n    return [\n      \"You are a translation engine.\",\n      `Translate each cell independently into ${targetLang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${n} strings in the same order as the provided cells.`,\n      \"Each item must contain ONLY the translated text for that cell.\",\n      \"Preserve numbers, units, and identifiers as-is unless they require translation.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not add any keys other than 'items'.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a translation engine.\",\n    `Translate the user text into ${targetLang}.`,\n    NO_CLARIFY,\n    \"Return only the translated text. No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClassify(labels, lang = \"en\") {\n  return [\n    \"You are a strict classifier.\",\n    `Return exactly one label from this set, using the label text verbatim: ${labels.join(\" | \")}`,\n    \"Do not translate, expand, or paraphrase labels.\",\n    \"If uncertain, return exactly: UNKNOWN\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    \"Return only the label.\"\n  ].join(\"\\n\");\n}\n\nfunction sysClean(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You are a text normalizer for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Preserve the meaning of each cell independently.\",\n      \"For empty inputs, return an empty string at the same position.\",\n      \"Do not invent or merge content.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You are a text normalizer for spreadsheet cells.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return only the cleaned text.\",\n    \"No quotes. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysConsistent(lang = \"fr\", expectedItems) {\n  return [\n    \"You harmonize spreadsheet entries that refer to the same real-world value.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n    \"Normalize casing, accents, spacing, and fix obvious typos.\",\n    \"When several cells refer to the same entity, use ONE consistent, best-written value for all of them.\",\n    \"Keep outputs aligned with inputs; do not merge or reorder rows.\",\n    \"If an input is empty or whitespace-only, return an empty string for that position.\",\n    \"Do not invent new information beyond correcting the given values.\"\n  ].join(\"\\n\");\n}\n\nfunction sysSummarize(lang = \"fr\", expectedItems) {\n  if (typeof expectedItems === \"number\" && expectedItems > 1) {\n    return [\n      \"You summarize text for spreadsheet cells.\",\n      `Respond in ${lang}.`,\n      NO_CLARIFY,\n      \"Return STRICT JSON only (no Markdown, no code fences).\",\n      `Return an object with a single key 'items' containing exactly ${expectedItems} strings in the same order as the provided cells.`,\n      \"Summarize each cell independently; do not merge content across cells.\",\n      \"Use bullet points with '-' when it improves readability.\",\n      \"Keep outputs aligned with inputs. If an input is empty or whitespace-only, return an empty string for that position.\",\n      \"No Markdown headers. No code fences. No surrounding quotes.\"\n    ].join(\"\\n\");\n  }\n\n  return [\n    \"You summarize text for a spreadsheet cell.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return a clear summary suitable for an Excel cell.\",\n    \"Use bullet points with '-' when it improves readability.\",\n    \"No Markdown headers. No code fences. No surrounding quotes.\"\n  ].join(\"\\n\");\n}\n\nfunction sysExtract(instruction, lang = \"fr\", expectedItems) {\n  const strictArray =\n    typeof expectedItems === \"number\" && expectedItems > 0\n      ? `Return an object with a single key 'items' which is an array of exactly ${expectedItems} strings, preserving order.`\n      : \"Return an object with a single key 'items' which is an array of strings.\";\n\n  return [\n    \"You are an expert extraction engine.\",\n    `Goal: Extract all entities matching this description: \"${instruction}\"`,\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Lightly normalize results (trim spaces, fix obvious email obfuscation like [at]/(at) -> @ and [dot]/(dot)/point -> .).\",\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    strictArray,\n    \"Example: { \\\"items\\\": [\\\"match1\\\", \\\"match2\\\"] }\",\n    typeof expectedItems === \"number\"\n      ? \"If a value is missing for a cell, return an empty string in that position.\"\n      : \"If nothing found, return { \\\"items\\\": [] }.\",\n    \"Extract exact values from the text without inventing data.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFill(lang = \"fr\", expectedItems) {\n  const n = Number.isFinite(Number(expectedItems)) ? Math.floor(Number(expectedItems)) : 0;\n  const spec = n > 0\n    ? `Return an object with a single key 'values' containing exactly ${n} strings, in the same order as the target rows.`\n    : \"Return an object with a single key 'values' containing an array of strings.\";\n\n  return [\n    \"You are filling spreadsheet cells based on examples.\",\n    `Respond in ${lang}.`,\n    NO_CLARIFY,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    spec,\n    \"Return only the values, in order, one per target row.\",\n    \"If a value is unknown, return an empty string for that row.\",\n    \"Do not add any keys other than 'values'.\"\n  ].join(\"\\n\");\n}\n\nfunction sysFormula(lang) {\n  const isFr = (lang || \"\").toLowerCase().startsWith(\"fr\");\n  return [\n    \"You are an expert Excel formula generator.\",\n    \"Your goal is to output a VALID Excel formula string based on the user request.\",\n    \"Leverage advanced Excel capabilities (dynamic arrays, LET/LAMBDA, structured references, advanced date/time, lookup, statistics, financial functions) when relevant.\",\n    NO_CLARIFY,\n    `Respond in ${lang}.`,\n    isFr\n      ? \"Use FRENCH Excel function names (e.g., SOMME, SI, RECHERCHEV...).\"\n      : \"Use ENGLISH Excel function names (e.g., SUM, IF, VLOOKUP...).\",\n    isFr ? \"Use SEMICOLON (;) as argument separator.\" : \"Use COMMA (,) as argument separator.\",\n    \"Return exactly one ready-to-use Excel formula with no surrounding text.\",\n    \"Return ONLY the formula starting with '='.\",\n    \"No Markdown. No code fences. No explanations.\"\n  ].join(\"\\n\");\n}\n\nfunction sysTable() {\n  return [\n    \"You generate tables for Excel.\",\n    NO_CLARIFY,\n    \"Return JSON that matches the provided schema.\",\n    \"Do not include any extra keys.\",\n    \"Use strings for all cell values.\"\n  ].join(\" \");\n}\nfunction sysWeb(lang = \"fr\") {\n  return [\n    \"You are a meticulous fact-finding assistant with access to reliable web knowledge.\",\n    NO_CLARIFY,\n    \"Return only one precise, up-to-date factual value plus the best authoritative source URL.\",\n    \"Never fabricate numbers or URLs. Use official or authoritative sources only.\",\n    \"Match the requested timeframe and scope exactly; ignore partial or approximate figures.\",\n    \"If the data cannot be confirmed with high confidence, return empty strings and explain why in a 'reason' field.\",\n    `Respond in ${lang}.`,\n    \"Return STRICT JSON only (no Markdown, no code fences).\",\n    'Schema: {\"value\": \"<concise value>\", \"source\": \"https://...\", \"reason\": \"<why unavailable>\"}.',\n    \"The value must mirror the source exactly and stay under 80 characters.\"\n  ].join(\"\\n\");\n}\n\n// ---- Custom Functions ----\n\nexport async function KEY_STATUS() {\n  try {\n    const provider = await getDefaultProvider();\n    const maxTok = await getMaxOutputTokens();\n\n    const gemKey = await getApiKey(PROVIDERS.GEMINI);\n    const oaiKey = await getApiKey(PROVIDERS.OPENAI);\n\n    const gemModel = await getModel(PROVIDERS.GEMINI);\n    const oaiModel = await getModel(PROVIDERS.OPENAI);\n\n    const lines = [\n      `Default provider: ${provider}`,\n      `Max output tokens: ${maxTok}`,\n      `Gemini: ${gemKey ? \"key set\" : \"key missing\"} / model: ${gemModel}`,\n      `OpenAI: ${oaiKey ? \"key set\" : \"key missing\"} / model: ${oaiModel}`,\n      `Storage: ${storageBackendName()}`\n    ];\n\n    return lines.join(\"\\n\");\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, e?.message || \"Erreur KEY_STATUS.\");\n  }\n}\n\nexport async function TEST() {\n  const r = await aiMinimalTest();\n  if (r.ok) return \"OK\";\n  return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Test chou.\");\n}\n\nexport async function ASK(prompt, contextRange) {\n  const q = toScalarString(prompt).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre prompt est vide.\");\n\n  const hasContext = contextRange != null && isMatrix(contextRange);\n  const context = hasContext ? matrixToTSV(contextRange) : \"\";\n\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nQuestion:\\n${q}`\n    : q;\n\n  const r = await aiGenerate({\n    system: sysAsk(DEFAULT_LANG),\n    user,\n    webSearch: false,\n    functionName: \"AI.ASK\",\n    functionCall: buildFormulaCall(\"AI.ASK\", [prompt, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.ASK.\");\n\n  // Strip markdown bold/italic/headers to force plain text for Excel\n  let text = r.text || \"\";\n  text = text.replace(/\\*\\*/g, \"\").replace(/##/g, \"\").replace(/__/g, \"\");\n  return truncateForCell(text);\n}\n\nexport async function WEB(query, focus, showSource) {\n  const q = toScalarString(query).trim();\n  if (!q) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Le paramtre query est vide.\");\n\n  const context = focus != null && isMatrix(focus) ? matrixToTSV(focus) : \"\";\n  const user = context ? `Contexte (TSV):\\n${context}\\n\\nRequte web:\\n${q}` : q;\n\n  const r = await aiGenerate({\n    system: sysWeb(DEFAULT_LANG),\n    user,\n    webSearch: true,\n    functionName: \"AI.WEB\",\n    functionCall: buildFormulaCall(\"AI.WEB\", [query, focus, showSource])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.WEB.\");\n\n  let text = r.text || \"\";\n  let sources = Array.isArray(r.sources) ? r.sources : [];\n  let value = text;\n\n  try {\n    const obj = parseJsonSafe(text);\n    if (obj && typeof obj === \"object\") {\n      const v = toScalarString(obj.value).trim();\n      const src = toScalarString(obj.source).trim();\n      const reason = toScalarString(obj.reason).trim();\n      if (v) value = v;\n      else if (reason) value = reason;\n      if (src) sources = [{ title: \"\", url: src }];\n    }\n  } catch {\n    // Fallback to raw text + provider sources\n  }\n\n  const withSources = parseShowSource(showSource) === 1 ? value + makeSourcesBlock(sources) : value;\n  return truncateForCell(withSources);\n}\n\nexport async function TRANSLATE(textOrRange, targetLang) {\n  const lang = toScalarString(targetLang).trim();\n  if (!lang) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La langue cible est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.TRANSLATE.`\n    );\n  }\n\n  // Batch translation in one call for performance.\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      `Translate each item to: ${lang}.`,\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Translate to ${lang}:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysTranslate(lang, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.TRANSLATE\",\n    functionCall: buildFormulaCall(\"AI.TRANSLATE\", [textOrRange, targetLang])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TRANSLATE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // fall back: best-effort split, but log if empty\n      if (!r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"Rponse vide (TRANSLATE).\");\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  // Normalize length\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  // Rebuild matrix\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLASSIFY(textOrRange, labels) {\n  const allowed = parseLabels(labels);\n  if (!allowed.length) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La liste de labels est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLASSIFY.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  const labelList = allowed.join(\" | \");\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n\n  const user = isBatch\n    ? [\n      \"Classify each item into exactly one label from the allowed list.\",\n      `Allowed labels: ${labelList}`,\n      `Return JSON with items array of length ${expectedItems}. Use UNKNOWN if unsure.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : [\n      \"Classify the following text into exactly one allowed label.\",\n      `Allowed labels: ${labelList}`,\n      \"\",\n      flat[0] || \"\"\n    ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysClassify(allowed, DEFAULT_LANG),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLASSIFY\",\n    functionCall: buildFormulaCall(\"AI.CLASSIFY\", [textOrRange, labels])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLASSIFY.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"UNKNOWN\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const allowedLower = new Map(allowed.map((l) => [l.toLowerCase(), l]));\n  items = items.map((it) => {\n    const key = it.toLowerCase();\n    return allowedLower.get(key) || (it ? it : \"UNKNOWN\");\n  });\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"UNKNOWN\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function EXTRACT(textOrRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.EXTRACT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: {\n        type: \"array\",\n        items: { type: \"string\" }\n      }\n    }\n  };\n\n  // Single cell: allow multiple extracted items and return a vertical spill\n  if (flat.length === 1) {\n    const user = [\n      `Instruction: ${instr}`,\n      \"Input:\",\n      flat[0]\n    ].join(\"\\n\\n\");\n\n    const r = await aiGenerate({\n      system: sysExtract(instr, DEFAULT_LANG),\n      user,\n      responseMimeType: \"application/json\",\n      responseJsonSchema: schema,\n      functionName: \"AI.EXTRACT\",\n      functionCall: buildFormulaCall(\"AI.EXTRACT\", [textOrRange, instruction])\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n    let items = [];\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim()).filter(Boolean);\n    } catch {\n      // Best effort\n      items = r.text.split(\"\\n\").map((x) => x.trim()).filter(Boolean);\n      if (items.length === 0 && r.text) return cfError(CustomFunctions?.ErrorCode?.invalidValue, `JSON Error: ${r.text.slice(0, 100)}`);\n    }\n\n    if (!items.length) return [[\"\"]];\n    return items.map((x) => [truncateForCell(x)]);\n  }\n\n  // Range: return exactly one extracted value per cell (best-effort)\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    `Instruction: ${instr}`,\n    `Return JSON with items array of length ${flat.length}.`,\n    \"Each item must be the best extracted value for the corresponding input (or empty string if none).\",\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysExtract(instr, DEFAULT_LANG, flat.length),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.EXTRACT_BATCH\",\n    functionCall: buildFormulaCall(\"AI.EXTRACT\", [textOrRange, instruction])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.EXTRACT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x).trim());\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CLEAN(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CLEAN.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Clean each item for Excel (whitespace, line breaks).\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Clean this text for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysClean(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.CLEAN\",\n    functionCall: buildFormulaCall(\"AI.CLEAN\", [textOrRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CLEAN.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function CONSISTENT(textOrRange) {\n  const m = normalizeToMatrix(textOrRange);\n  const flat = flattenMatrix(m, MAX_BATCH_CELLS + 1);\n  const expectedItems = flat.length;\n\n  if (flat.length > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage trop grande (max ${MAX_BATCH_CELLS} cellules) pour AI.CONSISTENT.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = [\n    \"Normalize each item so that near-duplicates become identical.\",\n    `Return JSON with items array of length ${expectedItems}.`,\n    \"\",\n    ...lines\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysConsistent(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.CONSISTENT\",\n    functionCall: buildFormulaCall(\"AI.CONSISTENT\", [textOrRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.CONSISTENT.\");\n\n  let items = [];\n  try {\n    const obj = parseJsonSafe(r.text);\n    if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n  } catch {\n    items = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport async function FORMULA(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n  const user = context\n    ? `Contexte (TSV):\\n${context}\\n\\nDescription:\\n${desc}`\n    : desc;\n\n  const locale = getExcelLocale();\n  const formulaLang = isFrenchLocale(locale) ? \"fr\" : \"en\";\n\n  const r = await aiGenerate({\n    system: sysFormula(formulaLang),\n    user,\n    webSearch: false,\n    functionName: \"AI.FORMULA\",\n    functionCall: buildFormulaCall(\"AI.FORMULA\", [description, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FORMULA.\");\n\n  // Extract first formula starting with \"=\"\n  const text = (r.text || \"\").trim();\n  const m1 = text.match(/=[^\\n\\r]+/);\n  const formula = (m1 ? m1[0] : text).trim();\n\n  if (!formula.startsWith(\"=\")) {\n    return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"La rponse n'est pas une formule Excel valide.\");\n  }\n  return truncateForCell(formula);\n}\n\nexport async function TABLE(description, contextRange) {\n  const desc = toScalarString(description).trim();\n  if (!desc) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"La description est vide.\");\n\n  const context = contextRange != null && isMatrix(contextRange) ? matrixToTSV(contextRange) : \"\";\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"headers\", \"rows\"],\n    properties: {\n      headers: { type: \"array\", items: { type: \"string\" } },\n      rows: {\n        type: \"array\",\n        items: {\n          type: \"array\",\n          items: { type: \"string\" }\n        }\n      }\n    }\n  };\n\n  const user = [\n    \"Build a table for Excel based on the description and optional context.\",\n    \"Return JSON { headers: [...], rows: [[...], ...] }\",\n    context ? `\\nContext (TSV):\\n${context}` : \"\",\n    `\\nDescription:\\n${desc}`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysTable(),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.TABLE\",\n    functionCall: buildFormulaCall(\"AI.TABLE\", [description, contextRange])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.TABLE.\");\n\n  let obj = null;\n  try {\n    obj = parseJsonSafe(r.text);\n  } catch {\n    // If strict parsing fails, try to just find the first JSON-like object\n    try {\n      const match = r.text.match(/\\{[\\s\\S]*\\}/);\n      if (match) obj = JSON.parse(match[0]);\n      else throw new Error();\n    } catch {\n      return cfError(CustomFunctions?.ErrorCode?.notAvailable, \"Impossible de parser le JSON renvoy par l'IA.\");\n    }\n  }\n\n  const headers = Array.isArray(obj?.headers) ? obj.headers.map((x) => truncateForCell(toScalarString(x))) : [];\n  const rows = Array.isArray(obj?.rows) ? obj.rows : [];\n\n  const width = headers.length || (Array.isArray(rows?.[0]) ? rows[0].length : 0) || 1;\n  const safeHeaders = headers.length ? headers : Array.from({ length: width }, (_, i) => `Col${i + 1}`);\n\n  const out = [safeHeaders];\n\n  for (const r0 of rows) {\n    const row = Array.isArray(r0) ? r0.map((x) => truncateForCell(toScalarString(x))) : [];\n    // pad / truncate to width\n    while (row.length < safeHeaders.length) row.push(\"\");\n    if (row.length > safeHeaders.length) row.length = safeHeaders.length;\n    out.push(row);\n  }\n\n  return out;\n}\n\nexport async function FILL(exampleRange, targetRange, instruction) {\n  const instr = toScalarString(instruction).trim();\n  if (!instr) return cfError(CustomFunctions?.ErrorCode?.invalidValue, \"L'instruction est vide.\");\n\n  const ex = normalizeToMatrix(exampleRange);\n  const tgt = normalizeToMatrix(targetRange);\n\n  const nRows = tgt.length;\n  if (nRows <= 0) return [[\"\"]];\n\n  if (nRows > MAX_BATCH_CELLS) {\n    return cfError(\n      CustomFunctions?.ErrorCode?.invalidValue,\n      `Plage cible trop grande (max ${MAX_BATCH_CELLS} lignes) pour AI.FILL.`\n    );\n  }\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"values\"],\n    properties: {\n      values: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const user = [\n    `Instruction: ${instr}`,\n    \"\",\n    \"Examples (TSV):\",\n    matrixToTSV(ex, 6000),\n    \"\",\n    \"Target rows (TSV):\",\n    matrixToTSV(tgt, 6000),\n    \"\",\n    `Return JSON with values array of length ${nRows} (one value per target row).`\n  ].join(\"\\n\");\n\n  const r = await aiGenerate({\n    system: sysFill(DEFAULT_LANG, nRows),\n    user,\n    responseMimeType: \"application/json\",\n    responseJsonSchema: schema,\n    functionName: \"AI.FILL\",\n    functionCall: buildFormulaCall(\"AI.FILL\", [exampleRange, targetRange, instruction])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.FILL.\");\n\n  let values = [];\n  try {\n    const obj = JSON.parse(r.text);\n    if (Array.isArray(obj?.values)) values = obj.values.map((x) => toScalarString(x));\n  } catch {\n    values = r.text.split(\"\\n\").map((x) => x.trim());\n  }\n\n  while (values.length < nRows) values.push(\"\");\n  if (values.length > nRows) values = values.slice(0, nRows);\n\n  return values.map((v) => [truncateForCell(v)]);\n}\n\nexport async function SUMMARIZE(textOrRange, mode) {\n  const summarizeMode = parseSummarizeMode(mode);\n  const m = normalizeToMatrix(textOrRange);\n\n  if (summarizeMode === 1) {\n    const flat = flattenMatrix(m, 2000)\n      .map((s) => s.trim())\n      .filter(Boolean);\n\n    if (!flat.length) return [[\"\"]];\n\n    const joined = flat.join(\"\\n\");\n    const user = `Content:\\n${joined}`;\n\n    const r = await aiGenerate({\n      system: sysSummarize(DEFAULT_LANG),\n      user,\n      webSearch: false,\n      functionName: \"AI.SUMMARIZE\",\n      functionCall: buildFormulaCall(\"AI.SUMMARIZE\", [textOrRange, mode])\n    });\n\n    if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n    return [[truncateForCell(r.text)]];\n  }\n\n  const flat = flattenMatrix(m, 2000).map((s) => s.trim());\n  const expectedItems = flat.length;\n  const isBatch = expectedItems > 1;\n\n  if (!expectedItems) return [[\"\"]];\n\n  const schema = {\n    type: \"object\",\n    additionalProperties: false,\n    required: [\"items\"],\n    properties: {\n      items: { type: \"array\", items: { type: \"string\" } }\n    }\n  };\n\n  const lines = flat.map((t, i) => `${i + 1}. ${t}`);\n  const user = isBatch\n    ? [\n      \"Summarize each item for Excel.\",\n      `Return JSON with items array of length ${expectedItems}. Use empty string for empty inputs.`,\n      \"\",\n      ...lines\n    ].join(\"\\n\")\n    : `Summarize for Excel:\\n${flat[0] || \"\"}`;\n\n  const r = await aiGenerate({\n    system: sysSummarize(DEFAULT_LANG, expectedItems),\n    user,\n    responseMimeType: isBatch ? \"application/json\" : undefined,\n    responseJsonSchema: isBatch ? schema : undefined,\n    functionName: \"AI.SUMMARIZE\",\n    functionCall: buildFormulaCall(\"AI.SUMMARIZE\", [textOrRange, mode])\n  });\n\n  if (!r.ok) return cfError(CustomFunctions?.ErrorCode?.notAvailable, r.message || \"Erreur AI.SUMMARIZE.\");\n\n  let items = [];\n  if (isBatch) {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      items = r.text.split(\"\\n\").map((x) => x.trim());\n    }\n  } else {\n    try {\n      const obj = parseJsonSafe(r.text);\n      if (Array.isArray(obj?.items)) items = obj.items.map((x) => toScalarString(x));\n    } catch {\n      // ignore and fallback to plain text\n    }\n    if (!items.length) items = [toScalarString(r.text).trim()];\n  }\n\n  while (items.length < flat.length) items.push(\"\");\n  if (items.length > flat.length) items = items.slice(0, flat.length);\n\n  const out = [];\n  let k = 0;\n  for (let i = 0; i < m.length; i++) {\n    const row = [];\n    for (let j = 0; j < (m[i] || []).length; j++) {\n      row.push(truncateForCell(items[k++] || \"\"));\n    }\n    out.push(row);\n  }\n  return out;\n}\n\nexport function COUNT(range, value) {\n  try {\n    const m = normalizeToMatrix(range);\n    const needle = toScalarString(value).toLowerCase();\n\n    let count = 0;\n    for (const row of m) {\n      const r = Array.isArray(row) ? row : [row];\n      for (const cell of r) {\n        if (toScalarString(cell).toLowerCase() === needle) count++;\n      }\n    }\n    return count;\n  } catch (e) {\n    return cfError(CustomFunctions?.ErrorCode?.invalidValue, e?.message || \"Erreur AI.COUNT.\");\n  }\n}\n\n// ---- Registration (robust for shared runtime timing) ----\n\nfunction registerAll() {\n  // Associate function names exactly as used in functions.json (ids map to namespace AI.*)\n  try {\n    if (typeof CustomFunctions === \"undefined\" || !CustomFunctions?.associate) return false;\n\n    const safeAssociate = (id, fn) => {\n      try {\n        CustomFunctions.associate(id, fn);\n        return true;\n      } catch {\n        return false;\n      }\n    };\n\n    let ok = true;\n    ok = safeAssociate(\"AI.KEYSTATUS\", KEY_STATUS) && ok;\n    ok = safeAssociate(\"AI.TEST\", TEST) && ok;\n    ok = safeAssociate(\"AI.ASK\", ASK) && ok;\n    ok = safeAssociate(\"AI.WEB\", WEB) && ok;\n    ok = safeAssociate(\"AI.TRANSLATE\", TRANSLATE) && ok;\n    ok = safeAssociate(\"AI.CLASSIFY\", CLASSIFY) && ok;\n    ok = safeAssociate(\"AI.EXTRACT\", EXTRACT) && ok;\n    ok = safeAssociate(\"AI.CLEAN\", CLEAN) && ok;\n    ok = safeAssociate(\"AI.CONSISTENT\", CONSISTENT) && ok;\n    ok = safeAssociate(\"AI.FORMULA\", FORMULA) && ok;\n    ok = safeAssociate(\"AI.TABLE\", TABLE) && ok;\n    ok = safeAssociate(\"AI.FILL\", FILL) && ok;\n    ok = safeAssociate(\"AI.SUMMARIZE\", SUMMARIZE) && ok;\n    ok = safeAssociate(\"AI.COUNT\", COUNT) && ok;\n\n    return ok;\n  } catch {\n    return false;\n  }\n}\n\n// Poll until CustomFunctions is available (Office.js loads after functions.js in taskpane.html)\nconst regTimer = setInterval(() => {\n  if (registerAll()) clearInterval(regTimer);\n}, 200);\n"],"names":["PROVIDERS","Object","freeze","GEMINI","OPENAI","DEFAULTS","provider","geminiModel","openaiModel","geminiReasoningEffort","openaiReasoningEffort","maxOutputTokens","concurrencyLimit","retry","timeoutMs","cache","cacheTtlSec","webCacheTtlSec","STORAGE_KEYS","DEFAULT_PROVIDER","GEMINI_API_KEY","OPENAI_API_KEY","GEMINI_MODEL","OPENAI_MODEL","GEMINI_REASONING_EFFORT","OPENAI_REASONING_EFFORT","MAX_OUTPUT_TOKENS","CONCURRENCY_LIMIT","ONBOARDING_SEEN","ONBOARDING_KEYS_CONFIRMED","SECTION_ORDER","SECTION_HIDDEN","LICENSE","PRIVACY_MODE","MIGRATION_DONE","REQUEST_LOG","REQUEST_LOG_CLEAR_AT","USAGE_TOTALS","CACHE_INDEX","CACHE_CLEAR_AT","RUNTIME_STATUS","SENSITIVE_KEYS","Set","LEGACY_KEYS","DEFAULT_PROVIDER_V2","GEMINI_API_KEY_V2","OPENAI_API_KEY_V2","GEMINI_MODEL_V2","OPENAI_MODEL_V2","GEMINI_MAX_TOKENS_V2","OPENAI_MAX_TOKENS_V2","_migrationPromise","_officeStorageFailed","_privacyModeCache","_privacyModeCacheAt","markOfficeStorageFailed","getRuntimeStorage","OfficeRuntime","storage","getItem","kind","window","localStorage","mem","Map","async","k","has","get","setItem","v","set","String","removeItem","delete","getLocalStorageSafe","localGet","local","key","localSet","value","localRemove","rawGet","options","sensitive","isSensitiveKey","allowLocalFallback","result","localValue","rawSet","stored","ensureMigrated","normalizeProvider","legacyProvider","legacy","candidates","map","x","parseInt","trim","filter","n","Number","isFinite","migrated","length","Math","max","p","s","toLowerCase","GEMINI_REASONING_EFFORTS","OPENAI_REASONING_EFFORTS","getDefaultProvider","getApiKey","keyKey","getModel","raw","modelKey","getMaxOutputTokens","clampInt","CONCURRENCY_OPTIONS","setRuntimeStatus","status","normalized","active","queued","ts","MAX_SAFE_INTEGER","JSON","stringify","getPrivacyMode","now","nowMs","enabled","loadPrivacyMode","Date","sleep","ms","Promise","resolve","setTimeout","min","fallback","REDACT_PATTERNS","redactSensitiveText","text","pattern","replace","redactSensitiveValue","Array","isArray","out","entry","entries","parseTimestampMs","CACHE_ENTRY_PREFIX","_cacheClearMs","syncCacheClearMarker","clearedAt","loadCacheIndex","arr","parse","saveCacheIndex","removeCacheEntry","removed","rawRemove","removeFromCacheIndex","index","next","item","setPersistentCache","cacheKey","ttlMs","meta","savedAtMs","expiresAtMs","model","size","updated","push","pruned","kept","removedKeys","savedAt","sort","a","b","over","toRemove","slice","r","list","pruneCacheIndex","sortKeysDeep","prototype","toString","call","keys","REQUEST_LOG_TTL_MS","Infinity","_requestLog","_requestLogLoading","_requestLogLoaded","_requestLogLastLoadedMs","_requestLogClearMs","_usageTotals","createEmptyUsageTotals","_usageTotalsLoading","_usageTotalsLoaded","_usageTotalsLastLoadedMs","syncRequestLogClearMarker","reset","isErrorLogEntry","ok","persistRequestLog","pruneRequestLog","REQUEST_LOG_MAX_PER_TYPE","valid","e","normals","errors","concat","toNonNegInt","floor","inputTokens","outputTokens","reasoningTokens","cachedInputTokens","requests","byProvider","models","updateUsageTotals","modelLabel","force","parsed","base","providers","rawProvider","target","rawModels","label","normalizeUsageTotals","loadUsageTotals","providerTotals","existing","persistUsageTotals","logRequest","logEntry","sanitizeLogEntry","normal","coerceRequestLogArray","loadRequestLog","logRequestAsync","CACHE","constructor","maxEntries","this","oldestKey","clear","_cacheClearLocalMs","INFLIGHT","QUEUE_CANCELLED","Symbol","QUEUE_CANCELLED_RESULT","code","message","concurrencyLimitCached","concurrencyLimitCachedAt","queue","statusTimer","pendingStatus","lastStatusKey","scheduleRuntimeStatusUpdate","snapshot","getConcurrencyLimitCached","includes","best","bestDiff","abs","option","diff","normalizeConcurrencyLimit","getConcurrencyLimit","isNonEmptyString","normalizeBoolean","def","normalizeTimeoutMs","toLowerMsg","looksLikeStructuredOutputUnsupported","looksLikeWebSearchUnsupported","isGeminiServiceUnavailable","msg","ensureJsonInstruction","system","test","getFormulaForLog","fnName","match","formula","startsWith","extractFormulaFromText","aiGenerate","req","start","apiKey","functionName","functionCall","reasoningEffort","normalizeReasoningEffort","getOpenAIReasoningEffort","normalizeGeminiReasoningEffort","getGeminiReasoningEffort","reasoningEffortLabel","fn","undefined","user","webSearch","gemini503RetryMax","cfgMax","normalizeMaxOutputTokens","thinkingConfig","effort","level","modelId","thinkingLevel","toUpperCase","budget","minimal","low","medium","high","thinkingBudget","resolveGeminiThinkingConfig","cacheEnabled","ttlSec","getCacheClearAt","cacheKeyPayload","responseMimeType","responseJsonSchema","input","crypto","subtle","digest","TextEncoder","bytes","encode","from","Uint8Array","padStart","join","str","h","i","charCodeAt","imul","fnv1a32","hashKey","cached","cacheKind","totalTokens","persisted","Error","getPersistentCache","limit","attempt","lastErr","callProvider","url","body","max_output_tokens","store","reasoning","sysText","instructions","format","type","name","strict","schema","tools","include","res","fetchWithTimeout","method","headers","Authorization","json","safeJson","error","extractOpenAIError","output_text","output","texts","content","part","choices","extractOpenAIText","sources","action","src","title","dedupeSources","extractOpenAISources","usage","u","rawOutputTokens","toInt","output_tokens","output_tokens_details","reasoning_tokens","input_tokens","total_tokens","input_tokens_details","cached_tokens","extractOpenAIUsage","callOpenAI","opts","encodeURIComponent","geminiEndpoint","contents","role","parts","generationConfig","systemInstruction","responseSchema","google_search","errInfo","err","statusCode","extractGeminiErrorInfo","extractGeminiError","c","extractGeminiText","md","groundingMetadata","chunks","groundingChunks","ch","web","uri","extractGeminiSources","usageMetadata","promptTokenCount","candidatesTokenCount","thoughtsTokenCount","totalTokenCount","cachedContentTokenCount","extractGeminiUsage","callGemini","baseOpts","wantsStructured","shouldRetryServiceUnavailable","normalizeUsage","shift","withConcurrencyLimit","reportedTotal","computedTotal","seen","add","t","AbortController","fetch","ctrl","id","abort","signal","clearTimeout","MAX_BATCH_CELLS","POSITIVE_INFINITY","DEFAULT_LANG","isMatrix","normalizeToMatrix","toScalarString","truncateForCell","EXCEL_CELL_CHAR_LIMIT","matrixToTSV","matrix","maxChars","m","lines","row","formatFormulaText","FORMULA_ARG_MAX","formatFormulaArg","buildFormulaCall","args","formatted","last","flattenMatrix","maxItems","cell","dedupe","cfError","CustomFunctions","errCode","ErrorCode","invalidValue","parseJsonSafe","codeBlockMatch","firstCurly","indexOf","lastCurly","lastIndexOf","firstSquare","lastSquare","NO_CLARIFY","sysAsk","lang","sysTranslate","targetLang","expectedItems","sysClassify","labels","sysClean","sysConsistent","sysSummarize","sysExtract","instruction","sysFill","sysFormula","isFr","sysWeb","KEY_STATUS","maxTok","gemKey","oaiKey","gemModel","notAvailable","TEST","aiMinimalTest","ASK","prompt","contextRange","q","context","WEB","query","focus","showSource","obj","source","reason","withSources","parseShowSource","makeSourcesBlock","TRANSLATE","textOrRange","flat","isBatch","additionalProperties","required","properties","items","split","j","CLASSIFY","allowed","Boolean","parseLabels","labelList","allowedLower","l","it","EXTRACT","instr","CLEAN","CONSISTENT","FORMULA","description","desc","formulaLang","locale","Office","displayLanguage","contentLanguage","navigator","language","getExcelLocale","m1","TABLE","rows","width","safeHeaders","_","r0","FILL","exampleRange","targetRange","ex","tgt","nRows","values","SUMMARIZE","mode","summarizeMode","parseSummarizeMode","COUNT","range","needle","count","regTimer","setInterval","associate","safeAssociate","registerAll","clearInterval"],"ignoreList":[],"sourceRoot":""}