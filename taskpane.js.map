{"version":3,"file":"taskpane.js","mappings":"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","sources":["webpack://excel-ai-gemini-addin/./src/shared/core.js","webpack://excel-ai-gemini-addin/./src/shared/providers.js","webpack://excel-ai-gemini-addin/./src/license.js","webpack://excel-ai-gemini-addin/./src/taskpane/taskpane.js"],"sourcesContent":["// src/shared/core.js\n// Shared utilities + persisted configuration for the Neurow add-in.\n//\n// Key design goals:\n// - Two providers (Gemini + OpenAI) can coexist.\n// - The default provider is chosen in the taskpane (not in formulas).\n// - No temperature / sampling controls anywhere (per requirements).\n// - A single \"max output tokens\" setting applies to both providers.\n\nexport const PROVIDERS = Object.freeze({\n  GEMINI: \"gemini\",\n  OPENAI: \"openai\"\n});\n\nexport const DEFAULTS = Object.freeze({\n  provider: PROVIDERS.GEMINI,\n  // Default models (User specified future versions)\n  geminiModel: \"gemini-3-flash-preview\",\n  openaiModel: \"gpt-5-mini\",\n  geminiReasoningEffort: \"minimal\",\n  openaiReasoningEffort: \"low\",\n  maxOutputTokens: 4096,\n  concurrencyLimit: 16,\n  rpmLimit: 0,\n  interfaceMode: \"advanced\",\n\n  // Execution / UX\n  retry: 2,\n  timeoutMs: 120000,\n\n  // In-memory cache (per runtime). Note: Office custom functions can run in a long-lived runtime.\n  cache: true,\n  cacheTtlSec: 7 * 24 * 3600 // 7 days\n});\n\nconst STORAGE_KEYS = Object.freeze({\n  DEFAULT_PROVIDER: \"AI_DEFAULT_PROVIDER_V3\",\n  GEMINI_API_KEY: \"AI_GEMINI_API_KEY_V3\",\n  OPENAI_API_KEY: \"AI_OPENAI_API_KEY_V3\",\n  GEMINI_MODEL: \"AI_GEMINI_MODEL_V3\",\n  OPENAI_MODEL: \"AI_OPENAI_MODEL_V3\",\n  GEMINI_REASONING_EFFORT: \"AI_GEMINI_REASONING_EFFORT_V3\",\n  OPENAI_REASONING_EFFORT: \"AI_OPENAI_REASONING_EFFORT_V3\",\n  MAX_OUTPUT_TOKENS: \"AI_MAX_OUTPUT_TOKENS_V3\",\n  CONCURRENCY_LIMIT: \"AI_CONCURRENCY_LIMIT_V1\",\n  RPM_LIMIT: \"AI_RPM_LIMIT_V1\",\n  INTERFACE_MODE: \"AI_INTERFACE_MODE_V1\",\n  ONBOARDING_SEEN: \"AI_ONBOARDING_SEEN_V1\",\n  ONBOARDING_KEYS_CONFIRMED: \"AI_ONBOARDING_KEYS_CONFIRMED_V1\",\n  SECTION_ORDER: \"AI_SECTION_ORDER_V1\",\n  SECTION_HIDDEN: \"AI_SECTION_HIDDEN_V1\",\n  LICENSE: \"AI_LICENSE_V1\",\n  PRIVACY_MODE: \"AI_PRIVACY_MODE_V1\",\n\n  // Prevent re-running migrations each time.\n  MIGRATION_DONE: \"AI_MIGRATION_DONE_V3\",\n\n  // Diagnostics + cache metadata\n  REQUEST_LOG: \"AI_REQUEST_LOG_V1\",\n  REQUEST_LOG_CLEAR_AT: \"AI_REQUEST_LOG_CLEAR_AT_V1\",\n  USAGE_TOTALS: \"AI_USAGE_TOTALS_V1\",\n  CACHE_INDEX: \"AI_CACHE_INDEX_V1\",\n  CACHE_CLEAR_AT: \"AI_CACHE_CLEAR_AT_V1\",\n  RUNTIME_STATUS: \"AI_RUNTIME_STATUS_V1\"\n});\n\nconst SENSITIVE_KEYS = new Set([STORAGE_KEYS.GEMINI_API_KEY, STORAGE_KEYS.OPENAI_API_KEY, STORAGE_KEYS.LICENSE]);\n\n// Older keys used by previous versions (best-effort migration).\nconst LEGACY_KEYS = Object.freeze({\n  GEMINI_API_KEY: \"GEMINI_API_KEY\",\n  MAX_OUTPUT_TOKENS: \"MAX_OUTPUT_TOKENS\",\n\n  DEFAULT_PROVIDER_V2: \"AI_DEFAULT_PROVIDER_V2\",\n  GEMINI_API_KEY_V2: \"AI_GEMINI_API_KEY_V2\",\n  OPENAI_API_KEY_V2: \"AI_OPENAI_API_KEY_V2\",\n  GEMINI_MODEL_V2: \"AI_GEMINI_MODEL_V2\",\n  OPENAI_MODEL_V2: \"AI_OPENAI_MODEL_V2\",\n\n  GEMINI_MAX_TOKENS_V2: \"AI_GEMINI_MAX_OUTPUT_TOKENS_V2\",\n  OPENAI_MAX_TOKENS_V2: \"AI_OPENAI_MAX_OUTPUT_TOKENS_V2\"\n});\n\nlet _migrationPromise = null;\nlet _officeStorageFailed = false;\nlet _privacyModeCache = null;\nlet _privacyModeCacheAt = 0;\nconst SETTINGS_CACHE_TTL_MS = 1500;\nlet _defaultProviderCache = null;\nlet _defaultProviderCacheAt = 0;\nlet _maxOutputTokensCache = null;\nlet _maxOutputTokensCacheAt = 0;\nlet _geminiReasoningCache = null;\nlet _geminiReasoningCacheAt = 0;\nlet _openaiReasoningCache = null;\nlet _openaiReasoningCacheAt = 0;\nlet _interfaceModeCache = null;\nlet _interfaceModeCacheAt = 0;\nconst _apiKeyCache = { gemini: null, openai: null };\nconst _apiKeyCacheAt = { gemini: 0, openai: 0 };\nconst _modelCache = { gemini: null, openai: null };\nconst _modelCacheAt = { gemini: 0, openai: 0 };\n\nfunction markOfficeStorageFailed() {\n  _officeStorageFailed = true;\n}\n\nfunction isSensitiveKey(key) {\n  return SENSITIVE_KEYS.has(key);\n}\n\nconst MEMORY_STORAGE = {\n  kind: \"memory\",\n  storage: (() => {\n    const mem = new Map();\n    return {\n      async getItem(k) {\n        return mem.has(k) ? mem.get(k) : null;\n      },\n      async setItem(k, v) {\n        mem.set(k, String(v));\n      },\n      async removeItem(k) {\n        mem.delete(k);\n      }\n    };\n  })()\n};\n\nfunction getRuntimeStorage() {\n  if (!_officeStorageFailed) {\n    try {\n      if (typeof OfficeRuntime !== \"undefined\" && OfficeRuntime?.storage?.getItem) {\n        return { kind: \"office\", storage: OfficeRuntime.storage };\n      }\n    } catch {\n      // ignore\n    }\n  }\n\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return { kind: \"local\", storage: window.localStorage };\n    }\n  } catch {\n    // ignore\n  }\n\n  // Extremely defensive fallback (in-memory only, persisted for this session).\n  return MEMORY_STORAGE;\n}\n\nfunction getLocalStorageSafe() {\n  try {\n    if (typeof window !== \"undefined\" && window?.localStorage?.getItem) {\n      return window.localStorage;\n    }\n  } catch {\n    return null;\n  }\n  return null;\n}\n\nfunction localGet(local, key) {\n  try {\n    return local.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nfunction localSet(local, key, value) {\n  try {\n    local.setItem(key, value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction localRemove(local, key) {\n  try {\n    local.removeItem(key);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function storageBackendName() {\n  return getRuntimeStorage().kind;\n}\n\nasync function rawGet(key, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const sensitive = options.sensitive ?? isSensitiveKey(key);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    return localGet(storage, key);\n  }\n\n  if (kind === \"office\") {\n    let result = null;\n    try {\n      result = await storage.getItem(key);\n    } catch {\n      markOfficeStorageFailed();\n    }\n    if (result != null) {\n      if (sensitive) {\n        const local = getLocalStorageSafe();\n        if (local) localRemove(local, key);\n      }\n      return result;\n    }\n    if (!allowLocalFallback) return null;\n\n    const local = getLocalStorageSafe();\n    if (!local) return null;\n    const localValue = localGet(local, key);\n    if (localValue == null) return null;\n\n    if (!_officeStorageFailed) {\n      try {\n        await storage.setItem(key, String(localValue));\n        localRemove(local, key);\n      } catch {\n        markOfficeStorageFailed();\n      }\n    }\n\n    return localValue;\n  }\n\n  try {\n    return await storage.getItem(key);\n  } catch {\n    return null;\n  }\n}\n\nasync function rawSet(key, value, options = {}) {\n  const { kind, storage } = getRuntimeStorage();\n  const v = value == null ? \"\" : String(value);\n  const allowLocalFallback = options.allowLocalFallback !== false;\n\n  if (kind === \"local\") {\n    localSet(storage, key, v);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let stored = false;\n    try {\n      await storage.setItem(key, v);\n      stored = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (stored) {\n      if (local) localRemove(local, key);\n      return;\n    }\n\n    if (!allowLocalFallback || !local) return;\n    localSet(local, key, v);\n    return;\n  }\n\n  try {\n    await storage.setItem(key, v);\n  } catch {\n    // ignore\n  }\n}\n\nasync function rawRemove(key) {\n  const { kind, storage } = getRuntimeStorage();\n\n  if (kind === \"local\") {\n    localRemove(storage, key);\n    return;\n  }\n\n  if (kind === \"office\") {\n    let removed = false;\n    try {\n      await storage.removeItem(key);\n      removed = true;\n    } catch {\n      markOfficeStorageFailed();\n    }\n\n    const local = getLocalStorageSafe();\n    if (local) localRemove(local, key);\n    return;\n  }\n\n  try {\n    await storage.removeItem(key);\n  } catch {\n    // ignore\n  }\n}\n\nasync function ensureMigrated() {\n  if (_migrationPromise) return _migrationPromise;\n\n  _migrationPromise = (async () => {\n    // Fast exit if already migrated\n    const done = await rawGet(STORAGE_KEYS.MIGRATION_DONE);\n    if (done === \"1\") return;\n\n    // Migrate provider\n    const currentProvider = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER));\n    if (!currentProvider) {\n      const legacyProvider = normalizeProvider(await rawGet(LEGACY_KEYS.DEFAULT_PROVIDER_V2));\n      await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, legacyProvider || DEFAULTS.provider);\n    }\n\n    // Migrate keys\n    const gKey = await rawGet(STORAGE_KEYS.GEMINI_API_KEY);\n    if (!gKey) {\n      const legacy = (await rawGet(LEGACY_KEYS.GEMINI_API_KEY_V2)) || (await rawGet(LEGACY_KEYS.GEMINI_API_KEY));\n      if (legacy) await rawSet(STORAGE_KEYS.GEMINI_API_KEY, legacy);\n    }\n\n    const oKey = await rawGet(STORAGE_KEYS.OPENAI_API_KEY);\n    if (!oKey) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_API_KEY_V2);\n      if (legacy) await rawSet(STORAGE_KEYS.OPENAI_API_KEY, legacy);\n    }\n\n    // Migrate models\n    const gModel = await rawGet(STORAGE_KEYS.GEMINI_MODEL);\n    if (!gModel) {\n      const legacy = await rawGet(LEGACY_KEYS.GEMINI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.GEMINI_MODEL, legacy || DEFAULTS.geminiModel);\n    }\n\n    const oModel = await rawGet(STORAGE_KEYS.OPENAI_MODEL);\n    if (!oModel) {\n      const legacy = await rawGet(LEGACY_KEYS.OPENAI_MODEL_V2);\n      await rawSet(STORAGE_KEYS.OPENAI_MODEL, legacy || DEFAULTS.openaiModel);\n    }\n\n    // Migrate max tokens (unified)\n    const tok = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n    if (!tok) {\n      const legacyUnified = await rawGet(LEGACY_KEYS.MAX_OUTPUT_TOKENS);\n      const legacyGem = await rawGet(LEGACY_KEYS.GEMINI_MAX_TOKENS_V2);\n      const legacyOai = await rawGet(LEGACY_KEYS.OPENAI_MAX_TOKENS_V2);\n\n      const candidates = [legacyUnified, legacyGem, legacyOai]\n        .map((x) => parseInt(String(x || \"\").trim(), 10))\n        .filter((n) => Number.isFinite(n) && n > 0);\n\n      const migrated = candidates.length ? Math.max(...candidates) : DEFAULTS.maxOutputTokens;\n      await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(migrated));\n    }\n\n    const interfaceMode = await rawGet(STORAGE_KEYS.INTERFACE_MODE);\n    if (!interfaceMode) {\n      await rawSet(STORAGE_KEYS.INTERFACE_MODE, DEFAULTS.interfaceMode);\n    }\n\n    await rawSet(STORAGE_KEYS.MIGRATION_DONE, \"1\");\n  })();\n\n  try {\n    await _migrationPromise;\n  } finally {\n    _migrationPromise = null;\n  }\n}\n\nexport function normalizeProvider(p) {\n  if (!p) return \"\";\n  const s = String(p).trim().toLowerCase();\n  if (s === PROVIDERS.GEMINI) return PROVIDERS.GEMINI;\n  if (s === PROVIDERS.OPENAI) return PROVIDERS.OPENAI;\n  // Common aliases (defensive)\n  if (s === \"google\" || s === \"gem\") return PROVIDERS.GEMINI;\n  if (s === \"oai\" || s === \"chatgpt\") return PROVIDERS.OPENAI;\n  return \"\";\n}\n\nexport function normalizeInterfaceMode(mode) {\n  const value = String(mode || \"\").trim().toLowerCase();\n  if (value === \"simple\") return \"simple\";\n  if (value === \"advanced\") return \"advanced\";\n  return DEFAULTS.interfaceMode;\n}\n\nconst GEMINI_REASONING_EFFORTS = new Set([\"auto\", \"minimal\", \"low\", \"medium\", \"high\"]);\nconst OPENAI_REASONING_EFFORTS = new Set([\"none\", \"minimal\", \"low\", \"medium\", \"high\"]);\n\nfunction normalizeGeminiReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.geminiReasoningEffort;\n  return GEMINI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.geminiReasoningEffort;\n}\n\nfunction normalizeReasoningEffort(value) {\n  const v = String(value || \"\").trim().toLowerCase();\n  if (!v) return DEFAULTS.openaiReasoningEffort;\n  return OPENAI_REASONING_EFFORTS.has(v) ? v : DEFAULTS.openaiReasoningEffort;\n}\n\nexport async function getDefaultProvider() {\n  const now = nowMs();\n  if (_defaultProviderCache && now - _defaultProviderCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _defaultProviderCache;\n  }\n  await ensureMigrated();\n  const p = normalizeProvider(await rawGet(STORAGE_KEYS.DEFAULT_PROVIDER)) || DEFAULTS.provider;\n  _defaultProviderCache = p;\n  _defaultProviderCacheAt = now;\n  return p;\n}\n\nexport async function setDefaultProvider(provider) {\n  const p = normalizeProvider(provider) || DEFAULTS.provider;\n  await rawSet(STORAGE_KEYS.DEFAULT_PROVIDER, p);\n  _defaultProviderCache = p;\n  _defaultProviderCacheAt = nowMs();\n  return p;\n}\n\nfunction keyKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_API_KEY;\n  return STORAGE_KEYS.GEMINI_API_KEY;\n}\n\nexport async function getApiKey(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const now = nowMs();\n  if (_apiKeyCache[p] != null && now - _apiKeyCacheAt[p] < SETTINGS_CACHE_TTL_MS) {\n    return (_apiKeyCache[p] || \"\").trim();\n  }\n  await ensureMigrated();\n  const k = (await rawGet(keyKey(p))) || \"\";\n  const trimmed = String(k).trim();\n  _apiKeyCache[p] = trimmed;\n  _apiKeyCacheAt[p] = now;\n  return trimmed;\n}\n\nexport async function hasApiKey(provider) {\n  const k = await getApiKey(provider);\n  return !!k;\n}\n\nexport async function setApiKey(provider, apiKey) {\n  const k = (apiKey || \"\").trim();\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  await rawSet(keyKey(p), k);\n  _apiKeyCache[p] = k;\n  _apiKeyCacheAt[p] = nowMs();\n  return k;\n}\n\nexport async function clearApiKey(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  await rawRemove(keyKey(p));\n  _apiKeyCache[p] = \"\";\n  _apiKeyCacheAt[p] = nowMs();\n}\n\nfunction modelKey(provider) {\n  const p = normalizeProvider(provider);\n  if (p === PROVIDERS.OPENAI) return STORAGE_KEYS.OPENAI_MODEL;\n  return STORAGE_KEYS.GEMINI_MODEL;\n}\n\nexport async function getModel(provider) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const now = nowMs();\n  const cached = _modelCache[p];\n  if (cached && now - _modelCacheAt[p] < SETTINGS_CACHE_TTL_MS) return cached;\n  await ensureMigrated();\n  const raw = await rawGet(modelKey(p));\n  const resolved = (raw && String(raw).trim())\n    ? String(raw).trim()\n    : (p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel);\n  _modelCache[p] = resolved;\n  _modelCacheAt[p] = now;\n  return resolved;\n}\n\nexport async function getGeminiReasoningEffort() {\n  const now = nowMs();\n  if (_geminiReasoningCache && now - _geminiReasoningCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _geminiReasoningCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.GEMINI_REASONING_EFFORT);\n  const v = normalizeGeminiReasoningEffort(raw || DEFAULTS.geminiReasoningEffort);\n  _geminiReasoningCache = v;\n  _geminiReasoningCacheAt = now;\n  return v;\n}\n\nexport async function getOpenAIReasoningEffort() {\n  const now = nowMs();\n  if (_openaiReasoningCache && now - _openaiReasoningCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _openaiReasoningCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.OPENAI_REASONING_EFFORT);\n  const v = normalizeReasoningEffort(raw || DEFAULTS.openaiReasoningEffort);\n  _openaiReasoningCache = v;\n  _openaiReasoningCacheAt = now;\n  return v;\n}\n\nexport async function setModel(provider, model) {\n  const p = normalizeProvider(provider) === PROVIDERS.OPENAI ? PROVIDERS.OPENAI : PROVIDERS.GEMINI;\n  const v = String(model || \"\").trim();\n  if (!v) {\n    // Reset to default if emptied\n    const fallback = p === PROVIDERS.OPENAI ? DEFAULTS.openaiModel : DEFAULTS.geminiModel;\n    await rawSet(modelKey(p), fallback);\n    _modelCache[p] = fallback;\n    _modelCacheAt[p] = nowMs();\n    return;\n  }\n  await rawSet(modelKey(p), v);\n  _modelCache[p] = v;\n  _modelCacheAt[p] = nowMs();\n}\n\nexport async function setOpenAIReasoningEffort(value) {\n  const v = normalizeReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.OPENAI_REASONING_EFFORT, v);\n  _openaiReasoningCache = v;\n  _openaiReasoningCacheAt = nowMs();\n  return v;\n}\n\nexport async function setGeminiReasoningEffort(value) {\n  const v = normalizeGeminiReasoningEffort(value);\n  await rawSet(STORAGE_KEYS.GEMINI_REASONING_EFFORT, v);\n  _geminiReasoningCache = v;\n  _geminiReasoningCacheAt = nowMs();\n  return v;\n}\n\nexport async function getMaxOutputTokens() {\n  const now = nowMs();\n  if (_maxOutputTokensCache && now - _maxOutputTokensCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _maxOutputTokensCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.MAX_OUTPUT_TOKENS);\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  const v = clampInt(n, 1, 128000, DEFAULTS.maxOutputTokens);\n  _maxOutputTokensCache = v;\n  _maxOutputTokensCacheAt = now;\n  return v;\n}\n\nexport async function setMaxOutputTokens(value) {\n  const n = clampInt(value, 1, 128000, DEFAULTS.maxOutputTokens);\n  await rawSet(STORAGE_KEYS.MAX_OUTPUT_TOKENS, String(n));\n  _maxOutputTokensCache = n;\n  _maxOutputTokensCacheAt = nowMs();\n  return n;\n}\n\nconst CONCURRENCY_OPTIONS = [4, 8, 16, 32, 64, 128];\n\nfunction normalizeConcurrencyLimit(value) {\n  const base = clampInt(\n    value,\n    CONCURRENCY_OPTIONS[0],\n    CONCURRENCY_OPTIONS[CONCURRENCY_OPTIONS.length - 1],\n    DEFAULTS.concurrencyLimit\n  );\n  if (CONCURRENCY_OPTIONS.includes(base)) return base;\n  let best = CONCURRENCY_OPTIONS[0];\n  let bestDiff = Math.abs(base - best);\n  for (const option of CONCURRENCY_OPTIONS.slice(1)) {\n    const diff = Math.abs(base - option);\n    if (diff < bestDiff) {\n      best = option;\n      bestDiff = diff;\n    }\n  }\n  return best;\n}\n\nexport async function getConcurrencyLimit() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.CONCURRENCY_LIMIT);\n  return normalizeConcurrencyLimit(raw);\n}\n\nexport async function setConcurrencyLimit(value) {\n  const normalized = normalizeConcurrencyLimit(value);\n  await rawSet(STORAGE_KEYS.CONCURRENCY_LIMIT, String(normalized));\n  return normalized;\n}\n\nconst RPM_MIN = 0;\nconst RPM_MAX = 100000;\n\nfunction normalizeRpmLimit(value) {\n  const n = typeof value === \"string\" ? parseInt(value.trim(), 10) : Number(value);\n  return clampInt(n, RPM_MIN, RPM_MAX, DEFAULTS.rpmLimit);\n}\n\nexport async function getRpmLimit() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.RPM_LIMIT);\n  return normalizeRpmLimit(raw);\n}\n\nexport async function setRpmLimit(value) {\n  const normalized = normalizeRpmLimit(value);\n  await rawSet(STORAGE_KEYS.RPM_LIMIT, String(normalized));\n  return normalized;\n}\n\nexport async function getInterfaceMode() {\n  const now = nowMs();\n  if (_interfaceModeCache && now - _interfaceModeCacheAt < SETTINGS_CACHE_TTL_MS) {\n    return _interfaceModeCache;\n  }\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.INTERFACE_MODE);\n  const mode = normalizeInterfaceMode(raw);\n  _interfaceModeCache = mode;\n  _interfaceModeCacheAt = now;\n  return mode;\n}\n\nexport async function setInterfaceMode(mode) {\n  const normalized = normalizeInterfaceMode(mode);\n  await rawSet(STORAGE_KEYS.INTERFACE_MODE, normalized);\n  _interfaceModeCache = normalized;\n  _interfaceModeCacheAt = nowMs();\n  return normalized;\n}\n\nexport async function getOnboardingSeen() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_SEEN);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingSeen(seen = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_SEEN, seen ? \"1\" : \"0\");\n  return seen;\n}\n\nexport async function getOnboardingKeysConfirmed() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED);\n  return raw === \"1\";\n}\n\nexport async function setOnboardingKeysConfirmed(confirmed = true) {\n  await rawSet(STORAGE_KEYS.ONBOARDING_KEYS_CONFIRMED, confirmed ? \"1\" : \"0\");\n  return confirmed;\n}\n\nfunction normalizeRuntimeStatus(raw) {\n  const base = { active: 0, queued: 0, rpm: 0, ts: 0 };\n  if (!raw || typeof raw !== \"object\") return base;\n  const active = clampInt(raw.active, 0, 100000, 0);\n  const queued = clampInt(raw.queued, 0, 100000, 0);\n  const rpm = clampInt(raw.rpm, 0, 1000000, 0);\n  const ts = clampInt(raw.ts, 0, Number.MAX_SAFE_INTEGER, 0);\n  return { active, queued, rpm, ts };\n}\n\nexport async function getRuntimeStatus() {\n  const raw = await rawGet(STORAGE_KEYS.RUNTIME_STATUS);\n  if (!raw) return normalizeRuntimeStatus(null);\n  try {\n    return normalizeRuntimeStatus(JSON.parse(raw));\n  } catch {\n    return normalizeRuntimeStatus(null);\n  }\n}\n\nexport async function setRuntimeStatus(status) {\n  const normalized = normalizeRuntimeStatus(status);\n  await rawSet(STORAGE_KEYS.RUNTIME_STATUS, JSON.stringify(normalized));\n  return normalized;\n}\n\nconst PRIVACY_MODE_CACHE_TTL_MS = 2000;\n\nasync function loadPrivacyMode() {\n  const now = nowMs();\n  if (_privacyModeCache != null && now - _privacyModeCacheAt < PRIVACY_MODE_CACHE_TTL_MS) {\n    return _privacyModeCache;\n  }\n  const raw = await rawGet(STORAGE_KEYS.PRIVACY_MODE);\n  const enabled = raw === \"1\";\n  _privacyModeCache = enabled;\n  _privacyModeCacheAt = now;\n  return enabled;\n}\n\nexport async function getPrivacyMode() {\n  return await loadPrivacyMode();\n}\n\nexport async function setPrivacyMode(enabled = false) {\n  const next = !!enabled;\n  _privacyModeCache = next;\n  _privacyModeCacheAt = nowMs();\n  await rawSet(STORAGE_KEYS.PRIVACY_MODE, next ? \"1\" : \"0\");\n  return next;\n}\n\nfunction normalizeSectionList(value) {\n  if (!Array.isArray(value)) return [];\n  const out = [];\n  const seen = new Set();\n  for (const item of value) {\n    const key = String(item || \"\").trim();\n    if (!key || seen.has(key)) continue;\n    seen.add(key);\n    out.push(key);\n  }\n  return out;\n}\n\nexport async function getSectionOrder() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_ORDER);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setSectionOrder(order) {\n  const normalized = normalizeSectionList(order);\n  await rawSet(STORAGE_KEYS.SECTION_ORDER, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getHiddenSections() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.SECTION_HIDDEN);\n  if (!raw) return [];\n  try {\n    return normalizeSectionList(JSON.parse(raw));\n  } catch {\n    return [];\n  }\n}\n\nexport async function setHiddenSections(list) {\n  const normalized = normalizeSectionList(list);\n  await rawSet(STORAGE_KEYS.SECTION_HIDDEN, JSON.stringify(normalized));\n  return normalized;\n}\n\nexport async function getLicense() {\n  await ensureMigrated();\n  const raw = await rawGet(STORAGE_KEYS.LICENSE);\n  if (!raw) return null;\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return null;\n  }\n}\n\nexport async function setLicense(license) {\n  if (!license) {\n    await rawRemove(STORAGE_KEYS.LICENSE);\n    return null;\n  }\n  await rawSet(STORAGE_KEYS.LICENSE, JSON.stringify(license));\n  return license;\n}\n\nexport async function clearLicense() {\n  await rawRemove(STORAGE_KEYS.LICENSE);\n}\n\n// ---------- Small utilities ----------\nexport function nowMs() {\n  return Date.now();\n}\n\nexport function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function clamp(value, min, max, fallback = min) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nexport function clampInt(value, min, max, fallback = min) {\n  const n = parseInt(String(value), 10);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(min, Math.min(max, n));\n}\n\nconst REDACT_PATTERNS = [\n  /\\bsk-[A-Za-z0-9-_]{1,}\\b/gi,\n  /\\bAIza[0-9A-Za-z_-]{1,}\\b/gi,\n  /\\b[A-Z0-9]{4}(?:-[A-Z0-9]{4}){1,3}\\b/gi\n];\n\nexport function redactSensitiveText(value) {\n  if (value == null) return \"\";\n  let text = String(value);\n  for (const pattern of REDACT_PATTERNS) {\n    text = text.replace(pattern, \"[REDACTED]\");\n  }\n  return text;\n}\n\nexport function redactSensitiveValue(value) {\n  if (value == null) return value;\n  if (typeof value === \"string\") return redactSensitiveText(value);\n  if (Array.isArray(value)) return value.map(redactSensitiveValue);\n  if (typeof value === \"object\") {\n    const out = {};\n    for (const [key, entry] of Object.entries(value)) {\n      out[key] = redactSensitiveValue(entry);\n    }\n    return out;\n  }\n  return value;\n}\n\nfunction parseTimestampMs(raw) {\n  const n = parseInt(String(raw || \"\").trim(), 10);\n  return Number.isFinite(n) && n > 0 ? n : 0;\n}\n\n// ---------- LRU cache with TTL ----------\nexport class LRUCache {\n  constructor(maxEntries = 500) {\n    this.maxEntries = maxEntries;\n    this.map = new Map(); // key => {value, expiresAtMs}\n  }\n\n  get(key) {\n    if (!this.map.has(key)) return null;\n    const entry = this.map.get(key);\n\n    if (entry?.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      this.map.delete(key);\n      return null;\n    }\n\n    // Refresh key order (most recent)\n    this.map.delete(key);\n    this.map.set(key, entry);\n    return entry.value;\n  }\n\n  set(key, value, ttlMs) {\n    const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? nowMs() + ttlMs : null;\n    if (this.map.has(key)) this.map.delete(key);\n    this.map.set(key, { value, expiresAtMs });\n\n    // Evict LRU\n    while (this.map.size > this.maxEntries) {\n      const oldestKey = this.map.keys().next().value;\n      this.map.delete(oldestKey);\n    }\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\n// ---------- Persistent cache (survives reloads) ----------\nconst CACHE_ENTRY_PREFIX = \"AI_CACHE_ENTRY_V1:\";\nconst CACHE_INDEX_MAX_ENTRIES = 5000;\nconst CACHE_INDEX_MAX_BYTES = 5 * 1024 * 1024;\nlet _cacheClearMs = 0;\n\nfunction estimateSizeBytes(value) {\n  if (typeof value !== \"string\") return 0;\n  try {\n    if (typeof TextEncoder !== \"undefined\") {\n      return new TextEncoder().encode(value).length;\n    }\n  } catch {\n    // ignore and fallback\n  }\n  return value.length;\n}\n\nasync function syncCacheClearMarker() {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.CACHE_CLEAR_AT));\n  if (clearedAt > _cacheClearMs) _cacheClearMs = clearedAt;\n  return _cacheClearMs;\n}\n\nexport async function getCacheClearAt() {\n  return await syncCacheClearMarker();\n}\n\nasync function loadCacheIndex() {\n  const raw = await rawGet(STORAGE_KEYS.CACHE_INDEX);\n  if (!raw) return [];\n  try {\n    const arr = JSON.parse(raw);\n    return Array.isArray(arr) ? arr : [];\n  } catch {\n    return [];\n  }\n}\n\nasync function saveCacheIndex(entries) {\n  try {\n    await rawSet(STORAGE_KEYS.CACHE_INDEX, JSON.stringify(entries));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneCacheIndex(entries, clearedAt = 0) {\n  const now = nowMs();\n  const kept = [];\n  const removedKeys = [];\n\n  for (const entry of entries || []) {\n    if (!entry || !entry.key) continue;\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= now) {\n      removedKeys.push(entry.key);\n      continue;\n    }\n    kept.push(entry);\n  }\n\n  let totalSize = 0;\n  for (const entry of kept) totalSize += Number(entry?.size || 0);\n\n  if (kept.length > CACHE_INDEX_MAX_ENTRIES || totalSize > CACHE_INDEX_MAX_BYTES) {\n    kept.sort((a, b) => (a.savedAtMs || 0) - (b.savedAtMs || 0));\n    let dropCount = 0;\n    while (kept.length - dropCount > CACHE_INDEX_MAX_ENTRIES || totalSize > CACHE_INDEX_MAX_BYTES) {\n      const entry = kept[dropCount];\n      if (!entry) break;\n      removedKeys.push(entry.key);\n      totalSize -= Number(entry?.size || 0);\n      dropCount += 1;\n    }\n    return { list: kept.slice(dropCount), removedKeys };\n  }\n\n  return { list: kept, removedKeys };\n}\n\nasync function removeCacheEntry(key) {\n  if (!key) return;\n  await rawRemove(CACHE_ENTRY_PREFIX + key);\n}\n\nasync function removeFromCacheIndex(key) {\n  const index = await loadCacheIndex();\n  const next = (index || []).filter((item) => item?.key !== key);\n  if (next.length !== index.length) await saveCacheIndex(next);\n}\n\nexport async function getPersistentCache(cacheKey) {\n  if (!cacheKey) return null;\n  if (await getPrivacyMode()) return null;\n  const clearedAt = await syncCacheClearMarker();\n  const raw = await rawGet(CACHE_ENTRY_PREFIX + cacheKey);\n  if (!raw) {\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n\n  try {\n    const entry = JSON.parse(raw);\n    if (!entry || typeof entry !== \"object\") throw new Error(\"Invalid entry\");\n    const savedAt = Number(entry.savedAtMs || 0);\n    if (clearedAt && (!Number.isFinite(savedAt) || savedAt <= clearedAt)) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    if (entry.expiresAtMs && entry.expiresAtMs <= nowMs()) {\n      await removeCacheEntry(cacheKey);\n      await removeFromCacheIndex(cacheKey);\n      return null;\n    }\n    return entry.value || null;\n  } catch {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return null;\n  }\n}\n\nexport async function setPersistentCache(cacheKey, value, ttlMs, meta = {}) {\n  if (!cacheKey) return;\n  if (await getPrivacyMode()) return;\n  const now = nowMs();\n  const clearedAt = await syncCacheClearMarker();\n  const savedAtMs = clearedAt && now <= clearedAt ? clearedAt + 1 : now;\n  const expiresAtMs = typeof ttlMs === \"number\" && ttlMs > 0 ? savedAtMs + ttlMs : null;\n  const entry = {\n    v: 1,\n    savedAtMs,\n    expiresAtMs,\n    value\n  };\n\n  const raw = JSON.stringify(entry);\n  const size = estimateSizeBytes(raw);\n  if (size > CACHE_INDEX_MAX_BYTES) {\n    await removeCacheEntry(cacheKey);\n    await removeFromCacheIndex(cacheKey);\n    return;\n  }\n  await rawSet(CACHE_ENTRY_PREFIX + cacheKey, raw);\n\n  const index = await loadCacheIndex();\n  const provider = meta.provider || value?.provider || \"\";\n  const model = meta.model || value?.model || \"\";\n\n  let updated = false;\n  const next = (index || []).map((item) => {\n    if (item?.key !== cacheKey) return item;\n    updated = true;\n    return {\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    };\n  });\n\n  if (!updated) {\n    next.push({\n      key: cacheKey,\n      provider,\n      model,\n      size,\n      savedAtMs,\n      expiresAtMs\n    });\n  }\n\n  const pruned = pruneCacheIndex(next, clearedAt);\n  for (const key of pruned.removedKeys) await removeCacheEntry(key);\n  await saveCacheIndex(pruned.list);\n}\n\nexport async function clearPersistentCache() {\n  const clearedAt = nowMs();\n  _cacheClearMs = clearedAt;\n  await rawSet(STORAGE_KEYS.CACHE_CLEAR_AT, String(clearedAt));\n  const index = await loadCacheIndex();\n  for (const item of index || []) {\n    if (!item?.key) continue;\n    await removeCacheEntry(item.key);\n  }\n  await rawRemove(STORAGE_KEYS.CACHE_INDEX);\n}\n\nexport async function getPersistentCacheStats() {\n  if (await getPrivacyMode()) {\n    return {\n      entries: 0,\n      sizeBytes: 0,\n      providers: {\n        gemini: { entries: 0, sizeBytes: 0 },\n        openai: { entries: 0, sizeBytes: 0 }\n      },\n      oldestMs: null,\n      newestMs: null\n    };\n  }\n  const index = await loadCacheIndex();\n  const clearedAt = await syncCacheClearMarker();\n  const pruned = pruneCacheIndex(index, clearedAt);\n  if (pruned.removedKeys.length) {\n    for (const key of pruned.removedKeys) await removeCacheEntry(key);\n    await saveCacheIndex(pruned.list);\n  }\n\n  const stats = {\n    entries: 0,\n    sizeBytes: 0,\n    providers: {\n      gemini: { entries: 0, sizeBytes: 0 },\n      openai: { entries: 0, sizeBytes: 0 }\n    },\n    oldestMs: null,\n    newestMs: null\n  };\n\n  for (const item of pruned.list || []) {\n    if (!item?.key) continue;\n    stats.entries += 1;\n    stats.sizeBytes += Number(item.size || 0);\n    const provider = String(item.provider || \"\").toLowerCase();\n    if (provider === PROVIDERS.GEMINI) {\n      stats.providers.gemini.entries += 1;\n      stats.providers.gemini.sizeBytes += Number(item.size || 0);\n    } else if (provider === PROVIDERS.OPENAI) {\n      stats.providers.openai.entries += 1;\n      stats.providers.openai.sizeBytes += Number(item.size || 0);\n    }\n\n    const savedAt = Number(item.savedAtMs || 0);\n    if (savedAt) {\n      stats.oldestMs = stats.oldestMs == null ? savedAt : Math.min(stats.oldestMs, savedAt);\n      stats.newestMs = stats.newestMs == null ? savedAt : Math.max(stats.newestMs, savedAt);\n    }\n  }\n\n  return stats;\n}\n\n// ---------- Stable stringify + hashing (for cache keys) ----------\nfunction isPlainObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\n\nexport function stableStringify(value) {\n  return JSON.stringify(sortKeysDeep(value));\n}\n\nfunction sortKeysDeep(value) {\n  if (Array.isArray(value)) return value.map(sortKeysDeep);\n  if (isPlainObject(value)) {\n    const out = {};\n    for (const k of Object.keys(value).sort()) out[k] = sortKeysDeep(value[k]);\n    return out;\n  }\n  return value;\n}\n\nfunction fnv1a32(str) {\n  let h = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  // Unsigned\n  return (h >>> 0).toString(16).padStart(8, \"0\");\n}\n\nexport async function hashKey(input) {\n  const text = typeof input === \"string\" ? input : stableStringify(input);\n\n  // Prefer SHA-256 when available (browser/Office runtime)\n  try {\n    if (typeof crypto !== \"undefined\" && crypto?.subtle?.digest && typeof TextEncoder !== \"undefined\") {\n      const enc = new TextEncoder();\n      const bytes = enc.encode(text);\n      const digest = await crypto.subtle.digest(\"SHA-256\", bytes);\n      const arr = Array.from(new Uint8Array(digest));\n      return arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n  } catch {\n    // ignore and fallback\n  }\n\n  return `fnv1a:${fnv1a32(text)}`;\n}\n\n// ---------- Lightweight diagnostics log (persisted) ----------\nconst REQUEST_LOG_MAX_PER_TYPE = 50;\nconst REQUEST_LOG_MAX_TOTAL = REQUEST_LOG_MAX_PER_TYPE * 2;\nconst REQUEST_LOG_TTL_MS = Infinity; // Kept until manual reset (capped by count)\nconst LOG_FLUSH_INTERVAL_MS = 500;\nconst LOG_FLUSH_MAX_BUFFER = 80;\nlet _requestLog = [];\nlet _requestLogLoading = null;\nlet _requestLogLoaded = false;\nlet _requestLogLastLoadedMs = 0;\nlet _requestLogClearMs = 0;\nlet _logBuffer = [];\nlet _logFlushTimer = null;\nlet _logFlushPromise = null;\nconst USAGE_TOTALS_CACHE_TTL_MS = 1500;\nconst BATCH_APPLIED_MAX = 80;\nconst BATCH_APPLIED_TTL_MS = 24 * 60 * 60 * 1000;\nlet _usageTotals = createEmptyUsageTotals();\nlet _usageTotalsLoading = null;\nlet _usageTotalsLoaded = false;\nlet _usageTotalsLastLoadedMs = 0;\nlet _usageTotalsDirty = false;\n\nasync function syncRequestLogClearMarker(options = {}) {\n  const clearedAt = parseTimestampMs(await rawGet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT));\n  if (clearedAt > _requestLogClearMs) {\n    _requestLogClearMs = clearedAt;\n    _requestLog = [];\n    if (options.reset) {\n      _requestLogLoaded = true;\n      _requestLogLoading = null;\n      _requestLogLastLoadedMs = nowMs();\n    } else {\n      _requestLogLoaded = false;\n    }\n  }\n  return _requestLogClearMs;\n}\n\nfunction coerceRequestLogArray(value) {\n  if (Array.isArray(value)) return value;\n  if (value && typeof value === \"object\") {\n    const normal = Array.isArray(value.normal) ? value.normal : [];\n    const errors = Array.isArray(value.errors) ? value.errors : [];\n    return normal.concat(errors);\n  }\n  return [];\n}\n\nfunction isErrorLogEntry(entry) {\n  return !!entry && entry.ok === false;\n}\n\nasync function loadRequestLog(force = false) {\n  if (_requestLogLoading) return _requestLogLoading;\n\n  _requestLogLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_requestLogLoaded) {\n        _requestLogLoaded = true;\n        _requestLogLastLoadedMs = nowMs();\n      }\n      return _requestLog;\n    }\n    const clearedAt = await syncRequestLogClearMarker();\n    if (!force && _requestLogLoaded) return _requestLog;\n    const raw = await rawGet(STORAGE_KEYS.REQUEST_LOG);\n    let arr = [];\n    if (raw) {\n      try {\n        const parsed = JSON.parse(raw);\n        arr = coerceRequestLogArray(parsed);\n      } catch {\n        arr = [];\n      }\n    }\n    const now = nowMs();\n    arr = arr\n      .map((e) => {\n        if (!e) return null;\n        let ts = e.ts;\n        if (typeof ts === \"string\") {\n          const parsed = Date.parse(ts);\n          if (Number.isFinite(parsed)) ts = parsed;\n        }\n        if (typeof ts !== \"number\") return null;\n        return { ...e, ts };\n      })\n      .filter((e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS)\n      .map((e) => sanitizeLogEntry(e));\n    _requestLog = arr;\n    pruneRequestLog();\n    _requestLogLoaded = true;\n    _requestLogLastLoadedMs = nowMs();\n    return _requestLog;\n  })();\n\n  try {\n    return await _requestLogLoading;\n  } finally {\n    _requestLogLoading = null;\n  }\n}\n\nasync function persistRequestLog() {\n  try {\n    if (await getPrivacyMode()) return;\n    pruneRequestLog();\n    await rawSet(STORAGE_KEYS.REQUEST_LOG, JSON.stringify(_requestLog.slice(-REQUEST_LOG_MAX_TOTAL)));\n  } catch {\n    // ignore\n  }\n}\n\nfunction pruneRequestLog() {\n  const now = nowMs();\n  const clearedAt = _requestLogClearMs || 0;\n  const valid = (_requestLog || []).filter(\n    (e) => e && typeof e.ts === \"number\" && e.ts > clearedAt && now - e.ts <= REQUEST_LOG_TTL_MS\n  );\n  const normals = [];\n  const errors = [];\n  for (const entry of valid) {\n    if (isErrorLogEntry(entry)) errors.push(entry);\n    else normals.push(entry);\n  }\n  normals.sort((a, b) => a.ts - b.ts);\n  errors.sort((a, b) => a.ts - b.ts);\n  const pruned = normals.slice(-REQUEST_LOG_MAX_PER_TYPE).concat(errors.slice(-REQUEST_LOG_MAX_PER_TYPE));\n  pruned.sort((a, b) => a.ts - b.ts);\n  _requestLog = pruned;\n}\n\n// ---------- Persistent usage totals ----------\nfunction toNonNegInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nfunction toNonNegNumber(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return n;\n}\n\nfunction createEmptyUsageTotals() {\n  return {\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    cacheStorageTokenHours: 0,\n    requests: 0,\n    batchApplied: {},\n    byProvider: {\n      [PROVIDERS.GEMINI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0,\n        models: {}\n      },\n      [PROVIDERS.OPENAI]: {\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0,\n        models: {}\n      }\n    }\n  };\n}\n\nfunction normalizeUsageTotals(raw) {\n  const base = createEmptyUsageTotals();\n  if (!raw || typeof raw !== \"object\") return base;\n\n  base.inputTokens = toNonNegInt(raw.inputTokens);\n  base.outputTokens = toNonNegInt(raw.outputTokens);\n  base.reasoningTokens = toNonNegInt(raw.reasoningTokens);\n  base.cachedInputTokens = toNonNegInt(raw.cachedInputTokens);\n  base.cacheStorageTokenHours = toNonNegNumber(raw.cacheStorageTokenHours);\n  base.requests = toNonNegInt(raw.requests);\n  base.batchApplied = normalizeBatchApplied(raw.batchApplied);\n\n  const providers = raw.byProvider && typeof raw.byProvider === \"object\" ? raw.byProvider : {};\n  for (const provider of [PROVIDERS.GEMINI, PROVIDERS.OPENAI]) {\n    const rawProvider = providers[provider];\n    if (!rawProvider || typeof rawProvider !== \"object\") continue;\n    const target = base.byProvider[provider];\n    target.inputTokens = toNonNegInt(rawProvider.inputTokens);\n    target.outputTokens = toNonNegInt(rawProvider.outputTokens);\n    target.reasoningTokens = toNonNegInt(rawProvider.reasoningTokens);\n    target.cachedInputTokens = toNonNegInt(rawProvider.cachedInputTokens);\n    target.cacheStorageTokenHours = toNonNegNumber(rawProvider.cacheStorageTokenHours);\n    target.requests = toNonNegInt(rawProvider.requests);\n\n    const rawModels = rawProvider.models && typeof rawProvider.models === \"object\" ? rawProvider.models : {};\n    for (const [key, value] of Object.entries(rawModels)) {\n      if (!value || typeof value !== \"object\") continue;\n      const label = typeof value.label === \"string\" ? value.label : String(key || \"\");\n      const modelKey = String(key || label || \"\").toLowerCase();\n      if (!modelKey) continue;\n      target.models[modelKey] = {\n        label,\n        inputTokens: toNonNegInt(value.inputTokens),\n        outputTokens: toNonNegInt(value.outputTokens),\n        reasoningTokens: toNonNegInt(value.reasoningTokens),\n        cachedInputTokens: toNonNegInt(value.cachedInputTokens),\n        cacheStorageTokenHours: toNonNegNumber(value.cacheStorageTokenHours),\n        requests: toNonNegInt(value.requests)\n      };\n    }\n  }\n\n  return base;\n}\n\nfunction normalizeBatchApplied(raw) {\n  if (!raw || typeof raw !== \"object\") return {};\n  const out = {};\n  for (const [batchId, value] of Object.entries(raw)) {\n    if (!value || typeof value !== \"object\") continue;\n    const models = value.models && typeof value.models === \"object\" ? value.models : {};\n    const normalizedModels = {};\n    for (const [key, model] of Object.entries(models)) {\n      if (!model || typeof model !== \"object\") continue;\n      const provider = String(model.provider || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      const modelKey = String(model.modelKey || model.model || key || \"\").toLowerCase();\n      if (!modelKey) continue;\n      normalizedModels[key] = {\n        provider,\n        modelKey,\n        label: typeof model.label === \"string\" ? model.label : \"\",\n        inputTokens: toNonNegInt(model.inputTokens),\n        outputTokens: toNonNegInt(model.outputTokens),\n        reasoningTokens: toNonNegInt(model.reasoningTokens),\n        cachedInputTokens: toNonNegInt(model.cachedInputTokens),\n        cacheStorageTokenHours: toNonNegNumber(model.cacheStorageTokenHours),\n        requests: toNonNegInt(model.requests)\n      };\n    }\n    out[batchId] = {\n      ts: Number(value.ts) || 0,\n      models: normalizedModels\n    };\n  }\n  return pruneBatchApplied(out);\n}\n\nfunction pruneBatchApplied(map) {\n  if (!map || typeof map !== \"object\") return {};\n  const now = nowMs();\n  const entries = Object.entries(map)\n    .filter(([, value]) => value && typeof value === \"object\")\n    .filter(([, value]) => {\n      const ts = Number(value.ts) || 0;\n      return !ts || now - ts <= BATCH_APPLIED_TTL_MS;\n    })\n    .sort((a, b) => (Number(a[1].ts) || 0) - (Number(b[1].ts) || 0));\n  const trimmed = entries.slice(-BATCH_APPLIED_MAX);\n  const out = {};\n  for (const [key, value] of trimmed) {\n    out[key] = value;\n  }\n  return out;\n}\n\nfunction cloneUsageTotals(value) {\n  try {\n    return JSON.parse(JSON.stringify(value || createEmptyUsageTotals()));\n  } catch {\n    return createEmptyUsageTotals();\n  }\n}\n\nasync function loadUsageTotals(force = false) {\n  if (_usageTotalsLoading) return _usageTotalsLoading;\n\n  _usageTotalsLoading = (async () => {\n    const privacyMode = await getPrivacyMode();\n    if (privacyMode) {\n      if (force || !_usageTotalsLoaded) {\n        _usageTotalsLoaded = true;\n        _usageTotalsLastLoadedMs = nowMs();\n      }\n      return _usageTotals;\n    }\n\n    if (!force && _usageTotalsLoaded) return _usageTotals;\n\n    const raw = await rawGet(STORAGE_KEYS.USAGE_TOTALS);\n    let parsed = null;\n    if (raw) {\n      try {\n        parsed = JSON.parse(raw);\n      } catch {\n        parsed = null;\n      }\n    }\n\n    _usageTotals = normalizeUsageTotals(parsed);\n    _usageTotalsLoaded = true;\n    _usageTotalsLastLoadedMs = nowMs();\n    return _usageTotals;\n  })();\n\n  try {\n    return await _usageTotalsLoading;\n  } finally {\n    _usageTotalsLoading = null;\n  }\n}\n\nasync function persistUsageTotals() {\n  try {\n    if (await getPrivacyMode()) return;\n    await rawSet(STORAGE_KEYS.USAGE_TOTALS, JSON.stringify(_usageTotals));\n  } catch {\n    // ignore\n  }\n}\n\nfunction applyUsageTotalsFromEntry(entry) {\n  if (!entry || typeof entry !== \"object\") return false;\n\n  if (entry.batch && Array.isArray(entry.batchModels)) {\n    const batchId = entry.batchId ? String(entry.batchId) : \"\";\n    const now = nowMs();\n    const currentModels = {};\n    for (const item of entry.batchModels) {\n      if (!item || typeof item !== \"object\") continue;\n      const provider = String(item.provider || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      const modelLabel = String(item.model || \"\").trim();\n      const modelKey = (modelLabel || \"unknown\").toLowerCase();\n      const mapKey = `${provider}|${modelKey}`;\n      const existing = currentModels[mapKey] || {\n        provider,\n        modelKey,\n        label: modelLabel,\n        inputTokens: 0,\n        outputTokens: 0,\n        reasoningTokens: 0,\n        cachedInputTokens: 0,\n        cacheStorageTokenHours: 0,\n        requests: 0\n      };\n      existing.inputTokens += toNonNegInt(item.inputTokens);\n      existing.outputTokens += toNonNegInt(item.outputTokens);\n      existing.reasoningTokens += toNonNegInt(item.reasoningTokens);\n      existing.cachedInputTokens += toNonNegInt(item.cachedInputTokens);\n      existing.cacheStorageTokenHours += toNonNegNumber(item.cacheStorageTokenHours);\n      existing.requests += toNonNegInt(item.requests);\n      if (!existing.label && modelLabel) existing.label = modelLabel;\n      currentModels[mapKey] = existing;\n    }\n\n    if (!batchId) {\n      let touched = false;\n      for (const model of Object.values(currentModels)) {\n        if (applyUsageDelta(model.provider, model.modelKey, model.label, model)) touched = true;\n      }\n      return touched;\n    }\n\n    const batchApplied = _usageTotals.batchApplied || {};\n    const previous = batchApplied[batchId]?.models || {};\n    const keys = new Set([...Object.keys(previous), ...Object.keys(currentModels)]);\n    let touched = false;\n    for (const key of keys) {\n      const curr = currentModels[key] || null;\n      const prev = previous[key] || null;\n      if (!curr && !prev) continue;\n      const provider = (curr?.provider || prev?.provider || \"\").toLowerCase();\n      const modelKey = (curr?.modelKey || prev?.modelKey || \"\").toLowerCase();\n      if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) continue;\n      if (!modelKey) continue;\n      const delta = {\n        inputTokens: (curr?.inputTokens || 0) - (prev?.inputTokens || 0),\n        outputTokens: (curr?.outputTokens || 0) - (prev?.outputTokens || 0),\n        reasoningTokens: (curr?.reasoningTokens || 0) - (prev?.reasoningTokens || 0),\n        cachedInputTokens: (curr?.cachedInputTokens || 0) - (prev?.cachedInputTokens || 0),\n        cacheStorageTokenHours: (curr?.cacheStorageTokenHours || 0) - (prev?.cacheStorageTokenHours || 0),\n        requests: (curr?.requests || 0) - (prev?.requests || 0),\n        label: curr?.label || prev?.label || \"\"\n      };\n      if (!hasUsageDelta(delta)) continue;\n      if (applyUsageDelta(provider, modelKey, delta.label, delta)) touched = true;\n    }\n\n    batchApplied[batchId] = { ts: Number(entry.ts) || now, models: currentModels };\n    _usageTotals.batchApplied = pruneBatchApplied(batchApplied);\n    return touched;\n  }\n\n  const inputTokens = toNonNegInt(entry.inputTokens);\n  const outputTokens = toNonNegInt(entry.outputTokens);\n  const reasoningTokens = toNonNegInt(entry.reasoningTokens);\n  const cachedInputTokens = toNonNegInt(entry.cachedInputTokens);\n  const cacheStorageTokenHours = toNonNegNumber(entry.cacheStorageTokenHours);\n  const hasUsage = inputTokens + outputTokens + reasoningTokens + cachedInputTokens > 0 || cacheStorageTokenHours > 0;\n  if (!hasUsage) return false;\n\n  const provider = String(entry.provider || \"\").toLowerCase();\n  if (provider !== PROVIDERS.GEMINI && provider !== PROVIDERS.OPENAI) return false;\n\n  const modelLabel = String(entry.model || \"\").trim();\n  const modelKey = (modelLabel || \"unknown\").toLowerCase();\n\n  return applyUsageDelta(provider, modelKey, modelLabel, {\n    inputTokens,\n    outputTokens,\n    reasoningTokens,\n    cachedInputTokens,\n    cacheStorageTokenHours,\n    requests: 1\n  });\n}\n\nfunction hasUsageDelta(delta) {\n  return (\n    Number(delta?.inputTokens || 0) !== 0 ||\n    Number(delta?.outputTokens || 0) !== 0 ||\n    Number(delta?.reasoningTokens || 0) !== 0 ||\n    Number(delta?.cachedInputTokens || 0) !== 0 ||\n    Number(delta?.cacheStorageTokenHours || 0) !== 0 ||\n    Number(delta?.requests || 0) !== 0\n  );\n}\n\nfunction applyUsageDelta(provider, modelKey, modelLabel, delta) {\n  if (!delta) return false;\n  const inputTokens = Number(delta.inputTokens || 0);\n  const outputTokens = Number(delta.outputTokens || 0);\n  const reasoningTokens = Number(delta.reasoningTokens || 0);\n  const cachedInputTokens = Number(delta.cachedInputTokens || 0);\n  const cacheStorageTokenHours = Number(delta.cacheStorageTokenHours || 0);\n  const requests = Number(delta.requests || 0);\n  const hasUsage = inputTokens || outputTokens || reasoningTokens || cachedInputTokens || cacheStorageTokenHours || requests;\n  if (!hasUsage) return false;\n\n  _usageTotals.inputTokens = Math.max(0, _usageTotals.inputTokens + inputTokens);\n  _usageTotals.outputTokens = Math.max(0, _usageTotals.outputTokens + outputTokens);\n  _usageTotals.reasoningTokens = Math.max(0, _usageTotals.reasoningTokens + reasoningTokens);\n  _usageTotals.cachedInputTokens = Math.max(0, _usageTotals.cachedInputTokens + cachedInputTokens);\n  _usageTotals.cacheStorageTokenHours = Math.max(0, _usageTotals.cacheStorageTokenHours + cacheStorageTokenHours);\n  _usageTotals.requests = Math.max(0, _usageTotals.requests + requests);\n\n  const providerTotals = _usageTotals.byProvider[provider];\n  providerTotals.inputTokens = Math.max(0, providerTotals.inputTokens + inputTokens);\n  providerTotals.outputTokens = Math.max(0, providerTotals.outputTokens + outputTokens);\n  providerTotals.reasoningTokens = Math.max(0, providerTotals.reasoningTokens + reasoningTokens);\n  providerTotals.cachedInputTokens = Math.max(0, providerTotals.cachedInputTokens + cachedInputTokens);\n  providerTotals.cacheStorageTokenHours = Math.max(0, providerTotals.cacheStorageTokenHours + cacheStorageTokenHours);\n  providerTotals.requests = Math.max(0, providerTotals.requests + requests);\n\n  const models = providerTotals.models || {};\n  const existing = models[modelKey] || {\n    label: modelLabel,\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    cacheStorageTokenHours: 0,\n    requests: 0\n  };\n  if (!existing.label && modelLabel) existing.label = modelLabel;\n  existing.inputTokens = Math.max(0, existing.inputTokens + inputTokens);\n  existing.outputTokens = Math.max(0, existing.outputTokens + outputTokens);\n  existing.reasoningTokens = Math.max(0, existing.reasoningTokens + reasoningTokens);\n  existing.cachedInputTokens = Math.max(0, existing.cachedInputTokens + cachedInputTokens);\n  existing.cacheStorageTokenHours = Math.max(0, existing.cacheStorageTokenHours + cacheStorageTokenHours);\n  existing.requests = Math.max(0, existing.requests + requests);\n  models[modelKey] = existing;\n  providerTotals.models = models;\n  return true;\n}\n\nexport async function getUsageTotals(options = {}) {\n  if (_logBuffer.length) {\n    await flushLogBuffer();\n  }\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_usageTotalsLoaded || now - _usageTotalsLastLoadedMs > USAGE_TOTALS_CACHE_TTL_MS) {\n    await loadUsageTotals(true);\n  } else {\n    await loadUsageTotals(false);\n  }\n  return cloneUsageTotals(_usageTotals);\n}\n\nexport async function clearUsageTotals() {\n  _usageTotals = createEmptyUsageTotals();\n  _usageTotalsLoaded = true;\n  _usageTotalsLoading = null;\n  _usageTotalsLastLoadedMs = nowMs();\n  _usageTotalsDirty = false;\n  await rawRemove(STORAGE_KEYS.USAGE_TOTALS);\n}\n\nexport function logRequest(entry) {\n  if (!entry || typeof entry !== \"object\") return;\n  const logEntry = sanitizeLogEntry({ ts: nowMs(), ...entry });\n  if (logEntry.batch && logEntry.batchId) {\n    let replaced = false;\n    for (let i = _logBuffer.length - 1; i >= 0; i -= 1) {\n      const existing = _logBuffer[i];\n      if (existing && existing.batch && existing.batchId === logEntry.batchId) {\n        _logBuffer[i] = logEntry;\n        replaced = true;\n        break;\n      }\n    }\n    if (!replaced) _logBuffer.push(logEntry);\n  } else {\n    _logBuffer.push(logEntry);\n  }\n\n  if (_logBuffer.length >= LOG_FLUSH_MAX_BUFFER) {\n    void flushLogBuffer();\n    return;\n  }\n\n  if (_logFlushTimer) return;\n  _logFlushTimer = setTimeout(() => {\n    _logFlushTimer = null;\n    void flushLogBuffer();\n  }, LOG_FLUSH_INTERVAL_MS);\n}\nasync function flushLogBuffer() {\n  if (_logFlushPromise) return _logFlushPromise;\n  if (!_logBuffer.length) return;\n\n  _logFlushPromise = (async () => {\n    try {\n      const entries = _logBuffer;\n      _logBuffer = [];\n\n      if (!entries.length) return;\n\n      await loadUsageTotals();\n      let usageTouched = false;\n      for (const entry of entries) {\n        if (applyUsageTotalsFromEntry(entry)) usageTouched = true;\n      }\n      if (usageTouched) {\n        _usageTotalsLastLoadedMs = nowMs();\n        _usageTotalsDirty = true;\n      }\n\n      const privacyMode = await getPrivacyMode();\n      if (privacyMode) {\n        _requestLog.push(...entries);\n        pruneRequestLog();\n        _requestLogLoaded = true;\n        _requestLogLastLoadedMs = nowMs();\n        return;\n      }\n\n      await syncRequestLogClearMarker({ reset: true });\n      if (!_requestLogLoaded) {\n        await loadRequestLog();\n      }\n      for (const entry of entries) {\n        if (entry?.batch && entry?.batchId) {\n          const idx = _requestLog.findIndex((e) => e?.batch && e?.batchId === entry.batchId);\n          if (idx >= 0) _requestLog[idx] = entry;\n          else _requestLog.push(entry);\n        } else {\n          _requestLog.push(entry);\n        }\n      }\n      pruneRequestLog();\n      _requestLogLastLoadedMs = nowMs();\n      await persistRequestLog();\n\n      if (_usageTotalsDirty) {\n        await persistUsageTotals();\n        _usageTotalsDirty = false;\n      }\n    } catch {\n      // ignore\n    }\n  })();\n\n  try {\n    await _logFlushPromise;\n  } finally {\n    _logFlushPromise = null;\n  }\n}\n\nfunction sanitizeLogEntry(entry) {\n  if (!entry || typeof entry !== \"object\") return entry;\n  return redactSensitiveValue(entry);\n}\n\nexport async function getRequestLog(options = {}) {\n  if (_logBuffer.length) {\n    await flushLogBuffer();\n  }\n  const force = !!options?.fresh;\n  const now = nowMs();\n  if (force || !_requestLogLoaded || now - _requestLogLastLoadedMs > 1500) {\n    await loadRequestLog(true);\n  } else {\n    await loadRequestLog(false);\n  }\n  return _requestLog.slice();\n}\n\nexport async function clearRequestLog() {\n  const clearedAt = nowMs();\n  _logBuffer = [];\n  if (_logFlushTimer) {\n    clearTimeout(_logFlushTimer);\n    _logFlushTimer = null;\n  }\n  _requestLog = [];\n  _requestLogLoaded = true;\n  _requestLogLoading = null;\n  _requestLogClearMs = clearedAt;\n  _requestLogLastLoadedMs = clearedAt;\n  await rawSet(STORAGE_KEYS.REQUEST_LOG_CLEAR_AT, String(clearedAt));\n  await rawRemove(STORAGE_KEYS.REQUEST_LOG);\n}\n","// src/shared/providers.js\n// Provider implementations (Gemini + OpenAI) and shared request orchestration.\n//\n// Requirements implemented:\n// - Gemini 3 Flash (via Google Generative Language API)\n// - OpenAI GPT-5 Mini (via OpenAI Responses API)\n// - No temperature / sampling parameters are ever sent\n// - Provider selection happens via taskpane default provider (formulas cannot override)\n// - AI.WEB uses provider-native web search mechanisms:\n//   - Gemini: google_search tool\n//   - OpenAI: web_search tool\n\nimport {\n  PROVIDERS,\n  DEFAULTS,\n  normalizeProvider,\n  getDefaultProvider,\n  getApiKey,\n  getModel,\n  getGeminiReasoningEffort,\n  getOpenAIReasoningEffort,\n  getMaxOutputTokens,\n  getConcurrencyLimit,\n  getRpmLimit,\n  clampInt,\n  nowMs,\n  sleep,\n  LRUCache,\n  hashKey,\n  logRequest,\n  setRuntimeStatus,\n  getCacheClearAt,\n  getPersistentCache,\n  setPersistentCache,\n  clearPersistentCache,\n  getPrivacyMode,\n  redactSensitiveText\n} from \"./core.js\";\n\n// ---- In-memory cache (per runtime) ----\nconst CACHE = new LRUCache(800);\nlet _cacheClearLocalMs = 0;\n\nasync function syncCacheClearMarker() {\n  const clearedAt = await getCacheClearAt();\n  if (clearedAt > _cacheClearLocalMs) {\n    _cacheClearLocalMs = clearedAt;\n    CACHE.clear();\n  }\n}\n\n// Deduplicate in-flight identical requests to avoid bursts (per runtime)\nconst INFLIGHT = new Map(); // key => Promise<AIResult>\n\nconst GEMINI_503_RETRY_DELAY_MS = 10000;\nconst GEMINI_503_MAX_RETRIES = 2;\nconst GEMINI_CACHED_CONTENT_TTL_MS = 15 * 60 * 1000;\nconst GEMINI_CACHED_CONTENT_MIN_PREFIX_CHARS = 200;\nconst GEMINI_CACHED_CONTENT_MIN_SUFFIX_CHARS = 1;\nconst GEMINI_CACHED_CONTENT = new Map(); // key => {name, createdAtMs, expiresAtMs, chargedTokenHours}\nconst GEMINI_CACHED_INFLIGHT = new Map(); // key => Promise<{name, cacheKey} | null>\n\n// Concurrency limiter (per runtime)\nconst QUEUE_CANCELLED = Symbol(\"queue_cancelled\");\nconst QUEUE_CANCELLED_RESULT = { ok: false, code: \"QUEUE_CANCELLED\", message: \"File d'attente arrte.\" };\nconst CONCURRENCY_CACHE_TTL_MS = 1500;\nlet concurrencyLimitCached = DEFAULTS.concurrencyLimit;\nlet concurrencyLimitCachedAt = 0;\n\n// RPM limiter (per runtime, global across providers)\nconst RPM_WINDOW_MS = 60000;\nconst RPM_CACHE_TTL_MS = 1500;\nlet rpmLimitCached = DEFAULTS.rpmLimit;\nlet rpmLimitCachedAt = 0;\nlet rpmWindow = [];\nlet rpmGate = Promise.resolve();\nlet rpmStatusTimer = null;\n\nclass FastQueue {\n  constructor() {\n    this._items = [];\n    this._head = 0;\n  }\n\n  get length() {\n    return this._items.length - this._head;\n  }\n\n  push(value) {\n    this._items.push(value);\n  }\n\n  shift() {\n    if (this._head >= this._items.length) return undefined;\n    const value = this._items[this._head++];\n    if (this._head > 1024 && this._head * 2 > this._items.length) {\n      this._items = this._items.slice(this._head);\n      this._head = 0;\n    }\n    return value;\n  }\n\n  drain() {\n    const pending = this._items.slice(this._head);\n    this._items = [];\n    this._head = 0;\n    return pending;\n  }\n}\n\nlet active = 0;\nconst queue = new FastQueue();\nlet statusTimer = null;\nlet pendingStatus = null;\nlet lastStatusKey = \"\";\nconst BATCH_REQUEST_THRESHOLD = Number.POSITIVE_INFINITY;\nconst BATCH_LOG_THROTTLE_MS = 1000;\nlet batchState = null;\n\nfunction createBatchState() {\n  const startedAt = nowMs();\n  return {\n    id: `batch_${startedAt}_${Math.random().toString(36).slice(2, 8)}`,\n    startedAt,\n    endedAt: 0,\n    totalRequests: 0,\n    okCount: 0,\n    errorCount: 0,\n    cachedCount: 0,\n    inputTokens: 0,\n    outputTokens: 0,\n    reasoningTokens: 0,\n    cachedInputTokens: 0,\n    msSum: 0,\n    msMax: 0,\n    msMin: 0,\n    peakQueued: 0,\n    peakActive: 0,\n    models: new Map(),\n    lastLogAt: 0\n  };\n}\n\nfunction totalPendingRequests() {\n  return active + queue.length;\n}\n\nfunction ensureBatchState() {\n  if (batchState) return true;\n  if (totalPendingRequests() < BATCH_REQUEST_THRESHOLD) return false;\n  batchState = createBatchState();\n  return true;\n}\n\nfunction updateBatchPeaks() {\n  if (!batchState) return;\n  batchState.peakQueued = Math.max(batchState.peakQueued, queue.length);\n  batchState.peakActive = Math.max(batchState.peakActive, active);\n}\n\nfunction recordBatchResult({ provider, model, ok, cached, usage, ms, cacheAdjusted = false }) {\n  if (!batchState) return false;\n  batchState.totalRequests += 1;\n  if (ok) batchState.okCount += 1;\n  else batchState.errorCount += 1;\n  if (cached) batchState.cachedCount += 1;\n\n  const inputTokens = Number(usage?.inputTokens || 0) || 0;\n  const outputTokens = Number(usage?.outputTokens || 0) || 0;\n  const reasoningTokens = Number(usage?.reasoningTokens || 0) || 0;\n  const cachedInputTokens = Number(usage?.cachedInputTokens || 0) || 0;\n\n  batchState.inputTokens += inputTokens;\n  batchState.outputTokens += outputTokens;\n  batchState.reasoningTokens += reasoningTokens;\n  batchState.cachedInputTokens += cachedInputTokens;\n\n  const duration = Number(ms || 0) || 0;\n  if (duration > 0) {\n    batchState.msSum += duration;\n    batchState.msMax = Math.max(batchState.msMax, duration);\n    batchState.msMin = batchState.msMin ? Math.min(batchState.msMin, duration) : duration;\n  }\n\n  if (inputTokens + outputTokens + reasoningTokens + cachedInputTokens > 0) {\n    const key = `${String(provider || \"\").toLowerCase()}|${String(model || \"\").trim()}`;\n    const existing = batchState.models.get(key) || {\n      provider: String(provider || \"\").toLowerCase(),\n      model: String(model || \"\").trim(),\n      inputTokens: 0,\n      outputTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0,\n      requests: 0,\n      cacheAdjusted: false\n    };\n    existing.inputTokens += inputTokens;\n    existing.outputTokens += outputTokens;\n    existing.reasoningTokens += reasoningTokens;\n    existing.cachedInputTokens += cachedInputTokens;\n    existing.requests += 1;\n    if (cacheAdjusted) existing.cacheAdjusted = true;\n    batchState.models.set(key, existing);\n  }\n\n  maybeEmitBatchLog(false);\n  return true;\n}\n\nfunction shouldUsePersistentCache() {\n  if (batchState) return false;\n  if (totalPendingRequests() >= BATCH_REQUEST_THRESHOLD) return false;\n  return true;\n}\n\nfunction buildBatchLogEntry(isFinal) {\n  if (!batchState) return null;\n  const models = Array.from(batchState.models.values());\n  const totalTokens = batchState.inputTokens + batchState.outputTokens + batchState.reasoningTokens;\n  const durationMs = Math.max(0, (batchState.endedAt || nowMs()) - batchState.startedAt);\n  const avgMs = batchState.totalRequests > 0 ? Math.round(batchState.msSum / batchState.totalRequests) : 0;\n\n  return {\n    fn: \"AI.BATCH\",\n    provider: \"batch\",\n    model: \"\",\n    ok: batchState.errorCount === 0,\n    cache: false,\n    ms: durationMs,\n    inputTokens: batchState.inputTokens,\n    outputTokens: batchState.outputTokens,\n    reasoningTokens: batchState.reasoningTokens,\n    cachedInputTokens: batchState.cachedInputTokens,\n    totalTokens,\n    batch: true,\n    batchId: batchState.id,\n    batchLive: !isFinal,\n    batchModels: models,\n    batchStats: {\n      totalRequests: batchState.totalRequests,\n      ok: batchState.okCount,\n      error: batchState.errorCount,\n      cached: batchState.cachedCount,\n      avgMs,\n      maxMs: batchState.msMax,\n      minMs: batchState.msMin,\n      peakQueued: batchState.peakQueued,\n      peakActive: batchState.peakActive\n    }\n  };\n}\n\nfunction maybeEmitBatchLog(force) {\n  if (!batchState) return;\n  const now = nowMs();\n  if (!force && now - batchState.lastLogAt < BATCH_LOG_THROTTLE_MS) return;\n  batchState.lastLogAt = now;\n  const entry = buildBatchLogEntry(false);\n  if (entry) logRequest(entry);\n}\n\nfunction finalizeBatchIfIdle() {\n  if (!batchState) return;\n  if (active > 0 || queue.length > 0) return;\n  batchState.endedAt = nowMs();\n  const entry = buildBatchLogEntry(true);\n  batchState = null;\n  if (entry) logRequest(entry);\n}\n\nfunction getRpmCount() {\n  const now = nowMs();\n  pruneRpmWindow(now);\n  return rpmWindow.length;\n}\n\nfunction snapshotQueueStatus() {\n  return { active, queued: queue.length, rpm: getRpmCount() };\n}\n\nfunction scheduleRuntimeStatusUpdate() {\n  const snapshot = snapshotQueueStatus();\n  pendingStatus = snapshot;\n  if (statusTimer) return;\n  statusTimer = setTimeout(() => {\n    statusTimer = null;\n    const status = pendingStatus;\n    pendingStatus = null;\n    if (!status) return;\n    const key = `${status.active}:${status.queued}:${status.rpm}`;\n    if (key === lastStatusKey) return;\n    lastStatusKey = key;\n    void setRuntimeStatus({ ...status, ts: nowMs() });\n  }, 120);\n}\n\nasync function getConcurrencyLimitCached() {\n  const now = nowMs();\n  if (now - concurrencyLimitCachedAt < CONCURRENCY_CACHE_TTL_MS) return concurrencyLimitCached;\n  const value = await getConcurrencyLimit();\n  concurrencyLimitCached = value;\n  concurrencyLimitCachedAt = now;\n  return value;\n}\n\nasync function getRpmLimitCached() {\n  const now = nowMs();\n  if (now - rpmLimitCachedAt < RPM_CACHE_TTL_MS) return rpmLimitCached;\n  const value = await getRpmLimit();\n  rpmLimitCached = value;\n  rpmLimitCachedAt = now;\n  return value;\n}\n\nfunction pruneRpmWindow(now) {\n  const cutoff = now - RPM_WINDOW_MS;\n  while (rpmWindow.length && rpmWindow[0] <= cutoff) {\n    rpmWindow.shift();\n  }\n}\n\nfunction ensureRpmStatusTimer() {\n  if (rpmStatusTimer) return;\n  rpmStatusTimer = setInterval(() => {\n    const count = getRpmCount();\n    scheduleRuntimeStatusUpdate();\n    if (count <= 0) {\n      clearInterval(rpmStatusTimer);\n      rpmStatusTimer = null;\n    }\n  }, 1000);\n}\n\nasync function reserveRpmSlot(limit) {\n  while (true) {\n    const now = nowMs();\n    pruneRpmWindow(now);\n    if (!limit || limit <= 0 || rpmWindow.length < limit) {\n      rpmWindow.push(now);\n      ensureRpmStatusTimer();\n      scheduleRuntimeStatusUpdate();\n      return;\n    }\n    const waitMs = Math.max(0, rpmWindow[0] + RPM_WINDOW_MS - now);\n    if (waitMs > 0) {\n      await sleep(waitMs);\n    } else {\n      await sleep(0);\n    }\n  }\n}\n\nasync function waitForRpmSlot() {\n  const limit = await getRpmLimitCached();\n  if (!limit || limit <= 0) return;\n  rpmGate = rpmGate.then(() => reserveRpmSlot(limit));\n  return rpmGate;\n}\n\nexport function stopQueuedRequests() {\n  if (!queue.length) return 0;\n  const pending = queue.drain();\n  for (const resolve of pending) {\n    resolve(QUEUE_CANCELLED);\n  }\n  scheduleRuntimeStatusUpdate();\n  return pending.length;\n}\n\nasync function withConcurrencyLimit(fn) {\n  while (true) {\n    const limit = await getConcurrencyLimitCached();\n    if (active < limit) break;\n    const gate = await new Promise((resolve) => {\n      queue.push(resolve);\n      ensureBatchState();\n      updateBatchPeaks();\n      scheduleRuntimeStatusUpdate();\n    });\n    if (gate === QUEUE_CANCELLED) return { ...QUEUE_CANCELLED_RESULT };\n  }\n  active++;\n  ensureBatchState();\n  updateBatchPeaks();\n  scheduleRuntimeStatusUpdate();\n  try {\n    await waitForRpmSlot();\n    return await fn();\n  } finally {\n    active--;\n    const next = queue.shift();\n    if (next) next();\n    scheduleRuntimeStatusUpdate();\n    finalizeBatchIfIdle();\n  }\n}\n\n// Reset runtime status on load to avoid stale UI.\nvoid setRuntimeStatus({ active: 0, queued: 0, rpm: 0, ts: nowMs() });\n\nfunction isNonEmptyString(s) {\n  return typeof s === \"string\" && s.trim().length > 0;\n}\n\nfunction normalizeBoolean(v, def = false) {\n  if (typeof v === \"boolean\") return v;\n  if (typeof v === \"number\") return v !== 0;\n  if (typeof v === \"string\") {\n    const s = v.trim().toLowerCase();\n    if ([\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(s)) return true;\n    if ([\"0\", \"false\", \"no\", \"n\", \"off\"].includes(s)) return false;\n  }\n  return def;\n}\n\nfunction normalizeTimeoutMs(v) {\n  return clampInt(v, 1000, 120000, DEFAULTS.timeoutMs);\n}\n\nfunction normalizeRetry(v) {\n  return clampInt(v, 0, 5, DEFAULTS.retry);\n}\n\nfunction normalizeMaxOutputTokens(v) {\n  return clampInt(v, 1, 128000, DEFAULTS.maxOutputTokens);\n}\n\nfunction toLowerMsg(v) {\n  return String(v || \"\").toLowerCase();\n}\n\nfunction isTimeoutError(err) {\n  if (!err) return false;\n  if (err.name === \"AbortError\") return true;\n  const msg = String(err.message || \"\").toLowerCase();\n  return msg.includes(\"aborted\") || msg.includes(\"timeout\");\n}\n\nfunction toGeminiModelRef(model) {\n  const id = String(model || \"\").trim();\n  if (!id) return \"\";\n  return id.startsWith(\"models/\") ? id : `models/${id}`;\n}\n\nfunction pruneGeminiCachedContent() {\n  const now = nowMs();\n  for (const [key, entry] of GEMINI_CACHED_CONTENT.entries()) {\n    if (entry?.expiresAtMs && entry.expiresAtMs <= now) {\n      GEMINI_CACHED_CONTENT.delete(key);\n    }\n  }\n}\n\nasync function createGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs }) {\n  const url = \"https://generativelanguage.googleapis.com/v1beta/cachedContents\";\n  const body = {\n    model: toGeminiModelRef(model),\n    contents: [{ role: \"user\", parts: [{ text: prefix }] }],\n    ttl: `${Math.max(60, Math.floor((ttlMs || GEMINI_CACHED_CONTENT_TTL_MS) / 1000))}s`\n  };\n\n  if (isNonEmptyString(system)) {\n    body.systemInstruction = { role: \"system\", parts: [{ text: system }] };\n  }\n\n  const res = await fetchWithTimeout(\n    url,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-goog-api-key\": apiKey\n      },\n      body: JSON.stringify(body)\n    },\n    Math.max(10000, Math.min(60000, timeoutMs || 30000))\n  );\n\n  const json = await safeJson(res);\n  if (!res.ok) return { ok: false, status: res.status, json };\n  const name = String(json?.name || \"\").trim();\n  if (!name) return { ok: false, status: res.status, json };\n  const expireTime = json?.expireTime ? Date.parse(String(json.expireTime)) : 0;\n  return { ok: true, name, expireTime };\n}\n\nasync function ensureGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs }) {\n  if (!apiKey || !isNonEmptyString(prefix)) return null;\n  if (await getPrivacyMode()) return null;\n  if (prefix.length < GEMINI_CACHED_CONTENT_MIN_PREFIX_CHARS) return null;\n\n  pruneGeminiCachedContent();\n  const cacheKey = await hashKey({ v: 1, model: String(model || \"\").trim(), system: String(system || \"\").trim(), prefix });\n  const existing = GEMINI_CACHED_CONTENT.get(cacheKey);\n  if (existing?.name) {\n    if (!Number.isFinite(existing.createdAtMs) || existing.createdAtMs <= 0) {\n      existing.createdAtMs = nowMs();\n    }\n    if (!Number.isFinite(existing.expiresAtMs) || existing.expiresAtMs <= existing.createdAtMs) {\n      existing.expiresAtMs = existing.createdAtMs + (ttlMs || GEMINI_CACHED_CONTENT_TTL_MS);\n    }\n    if (!Number.isFinite(existing.chargedTokenHours)) existing.chargedTokenHours = 0;\n    GEMINI_CACHED_CONTENT.set(cacheKey, existing);\n    return { name: existing.name, cacheKey };\n  }\n\n  if (GEMINI_CACHED_INFLIGHT.has(cacheKey)) return GEMINI_CACHED_INFLIGHT.get(cacheKey);\n\n  const p = (async () => {\n    try {\n      const created = await createGeminiCachedContent({ apiKey, model, system, prefix, ttlMs, timeoutMs });\n      if (!created?.ok || !created?.name) return null;\n      const expiresAtMs = Number.isFinite(created.expireTime) && created.expireTime > 0\n        ? created.expireTime\n        : nowMs() + (ttlMs || GEMINI_CACHED_CONTENT_TTL_MS);\n      GEMINI_CACHED_CONTENT.set(cacheKey, {\n        name: created.name,\n        createdAtMs: nowMs(),\n        expiresAtMs,\n        chargedTokenHours: 0\n      });\n      return { name: created.name, cacheKey };\n    } catch {\n      return null;\n    }\n  })();\n\n  GEMINI_CACHED_INFLIGHT.set(cacheKey, p);\n  try {\n    return await p;\n  } finally {\n    GEMINI_CACHED_INFLIGHT.delete(cacheKey);\n  }\n}\n\nfunction looksLikeCachedContentInvalid(message) {\n  const s = toLowerMsg(message);\n  if (!s || !s.includes(\"cached\")) return false;\n  return (\n    s.includes(\"not found\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"expired\") ||\n    s.includes(\"does not exist\")\n  );\n}\n\nfunction looksLikeStructuredOutputUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  return (\n    s.includes(\"responseschema\") ||\n    s.includes(\"response schema\") ||\n    s.includes(\"response_schema\") ||\n    s.includes(\"responsemime\") ||\n    s.includes(\"response mime\") ||\n    s.includes(\"response_mime\") ||\n    s.includes(\"response_mime_type\") ||\n    s.includes(\"json_schema\") ||\n    s.includes(\"response_format\") ||\n    s.includes(\"text.format\")\n  );\n}\n\nfunction looksLikeWebSearchUnsupported(message) {\n  const s = toLowerMsg(message);\n  if (!s) return false;\n  if (!(s.includes(\"web_search\") || s.includes(\"google_search\") || s.includes(\"web search\") || s.includes(\"google search\"))) {\n    return false;\n  }\n  return (\n    s.includes(\"not supported\") ||\n    s.includes(\"unsupported\") ||\n    s.includes(\"unknown\") ||\n    s.includes(\"unrecognized\") ||\n    s.includes(\"invalid\") ||\n    s.includes(\"not enabled\") ||\n    s.includes(\"not available\")\n  );\n}\n\nfunction isGeminiServiceUnavailable(provider, result) {\n  if (provider !== PROVIDERS.GEMINI || result?.ok) return false;\n  if (result?.status === 503) return true;\n  if (result?.code !== \"API_ERROR\") return false;\n  const msg = toLowerMsg(result?.message);\n  if (!msg) return false;\n  return msg.includes(\"overloaded\") || msg.includes(\"service unavailable\") || msg.includes(\"unavailable\");\n}\n\nfunction ensureJsonInstruction(system) {\n  const suffix = \" Return valid JSON only.\";\n  if (!isNonEmptyString(system)) return \"Return valid JSON only.\";\n  const s = String(system).trim();\n  if (/json/i.test(s)) return s;\n  return s + suffix;\n}\n\nfunction extractFormulaFromText(text) {\n  if (!isNonEmptyString(text)) return \"\";\n  const raw = String(text).trim();\n  const match = raw.match(/=[^\\n\\r]+/);\n  const formula = (match ? match[0] : raw).trim();\n  if (!formula.startsWith(\"=\")) return \"\";\n  return formula;\n}\n\nfunction getFormulaForLog(fnName, text) {\n  if (fnName !== \"AI.FORMULA\") return \"\";\n  return extractFormulaFromText(text);\n}\n\nfunction resolveGeminiThinkingConfig(model, effort) {\n  const level = String(effort || \"\").trim().toLowerCase();\n  if (!level || level === \"auto\" || level === \"none\") return null;\n\n  const modelId = String(model || \"\").trim().toLowerCase();\n  if (!modelId.includes(\"gemini\")) return null;\n\n  if (modelId.includes(\"gemini-3\")) {\n    if (modelId.includes(\"flash\")) {\n      const allowed = new Set([\"minimal\", \"low\", \"medium\", \"high\"]);\n      const normalized = allowed.has(level) ? level : \"low\";\n      return { thinkingLevel: normalized.toUpperCase() };\n    }\n    const normalized = level === \"high\" || level === \"medium\" ? \"high\" : \"low\";\n    return { thinkingLevel: normalized.toUpperCase() };\n  }\n\n  if (modelId.includes(\"gemini-2.5\")) {\n    const budgets = {\n      minimal: 512,\n      low: 2048,\n      medium: 8192,\n      high: 24576\n    };\n    let budget = budgets[level];\n    if (!budget) return null;\n    if (modelId.includes(\"flash-lite\")) budget = Math.max(512, budget);\n    if (modelId.includes(\"pro\")) budget = Math.max(128, budget);\n    return { thinkingBudget: budget };\n  }\n\n  return null;\n}\n\n// ---- Public API ----\n\n/**\n * @typedef {Object} AIGenerateRequest\n * @property {string=} provider Optional override (should only be used by taskpane tests, not formulas).\n * @property {string=} system System instruction.\n * @property {string} user User prompt.\n * @property {boolean=} webSearch Enable provider web search tool.\n * @property {number=} maxOutputTokens Override max tokens (optional; normally from panel).\n * @property {number=} timeoutMs\n * @property {number=} retry\n * @property {boolean=} cache\n * @property {number=} cacheTtlSec\n * @property {string=} cachePrefix Explicit cache prefix (Gemini only, used by AI.BATCH).\n * @property {string=} cacheSuffix Explicit cache suffix (Gemini only, used by AI.BATCH).\n * @property {string=} responseMimeType e.g., \"application/json\"\n * @property {Object=} responseJsonSchema JSON schema (strict) for structured output.\n * @property {string=} functionName Name for diagnostics.\n * @property {string=} functionCall Excel-style function call for diagnostics.\n */\n\n/**\n * @typedef {Object} AIResult\n * @property {boolean} ok\n * @property {string=} text\n * @property {Array<{title?: string, url: string}>=} sources\n * @property {string=} provider\n * @property {string=} model\n * @property {Object=} usage\n * @property {number=} status\n * @property {string=} code\n * @property {string=} message\n * @property {string=} cacheHint\n * @property {number=} cacheStorageTokenHours\n */\n\nexport async function aiGenerate(req) {\n  const start = nowMs();\n  const provider = normalizeProvider(req?.provider) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n  const fnName = req?.functionName || \"aiGenerate\";\n  const functionCall = isNonEmptyString(req?.functionCall) ? String(req.functionCall) : \"\";\n  const reasoningEffort = provider === PROVIDERS.OPENAI ? await getOpenAIReasoningEffort() : \"\";\n  const geminiReasoningEffort = provider === PROVIDERS.GEMINI ? await getGeminiReasoningEffort() : \"\";\n  const reasoningEffortLabel = provider === PROVIDERS.OPENAI ? reasoningEffort : geminiReasoningEffort;\n\n  if (!apiKey) {\n    logRequest({\n      fn: fnName,\n      provider,\n      model,\n      ok: false,\n      ms: nowMs() - start,\n      cache: false,\n      reasoningEffort: reasoningEffortLabel || undefined,\n      call: functionCall || undefined,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    });\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  const cachePrefix = isNonEmptyString(req?.cachePrefix) ? String(req.cachePrefix) : \"\";\n  const cacheSuffix = isNonEmptyString(req?.cacheSuffix) ? String(req.cacheSuffix) : \"\";\n  const user = cachePrefix ? cachePrefix + cacheSuffix : String(req?.user || \"\");\n  const system = isNonEmptyString(req?.system) ? String(req.system) : \"\";\n\n  const webSearch = normalizeBoolean(req?.webSearch, false);\n  const timeoutMs = normalizeTimeoutMs(req?.timeoutMs);\n  const retry = normalizeRetry(req?.retry);\n  const gemini503RetryMax = Math.min(retry, GEMINI_503_MAX_RETRIES);\n\n  const cfgMax = await getMaxOutputTokens();\n  const maxOutputTokens = normalizeMaxOutputTokens(req?.maxOutputTokens ?? cfgMax);\n  const thinkingConfig = provider === PROVIDERS.GEMINI ? resolveGeminiThinkingConfig(model, geminiReasoningEffort) : null;\n\n  const cacheEnabled = normalizeBoolean(req?.cache, DEFAULTS.cache);\n  const ttlSec = clampInt(\n    req?.cacheTtlSec ?? DEFAULTS.cacheTtlSec,\n    1,\n    365 * 24 * 3600,\n    DEFAULTS.cacheTtlSec\n  );\n  const allowPersistentCache = cacheEnabled && shouldUsePersistentCache();\n\n  await syncCacheClearMarker();\n\n  // Cache key (no temperature anywhere)\n  const cacheKeyPayload = {\n    v: 3,\n    provider,\n    model,\n    maxOutputTokens,\n    reasoningEffort,\n    geminiReasoningEffort,\n    webSearch,\n    system,\n    user,\n    responseMimeType: req?.responseMimeType || \"\",\n    responseJsonSchema: req?.responseJsonSchema || null\n  };\n\n  const cacheKey = await hashKey(cacheKeyPayload);\n\n  if (cacheEnabled) {\n    const cached = CACHE.get(cacheKey);\n    if (cached) {\n      const formula = getFormulaForLog(fnName, cached?.text);\n      const recorded = recordBatchResult({\n        provider,\n        model,\n        ok: true,\n        cached: true,\n        usage: null,\n        ms: nowMs() - start\n      });\n      if (!recorded) {\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: true,\n          ms: nowMs() - start,\n          cache: true,\n          cacheKind: \"memory\",\n          reasoningEffort: reasoningEffortLabel || undefined,\n          call: functionCall || undefined,\n          inputTokens: 0,\n          outputTokens: 0,\n          reasoningTokens: 0,\n          totalTokens: 0,\n          formula: formula || undefined\n        });\n      }\n      if (recorded) finalizeBatchIfIdle();\n      return { ...cached, cached: true, cacheKind: \"memory\" };\n    }\n    if (allowPersistentCache) {\n      const persisted = await getPersistentCache(cacheKey);\n      if (persisted) {\n        const formula = getFormulaForLog(fnName, persisted?.text);\n        CACHE.set(cacheKey, persisted, ttlSec * 1000);\n        const recorded = recordBatchResult({\n          provider,\n          model,\n          ok: true,\n          cached: true,\n          usage: null,\n          ms: nowMs() - start\n        });\n        if (!recorded) {\n          logRequest({\n            fn: fnName,\n            provider,\n            model,\n            ok: true,\n            ms: nowMs() - start,\n            cache: true,\n            cacheKind: \"persistent\",\n            reasoningEffort: reasoningEffortLabel || undefined,\n            call: functionCall || undefined,\n            inputTokens: 0,\n            outputTokens: 0,\n            reasoningTokens: 0,\n            totalTokens: 0,\n            formula: formula || undefined\n          });\n        }\n        if (recorded) finalizeBatchIfIdle();\n        return { ...persisted, cached: true, cacheKind: \"persistent\" };\n      }\n    }\n  }\n\n  if (INFLIGHT.has(cacheKey)) return INFLIGHT.get(cacheKey);\n\n  const p = withConcurrencyLimit(async () => {\n    let attempt = 0;\n    let lastErr = null;\n\n    const callProvider = async (opts) =>\n      provider === PROVIDERS.OPENAI ? callOpenAI(opts) : callGemini(opts);\n\n    while (attempt <= retry) {\n      attempt++;\n      try {\n        const baseOpts = {\n          apiKey,\n          model,\n          system,\n          user,\n          cachePrefix: cachePrefix || undefined,\n          cacheSuffix: cacheSuffix || undefined,\n          maxOutputTokens,\n          reasoningEffort,\n          thinkingConfig,\n          timeoutMs,\n          webSearch,\n          responseMimeType: req?.responseMimeType,\n          responseJsonSchema: req?.responseJsonSchema\n        };\n\n        let result = await callProvider(baseOpts);\n\n        if (!result.ok && !isGeminiServiceUnavailable(provider, result)) {\n          let opts = baseOpts;\n\n          // Fallback #1: if web search fails, retry without tools.\n          if (opts.webSearch) {\n            const shouldRetryNoWeb =\n              looksLikeWebSearchUnsupported(result.message) || result.code === \"API_ERROR\" || result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryNoWeb) {\n              opts = { ...opts, webSearch: false };\n              result = await callProvider(opts);\n            }\n          }\n\n          // Fallback #2: if structured output fails, retry without schema/responseMimeType.\n          const wantsStructured = opts.responseMimeType || opts.responseJsonSchema;\n          if (!result.ok && wantsStructured) {\n            const shouldRetryPlainJson =\n              looksLikeStructuredOutputUnsupported(result.message) ||\n              result.code === \"API_ERROR\" ||\n              result.code === \"EMPTY_RESPONSE\";\n            if (shouldRetryPlainJson) {\n              opts = {\n                ...opts,\n                responseMimeType: undefined,\n                responseJsonSchema: undefined,\n                system: ensureJsonInstruction(opts.system)\n              };\n              result = await callProvider(opts);\n            }\n          }\n        }\n\n        const shouldRetryServiceUnavailable =\n          isGeminiServiceUnavailable(provider, result) && attempt <= gemini503RetryMax;\n\n        // Log (best-effort)\n        let usage = normalizeUsage(result?.usage);\n        const cacheAdjusted = provider === PROVIDERS.GEMINI && usage.cachedInputTokens > 0;\n        if (cacheAdjusted) {\n          usage = {\n            ...usage,\n            inputTokens: Math.max(0, usage.inputTokens - usage.cachedInputTokens)\n          };\n        }\n        const formula = result.ok ? getFormulaForLog(fnName, result.text) : \"\";\n\n        if (shouldRetryServiceUnavailable) {\n          await sleep(GEMINI_503_RETRY_DELAY_MS);\n          continue;\n        }\n\n        const recorded = recordBatchResult({\n          provider,\n          model,\n          ok: result.ok,\n          cached: false,\n          usage,\n          ms: nowMs() - start,\n          cacheAdjusted\n        });\n        if (!recorded) {\n          logRequest({\n            fn: fnName,\n            provider,\n            model,\n            ok: result.ok,\n            ms: nowMs() - start,\n            attempt,\n            cache: false,\n            reasoningEffort: reasoningEffortLabel || undefined,\n            call: functionCall || undefined,\n            inputTokens: usage.inputTokens,\n            outputTokens: usage.outputTokens,\n            reasoningTokens: usage.reasoningTokens,\n            cachedInputTokens: usage.cachedInputTokens,\n            totalTokens: usage.totalTokens,\n            code: result.code,\n            message: result.message,\n            formula: formula || undefined,\n            cacheHint: result.cacheHint || undefined,\n            cacheStorageTokenHours: result.cacheStorageTokenHours || 0,\n            cacheAdjusted\n          });\n        }\n\n        if (result.ok && cacheEnabled) {\n          CACHE.set(cacheKey, result, ttlSec * 1000);\n          if (allowPersistentCache) {\n            await setPersistentCache(cacheKey, result, ttlSec * 1000, { provider, model });\n          }\n        }\n\n        return result;\n      } catch (e) {\n        lastErr = e;\n        if (attempt <= retry) await sleep(250 * attempt);\n      }\n    }\n\n    const timeout = isTimeoutError(lastErr);\n    const code = timeout ? \"TIMEOUT\" : \"API_ERROR\";\n    const rawMsg = timeout ? \"Dlai dpass (timeout).\" : (lastErr?.message ? String(lastErr.message) : \"Erreur inconnue.\");\n    const msg = redactSensitiveText(rawMsg);\n    const recorded = recordBatchResult({\n      provider,\n      model,\n      ok: false,\n      cached: false,\n      usage: null,\n      ms: nowMs() - start\n    });\n    if (!recorded) {\n      logRequest({\n        fn: fnName,\n        provider,\n        model,\n        ok: false,\n        ms: nowMs() - start,\n        cache: false,\n        reasoningEffort: reasoningEffortLabel || undefined,\n        call: functionCall || undefined,\n        code,\n        message: msg\n      });\n    }\n    return { ok: false, provider, model, code, message: msg };\n  });\n\n  INFLIGHT.set(cacheKey, p);\n\n  try {\n    const result = await p;\n    if (result?.code === \"QUEUE_CANCELLED\") {\n      const recorded = recordBatchResult({\n        provider,\n        model,\n        ok: false,\n        cached: false,\n        usage: null,\n        ms: nowMs() - start\n      });\n      if (!recorded) {\n        logRequest({\n          fn: fnName,\n          provider,\n          model,\n          ok: false,\n          ms: nowMs() - start,\n          cache: false,\n          reasoningEffort: reasoningEffortLabel || undefined,\n          call: functionCall || undefined,\n          inputTokens: 0,\n          outputTokens: 0,\n          reasoningTokens: 0,\n          cachedInputTokens: 0,\n          totalTokens: 0,\n          code: result.code,\n          message: result.message\n        });\n      }\n    }\n    return result;\n  } finally {\n    INFLIGHT.delete(cacheKey);\n  }\n}\n\n/**\n * Lightweight connectivity test for a provider (used from taskpane and AI.TEST()).\n */\nexport async function aiMinimalTest(providerOverride) {\n  const provider = normalizeProvider(providerOverride) || (await getDefaultProvider());\n  const model = await getModel(provider);\n  const apiKey = await getApiKey(provider);\n\n  if (!apiKey) {\n    return {\n      ok: false,\n      provider,\n      model,\n      code: \"API_KEY_MISSING\",\n      message: `Cl API manquante pour le fournisseur ${provider}.`\n    };\n  }\n\n  // Tiny request\n  return await aiGenerate({\n    provider,\n    system: \"You are a test endpoint. Reply with exactly: OK\",\n    user: \"OK\",\n    maxOutputTokens: 500,\n    cache: false,\n    webSearch: false,\n    functionName: \"AI.MINIMAL_TEST\"\n  });\n}\n\n// ---- Provider: Gemini (Google Generative Language API) ----\n\nfunction geminiEndpoint(model) {\n  return `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent`;\n}\n\nasync function callGemini({\n  apiKey,\n  model,\n  system,\n  user,\n  cachePrefix,\n  cacheSuffix,\n  maxOutputTokens,\n  thinkingConfig,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema,\n  disableCache = false\n}) {\n  const url = geminiEndpoint(model);\n  let cacheHint = \"\";\n  let cachedContentName = \"\";\n  let cachedContentKey = \"\";\n  let userText = user;\n\n  const systemText = isNonEmptyString(system)\n    ? ((responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system)\n    : \"\";\n\n  const shouldUseExplicitCache = !disableCache\n    && !webSearch\n    && isNonEmptyString(cachePrefix)\n    && isNonEmptyString(cacheSuffix)\n    && cacheSuffix.trim().length >= GEMINI_CACHED_CONTENT_MIN_SUFFIX_CHARS;\n\n  if (shouldUseExplicitCache) {\n    const cached = await ensureGeminiCachedContent({\n      apiKey,\n      model,\n      system: systemText,\n      prefix: cachePrefix,\n      ttlMs: GEMINI_CACHED_CONTENT_TTL_MS,\n      timeoutMs\n    });\n    if (cached?.name) {\n      cachedContentName = cached.name;\n      cachedContentKey = cached.cacheKey || \"\";\n      userText = cacheSuffix;\n      cacheHint = \"gemini_cached_content\";\n    }\n  }\n\n  const body = {\n    contents: [{ role: \"user\", parts: [{ text: userText }] }],\n    generationConfig: {\n      maxOutputTokens\n    }\n  };\n\n  if (thinkingConfig && typeof thinkingConfig === \"object\") {\n    body.generationConfig.thinkingConfig = thinkingConfig;\n  }\n\n  if (isNonEmptyString(systemText) && !cachedContentName) {\n    // API uses lowerCamelCase for this field in JSON representation\n    // Force explicit JSON instruction for robustness\n    body.systemInstruction = { role: \"system\", parts: [{ text: systemText }] };\n  }\n\n  // Structured output (JSON) when requested\n  if (responseMimeType) {\n    body.generationConfig.responseMimeType = responseMimeType;\n  }\n  if (responseJsonSchema) {\n    body.generationConfig.responseSchema = responseJsonSchema;\n  }\n\n  // Web grounding tool\n  if (webSearch) {\n    // For REST v1beta, the tool name is usually google_search (snake_case).\n    // Note: Some newer endpoints might respect googleSearch, but snake_case is safer for REST.\n    body.tools = [{ google_search: {} }];\n  }\n  if (cachedContentName) {\n    body.cachedContent = cachedContentName;\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-goog-api-key\": apiKey\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n  const errInfo = extractGeminiErrorInfo(json);\n\n  if (errInfo?.message) {\n    if (cachedContentKey && looksLikeCachedContentInvalid(errInfo.message)) {\n      GEMINI_CACHED_CONTENT.delete(cachedContentKey);\n      return await callGemini({\n        apiKey,\n        model,\n        system,\n        user,\n        cachePrefix,\n        cacheSuffix,\n        maxOutputTokens,\n        thinkingConfig,\n        timeoutMs,\n        webSearch,\n        responseMimeType,\n        responseJsonSchema,\n        disableCache: true\n      });\n    }\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: errInfo.status ?? res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(errInfo.message),\n      cacheHint\n    };\n  }\n\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    if (cachedContentKey && looksLikeCachedContentInvalid(msg)) {\n      GEMINI_CACHED_CONTENT.delete(cachedContentKey);\n      return await callGemini({\n        apiKey,\n        model,\n        system,\n        user,\n        cachePrefix,\n        cacheSuffix,\n        maxOutputTokens,\n        thinkingConfig,\n        timeoutMs,\n        webSearch,\n        responseMimeType,\n        responseJsonSchema,\n        disableCache: true\n      });\n    }\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      status: res.status,\n      code: \"API_ERROR\",\n      message: redactSensitiveText(msg),\n      cacheHint\n    };\n  }\n\n  const text = extractGeminiText(json);\n  const sources = extractGeminiSources(json);\n  const usage = extractGeminiUsage(json);\n  let cacheStorageTokenHours = 0;\n\n  if (cacheHint === \"gemini_cached_content\" && cachedContentKey && usage?.cachedInputTokens > 0) {\n    const entry = GEMINI_CACHED_CONTENT.get(cachedContentKey);\n    const alreadyCharged = entry?.chargedTokenHours && entry.chargedTokenHours > 0;\n    if (!alreadyCharged) {\n      const createdAtMs = Number(entry?.createdAtMs) || 0;\n      const expiresAtMs = Number(entry?.expiresAtMs) || 0;\n      let ttlMs = 0;\n      if (createdAtMs > 0 && expiresAtMs > createdAtMs) {\n        ttlMs = expiresAtMs - createdAtMs;\n      } else {\n        ttlMs = GEMINI_CACHED_CONTENT_TTL_MS;\n      }\n      if (ttlMs > 0) {\n        const ttlHours = ttlMs / 3600000;\n        cacheStorageTokenHours = Math.max(0, Number(usage.cachedInputTokens) || 0) * ttlHours;\n        if (entry && cacheStorageTokenHours > 0) {\n          entry.chargedTokenHours = cacheStorageTokenHours;\n          GEMINI_CACHED_CONTENT.set(cachedContentKey, entry);\n        }\n      }\n    }\n  }\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.GEMINI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide de Gemini.\",\n      cacheHint\n    };\n  }\n\n  return {\n    ok: true,\n    provider: PROVIDERS.GEMINI,\n    model,\n    text: text.trim(),\n    sources,\n    usage,\n    cacheHint,\n    cacheStorageTokenHours: cacheStorageTokenHours || 0\n  };\n}\n\nfunction extractGeminiText(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const parts = c?.content?.parts;\n    if (Array.isArray(parts)) {\n      return parts.map((p) => p?.text || \"\").join(\"\");\n    }\n    return \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractGeminiErrorInfo(json) {\n  try {\n    const err = json?.error;\n    if (!err) return null;\n    const msg = err?.message;\n    const statusCode = Number(err?.code);\n    return {\n      message: msg ? String(msg) : \"\",\n      status: Number.isFinite(statusCode) ? statusCode : undefined\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractGeminiSources(json) {\n  try {\n    const c = json?.candidates?.[0];\n    const md = c?.groundingMetadata;\n    const chunks = md?.groundingChunks;\n    if (!Array.isArray(chunks)) return [];\n\n    const out = [];\n    for (const ch of chunks) {\n      const web = ch?.web;\n      if (!web?.uri) continue;\n      out.push({ title: web?.title || \"\", url: web.uri });\n    }\n\n    return dedupeSources(out);\n  } catch {\n    return [];\n  }\n}\n\n// ---- Provider: OpenAI (Responses API) ----\n\nasync function callOpenAI({\n  apiKey,\n  model,\n  system,\n  user,\n  maxOutputTokens,\n  reasoningEffort,\n  timeoutMs,\n  webSearch,\n  responseMimeType,\n  responseJsonSchema\n}) {\n  const url = \"https://api.openai.com/v1/responses\";\n\n  const body = {\n    model,\n    input: user, // Responses API uses 'input' (string or array of objects)\n    max_output_tokens: maxOutputTokens,\n    store: false\n  };\n\n  if (isNonEmptyString(reasoningEffort)) {\n    body.reasoning = { effort: reasoningEffort };\n  }\n\n  // System prompt\n  if (isNonEmptyString(system)) {\n    const sysText = (responseMimeType === \"application/json\" || responseJsonSchema)\n      ? system + \" You must return valid JSON.\"\n      : system;\n    body.instructions = sysText;\n  }\n\n  // Structured output (JSON)\n  // - If a JSON schema is provided: use json_schema strict mode.\n  // - Else if responseMimeType is JSON: request a json_object.\n  if (responseJsonSchema) {\n    // For GPT-5 Mini / v1/responses, we try to use the most standard way if possible.\n    // If body.text format fails, we rely on the prompt.\n    // We kept the previous implementation but added prompt reinforcement.\n    body.text = {\n      format: {\n        type: \"json_schema\",\n        name: \"excel_ai_schema\",\n        strict: true,\n        schema: responseJsonSchema\n      }\n    };\n  } else if (responseMimeType === \"application/json\") {\n    body.text = { format: { type: \"json_object\" } };\n  }\n\n  // Web search tool\n  if (webSearch) {\n    body.tools = [{ type: \"web_search\" }];\n    body.include = [\"web_search_call.action.sources\"];\n  }\n\n  const res = await fetchWithTimeout(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(body)\n  }, timeoutMs);\n\n  const json = await safeJson(res);\n\n  if (!res.ok) {\n    const msg = extractOpenAIError(json) || `OpenAI API error (${res.status}).`;\n    return { ok: false, provider: PROVIDERS.OPENAI, model, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n  }\n\n  const text = extractOpenAIText(json);\n  const sources = webSearch ? extractOpenAISources(json) : [];\n  const usage = extractOpenAIUsage(json);\n\n  if (!isNonEmptyString(text)) {\n    return {\n      ok: false,\n      provider: PROVIDERS.OPENAI,\n      model,\n      code: \"EMPTY_RESPONSE\",\n      message: \"Rponse vide d'OpenAI.\"\n    };\n  }\n\n  return { ok: true, provider: PROVIDERS.OPENAI, model, text: text.trim(), sources, usage };\n}\n\nfunction extractOpenAIText(json) {\n  // 1. Try direct output_text (common in simple Responses)\n  try {\n    if (typeof json?.output_text === \"string\" && json.output_text.trim()) {\n      return json.output_text;\n    }\n  } catch {\n    // ignore\n  }\n\n  // 2. Try iterating over 'output' items (complex/agentic responses)\n  try {\n    const out = json?.output;\n    if (Array.isArray(out)) {\n      const texts = [];\n      for (const item of out) {\n        if (typeof item?.text === \"string\" && item.text.trim()) texts.push(item.text);\n        if (typeof item?.output_text === \"string\" && item.output_text.trim()) texts.push(item.output_text);\n        if (item?.type === \"output_text\" && typeof item?.text === \"string\") texts.push(item.text);\n        if (item?.type === \"text\" && typeof item?.text === \"string\") texts.push(item.text);\n\n        // Standard message output\n        if (item?.type === \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n\n        if (item?.type !== \"message\") {\n          const content = item?.content;\n          if (Array.isArray(content)) {\n            for (const part of content) {\n              if (part?.type === \"text\" && part?.text) texts.push(part.text);\n              if (part?.type === \"output_text\" && part?.text) texts.push(part.text);\n            }\n          } else if (typeof content === \"string\") {\n            texts.push(content);\n          }\n        }\n      }\n      if (texts.length > 0) return texts.join(\"\\n\").trim();\n    }\n  } catch {\n    // ignore\n  }\n\n  // 3. Fallback: Chat Completions style (just in case model acts differently)\n  try {\n    return json?.choices?.[0]?.message?.content || \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAIError(json) {\n  try {\n    const msg = json?.error?.message;\n    return msg ? String(msg) : \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nfunction extractOpenAISources(json) {\n  try {\n    const out = json?.output;\n    if (!Array.isArray(out)) return [];\n\n    const sources = [];\n    for (const item of out) {\n      if (item?.type !== \"web_search_call\") continue;\n      const s = item?.action?.sources;\n      if (!Array.isArray(s)) continue;\n      for (const src of s) {\n        if (!src?.url) continue;\n        sources.push({ title: src?.title || \"\", url: src.url });\n      }\n    }\n\n    return dedupeSources(sources);\n  } catch {\n    return [];\n  }\n}\n\nfunction extractGeminiUsage(json) {\n  try {\n    const u = json?.usageMetadata;\n    if (!u) return null;\n    return {\n      inputTokens: toInt(u?.promptTokenCount),\n      outputTokens: toInt(u?.candidatesTokenCount),\n      reasoningTokens: toInt(u?.thoughtsTokenCount),\n      totalTokens: toInt(u?.totalTokenCount),\n      cachedInputTokens: toInt(u?.cachedContentTokenCount)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction extractOpenAIUsage(json) {\n  try {\n    const u = json?.usage;\n    if (!u) return null;\n    const rawOutputTokens = toInt(u?.output_tokens);\n    const reasoningTokens = toInt(u?.output_tokens_details?.reasoning_tokens);\n    const outputTokens = Math.max(0, rawOutputTokens - reasoningTokens);\n    return {\n      inputTokens: toInt(u?.input_tokens),\n      outputTokens,\n      reasoningTokens,\n      totalTokens: toInt(u?.total_tokens),\n      cachedInputTokens: toInt(u?.input_tokens_details?.cached_tokens)\n    };\n  } catch {\n    return null;\n  }\n}\n\nfunction normalizeUsage(usage) {\n  if (!usage || typeof usage !== \"object\") {\n    return { inputTokens: 0, outputTokens: 0, reasoningTokens: 0, totalTokens: 0, cachedInputTokens: 0 };\n  }\n  const inputTokens = toInt(usage.inputTokens);\n  const outputTokens = toInt(usage.outputTokens);\n  const reasoningTokens = toInt(usage.reasoningTokens);\n  const cachedInputTokens = toInt(usage.cachedInputTokens);\n  const reportedTotal = toInt(usage.totalTokens);\n  const computedTotal = inputTokens + outputTokens + reasoningTokens;\n  const totalTokens = Math.max(reportedTotal, computedTotal);\n  return {\n    inputTokens,\n    outputTokens,\n    reasoningTokens,\n    totalTokens,\n    cachedInputTokens\n  };\n}\n\nfunction toInt(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nexport async function clearAllCaches() {\n  CACHE.clear();\n  await clearPersistentCache();\n}\n\nexport async function listGeminiCachedContents(options = {}) {\n  const apiKey = await getApiKey(PROVIDERS.GEMINI);\n  if (!apiKey) {\n    return { ok: false, code: \"API_KEY_MISSING\", message: \"Cl API manquante pour Gemini.\" };\n  }\n  const pageSize = clampInt(options?.pageSize ?? 50, 1, 100, 50);\n  const maxPages = clampInt(options?.maxPages ?? 3, 1, 5, 3);\n  const allPages = !!options?.all;\n  let pageToken = isNonEmptyString(options?.pageToken) ? String(options.pageToken) : \"\";\n  let pages = 0;\n  const caches = [];\n\n  while (pages < maxPages) {\n    pages += 1;\n    const url = new URL(\"https://generativelanguage.googleapis.com/v1beta/cachedContents\");\n    url.searchParams.set(\"pageSize\", String(pageSize));\n    if (pageToken) url.searchParams.set(\"pageToken\", pageToken);\n\n    const res = await fetchWithTimeout(url.toString(), {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-goog-api-key\": apiKey\n      }\n    }, 30000);\n\n    const json = await safeJson(res);\n    if (!res.ok) {\n      const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n      return { ok: false, status: res.status, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n    }\n\n    const list = Array.isArray(json?.cachedContents)\n      ? json.cachedContents\n      : (Array.isArray(json?.cachedContent) ? json.cachedContent : []);\n    caches.push(...list);\n\n    pageToken = isNonEmptyString(json?.nextPageToken) ? String(json.nextPageToken) : \"\";\n    if (!allPages || !pageToken) break;\n  }\n\n  return { ok: true, caches, nextPageToken: pageToken || \"\", pages };\n}\n\nexport async function deleteGeminiCachedContent(name) {\n  const apiKey = await getApiKey(PROVIDERS.GEMINI);\n  if (!apiKey) {\n    return { ok: false, code: \"API_KEY_MISSING\", message: \"Cl API manquante pour Gemini.\" };\n  }\n  const path = String(name || \"\").trim();\n  if (!path) return { ok: false, code: \"INVALID_NAME\", message: \"Nom de cache invalide.\" };\n\n  const url = `https://generativelanguage.googleapis.com/v1beta/${encodeURI(path)}`;\n  const res = await fetchWithTimeout(url, {\n    method: \"DELETE\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-goog-api-key\": apiKey\n    }\n  }, 30000);\n\n  const json = await safeJson(res);\n  if (!res.ok) {\n    const msg = extractGeminiError(json) || `Gemini API error (${res.status}).`;\n    return { ok: false, status: res.status, code: \"API_ERROR\", message: redactSensitiveText(msg) };\n  }\n\n  for (const [key, entry] of GEMINI_CACHED_CONTENT.entries()) {\n    if (entry?.name && entry.name === path) {\n      GEMINI_CACHED_CONTENT.delete(key);\n    }\n  }\n\n  return { ok: true };\n}\n\nfunction dedupeSources(list) {\n  const seen = new Set();\n  const out = [];\n  for (const s of list || []) {\n    const url = String(s?.url || \"\").trim();\n    if (!url) continue;\n    const key = url.toLowerCase();\n    if (seen.has(key)) continue;\n    seen.add(key);\n    out.push({ title: String(s?.title || \"\").trim(), url });\n  }\n  return out;\n}\n\n// ---- Helpers: fetch + timeout + JSON parsing ----\n\nasync function fetchWithTimeout(url, options, timeoutMs) {\n  const t = normalizeTimeoutMs(timeoutMs);\n\n  if (typeof AbortController === \"undefined\") {\n    // Basic fetch without cancellation (should be rare in modern Office runtimes)\n    return await fetch(url, options);\n  }\n\n  const ctrl = new AbortController();\n  const id = setTimeout(() => ctrl.abort(), t);\n\n  try {\n    return await fetch(url, { ...options, signal: ctrl.signal });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nasync function safeJson(res) {\n  try {\n    return await res.json();\n  } catch {\n    return {};\n  }\n}\n","// src/license.js\n// Lemon Squeezy license activation + validation helpers.\n\nimport { getLicense, setLicense, clearLicense } from \"./shared/core\";\n\nconst LS_ACTIVATE_ENDPOINT = \"https://api.lemonsqueezy.com/v1/licenses/activate\";\nconst LS_VALIDATE_ENDPOINT = \"https://api.lemonsqueezy.com/v1/licenses/validate\";\nconst INSTANCE_NAME = \"Neurow Add-in\";\nconst MIN_LICENSE_LENGTH = 5;\n\nfunction normalizeKey(key) {\n  return String(key || \"\").trim();\n}\n\nfunction normalizeExpiresAt(value) {\n  const raw = String(value || \"\").trim();\n  if (!raw) return \"\";\n  const ts = Date.parse(raw);\n  if (!Number.isFinite(ts)) return \"\";\n  return new Date(ts).toISOString();\n}\n\nfunction extractError(data, fallback) {\n  if (!data) return fallback;\n  if (typeof data.error === \"string\" && data.error.trim()) return data.error.trim();\n  if (typeof data.message === \"string\" && data.message.trim()) return data.message.trim();\n  if (Array.isArray(data.errors) && data.errors.length) {\n    const first = data.errors[0] || {};\n    const detail = first.detail || first.title || first.message;\n    if (detail) return String(detail).trim();\n  }\n  return fallback;\n}\n\nasync function postLicense(endpoint, payload) {\n  const formData = new FormData();\n  Object.entries(payload || {}).forEach(([key, value]) => {\n    if (value == null || value === \"\") return;\n    formData.append(key, value);\n  });\n\n  const response = await fetch(endpoint, { method: \"POST\", body: formData });\n  let data = null;\n  try {\n    data = await response.json();\n  } catch {\n    data = null;\n  }\n  return { ok: response.ok, status: response.status, data };\n}\n\nfunction buildLicense(key, data, overrides = {}) {\n  const instanceId = overrides.instanceId || data?.instance?.id || data?.instance_id || \"\";\n  const instanceName = data?.instance?.name || overrides.instanceName || INSTANCE_NAME;\n  const expiresAt = normalizeExpiresAt(data?.license_key?.expires_at || overrides.expiresAt);\n  const now = new Date().toISOString();\n\n  return {\n    key,\n    instanceId,\n    instanceName,\n    expiresAt,\n    valid: true,\n    activatedAt: overrides.activatedAt || now,\n    lastCheckedAt: now\n  };\n}\n\nfunction normalizeLicense(raw) {\n  if (!raw || typeof raw !== \"object\") return null;\n  const key = normalizeKey(raw.key);\n  if (!key) return null;\n\n  return {\n    key,\n    instanceId: String(raw.instanceId || \"\").trim(),\n    instanceName: String(raw.instanceName || INSTANCE_NAME).trim(),\n    expiresAt: normalizeExpiresAt(raw.expiresAt),\n    valid: raw.valid !== false,\n    activatedAt: String(raw.activatedAt || \"\").trim(),\n    lastCheckedAt: String(raw.lastCheckedAt || \"\").trim()\n  };\n}\n\nexport async function getStoredLicense() {\n  const stored = await getLicense();\n  return normalizeLicense(stored);\n}\n\nexport async function saveStoredLicense(license) {\n  const normalized = normalizeLicense(license);\n  if (!normalized) {\n    await clearLicense();\n    return null;\n  }\n  await setLicense(normalized);\n  return normalized;\n}\n\nexport async function clearStoredLicense() {\n  await clearLicense();\n}\n\nexport function isLicenseValid(license) {\n  if (!license || !license.key) return false;\n  if (license.valid === false) return false;\n  if (license.expiresAt) {\n    const ts = Date.parse(license.expiresAt);\n    if (Number.isFinite(ts) && ts <= Date.now()) return false;\n  }\n  return true;\n}\n\nexport async function hasValidLicense() {\n  const stored = await getStoredLicense();\n  return isLicenseValid(stored);\n}\n\nexport async function activateLicense(key, options = {}) {\n  const trimmed = normalizeKey(key);\n  if (!trimmed || trimmed.length < MIN_LICENSE_LENGTH) {\n    return { success: false, error: \"Cle trop courte\" };\n  }\n\n  const stored = await getStoredLicense();\n  if (!options.force && stored && stored.key === trimmed && isLicenseValid(stored)) {\n    return { success: true, license: stored, cached: true };\n  }\n\n  try {\n    const { ok, status, data } = await postLicense(LS_ACTIVATE_ENDPOINT, {\n      license_key: trimmed,\n      instance_name: INSTANCE_NAME\n    });\n\n    if (!ok) {\n      return { success: false, error: extractError(data, `Erreur API (${status})`) };\n    }\n\n    if (data?.activated) {\n      const license = buildLicense(trimmed, data, { activatedAt: stored?.activatedAt });\n      await setLicense(license);\n      return { success: true, license };\n    }\n\n    return { success: false, error: extractError(data, \"Cle invalide\") };\n  } catch {\n    return { success: false, error: \"Erreur de connexion internet\" };\n  }\n}\n\nexport async function validateLicense(key, options = {}) {\n  const trimmed = normalizeKey(key);\n  if (!trimmed || trimmed.length < MIN_LICENSE_LENGTH) {\n    return { success: false, error: \"Cle trop courte\" };\n  }\n\n  const stored = await getStoredLicense();\n  const instanceId = options.instanceId || stored?.instanceId || \"\";\n\n  try {\n    const { ok, status, data } = await postLicense(LS_VALIDATE_ENDPOINT, {\n      license_key: trimmed,\n      instance_id: instanceId || undefined\n    });\n\n    if (!ok) {\n      return { success: false, error: extractError(data, `Erreur API (${status})`) };\n    }\n\n    if (data?.valid) {\n      const license = buildLicense(trimmed, data, { instanceId, activatedAt: stored?.activatedAt });\n      return { success: true, license };\n    }\n\n    return { success: false, error: extractError(data, \"Cle invalide\") };\n  } catch {\n    return { success: false, error: \"Erreur de connexion internet\" };\n  }\n}\n","// src/taskpane/taskpane.js\n// Taskpane logic: provider selection + keys/models + shared max tokens.\n//\n// Requirements implemented:\n// - Default provider selection only in panel (not in formulas)\n// - Two tabs: Gemini and OpenAI\n// - Single max output tokens setting shared by both providers\n// - No temperature/top-p controls\n\nimport {\n  PROVIDERS,\n  DEFAULTS,\n  storageBackendName,\n  getDefaultProvider,\n  setDefaultProvider,\n  getMaxOutputTokens,\n  setMaxOutputTokens,\n  getConcurrencyLimit,\n  setConcurrencyLimit,\n  getRpmLimit,\n  setRpmLimit,\n  getInterfaceMode,\n  setInterfaceMode,\n  getOnboardingSeen,\n  setOnboardingSeen,\n  getOnboardingKeysConfirmed,\n  setOnboardingKeysConfirmed,\n  getSectionOrder,\n  setSectionOrder,\n  getHiddenSections,\n  setHiddenSections,\n  hasApiKey,\n  setApiKey,\n  getModel,\n  setModel,\n  getGeminiReasoningEffort,\n  setGeminiReasoningEffort,\n  getOpenAIReasoningEffort,\n  setOpenAIReasoningEffort,\n  getPrivacyMode,\n  setPrivacyMode,\n  getRequestLog,\n  clearRequestLog,\n  getUsageTotals,\n  clearUsageTotals,\n  getRuntimeStatus,\n  getPersistentCacheStats,\n  redactSensitiveText,\n  redactSensitiveValue\n} from \"../shared/core\";\n\nimport { clearAllCaches, stopQueuedRequests, listGeminiCachedContents, deleteGeminiCachedContent } from \"../shared/providers\";\n\nimport {\n  activateLicense,\n  getStoredLicense,\n  isLicenseValid\n} from \"../license\";\n\nfunction el(id) {\n  return document.getElementById(id);\n}\n\nfunction setStatus(line, detailsObj) {\n  const statusLine = el(\"statusLine\");\n  const statusDetails = el(\"statusDetails\");\n  if (!statusLine || !statusDetails) return;\n  const safeLine = redactSensitiveText(line || \"\");\n  statusLine.textContent = safeLine;\n  if (detailsObj) {\n    try {\n      const safeDetails = redactSensitiveValue(detailsObj);\n      statusDetails.textContent = JSON.stringify(safeDetails, null, 2);\n    } catch {\n      statusDetails.textContent = redactSensitiveText(detailsObj);\n    }\n  } else {\n    statusDetails.textContent = \"\";\n  }\n}\n\nfunction showToast(message, options = {}) {\n  const { duration = 2600 } = options;\n  const toast = el(\"statusToast\");\n  if (!toast) return;\n  toast.textContent = message || \"\";\n  toast.classList.add(\"is-visible\");\n  if (toastTimer) {\n    clearTimeout(toastTimer);\n    toastTimer = null;\n  }\n  toastTimer = setTimeout(() => {\n    toast.classList.remove(\"is-visible\");\n  }, duration);\n}\n\nfunction formatNumber(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return \"0\";\n  return Math.round(n).toLocaleString(\"en-US\");\n}\n\nconst CURRENCY_SYMBOL = \"\";\nconst COST_ICON = \"$\";\nconst REASON_ICON = \"\\uD83E\\uDDE0\";\nconst TOKEN_IN_ICON = \"IN\";\nconst TOKEN_REASON_ICON = \"REF\";\nconst TOKEN_OUT_ICON = \"OUT\";\nconst TOKEN_CACHE_ICON = \"CACHE\";\nconst LICENSE_PLACEHOLDER = \"AAAA-BBBB-CCCC-DDDD\";\n\nconst FAVORITE_ICON = \"\\u2605\";\n\nfunction formatCost(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return `${CURRENCY_SYMBOL}0.0000`;\n  return `${CURRENCY_SYMBOL}${n.toFixed(4)}`;\n}\n\nfunction formatCostTotal(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return `0,00${CURRENCY_SYMBOL}`;\n  return `${n.toFixed(2).replace(\".\", \",\")}${CURRENCY_SYMBOL}`;\n}\n\nfunction formatCostCents(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return \"00c\";\n  const cents = Math.max(0, n * 100);\n  if (cents > 0 && cents < 0.01) return \"<0,01c\";\n  return `${cents.toFixed(2).replace(\".\", \",\")}c`;\n}\n\nfunction isGeminiProvider(value) {\n  return String(value || \"\").toLowerCase() === PROVIDERS.GEMINI;\n}\n\nfunction isCacheAdjustedEntry(entry) {\n  return !!entry?.cacheAdjusted || entry?.fn === \"AI.BATCH\";\n}\n\nfunction shouldShowCacheTokens(entry) {\n  const cached = Number(entry?.cachedInputTokens || 0);\n  if (!Number.isFinite(cached) || cached <= 0) return false;\n  return entry?.fn === \"AI.BATCH\" || isGeminiProvider(entry?.provider);\n}\n\nfunction getDisplayInputTokens(entry) {\n  const inputTokens = Math.max(0, Number(entry?.inputTokens || 0));\n  if (!shouldShowCacheTokens(entry)) return inputTokens;\n  if (isCacheAdjustedEntry(entry)) return inputTokens;\n  const cachedInputTokens = Math.max(0, Number(entry?.cachedInputTokens || 0));\n  return Math.max(0, inputTokens - cachedInputTokens);\n}\n\nfunction getDisplayTokensTotal(entry) {\n  const inputTokens = getDisplayInputTokens(entry);\n  const reasoningTokens = Math.max(0, Number(entry?.reasoningTokens || 0));\n  const outputTokens = Math.max(0, Number(entry?.outputTokens || 0));\n  return inputTokens + reasoningTokens + outputTokens;\n}\n\nfunction splitInputTokensForCost(entry) {\n  const inputTokens = Math.max(0, Number(entry?.inputTokens || 0));\n  const cachedInputTokens = Math.max(0, Number(entry?.cachedInputTokens || 0));\n  if (isCacheAdjustedEntry(entry)) {\n    return { uncachedInputTokens: inputTokens, cachedInputTokens };\n  }\n  const cached = Math.min(cachedInputTokens, inputTokens);\n  return { uncachedInputTokens: Math.max(0, inputTokens - cached), cachedInputTokens: cached };\n}\n\nfunction formatDuration(ms) {\n  const n = Number(ms);\n  if (!Number.isFinite(n)) return \"0.00s\";\n  return `${(n / 1000).toFixed(2)}s`;\n}\n\nfunction formatTime(ts) {\n  try {\n    const d = new Date(ts);\n    return d.toLocaleTimeString(\"fr-FR\", { hour: \"2-digit\", minute: \"2-digit\" });\n  } catch {\n    return \"--:--\";\n  }\n}\n\nfunction formatDate(ts) {\n  try {\n    const d = new Date(ts);\n    return d.toLocaleDateString(\"fr-FR\", { year: \"numeric\", month: \"short\", day: \"2-digit\" });\n  } catch {\n    return \"\";\n  }\n}\n\nfunction formatDateTime(ts) {\n  try {\n    const d = new Date(ts);\n    return d.toLocaleString(\"fr-FR\", { year: \"numeric\", month: \"short\", day: \"2-digit\", hour: \"2-digit\", minute: \"2-digit\" });\n  } catch {\n    return \"\";\n  }\n}\n\nfunction formatBytes(bytes) {\n  const n = Number(bytes);\n  if (!Number.isFinite(n) || n <= 0) return \"0 KB\";\n  if (n < 1024) return `${n} B`;\n  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;\n  return `${(n / (1024 * 1024)).toFixed(2)} MB`;\n}\n\nfunction normalizeInterfaceMode(value) {\n  const mode = String(value || \"\").trim().toLowerCase();\n  if (mode === INTERFACE_MODES.SIMPLE) return INTERFACE_MODES.SIMPLE;\n  return INTERFACE_MODES.ADVANCED;\n}\n\nfunction setCollapsedState(section, collapsed) {\n  if (!section) return;\n  section.classList.toggle(\"is-collapsed\", !!collapsed);\n  const toggle = section.querySelector(\"[data-collapse-toggle]\");\n  if (toggle) toggle.setAttribute(\"aria-expanded\", collapsed ? \"false\" : \"true\");\n}\n\nfunction updateInterfaceModeButtons(mode) {\n  const simple = mode === INTERFACE_MODES.SIMPLE;\n  const simpleBtn = el(\"interfaceModeSimple\");\n  const advancedBtn = el(\"interfaceModeAdvanced\");\n  if (simpleBtn) {\n    simpleBtn.classList.toggle(\"segmented__btn--active\", simple);\n    simpleBtn.setAttribute(\"aria-pressed\", simple ? \"true\" : \"false\");\n  }\n  if (advancedBtn) {\n    advancedBtn.classList.toggle(\"segmented__btn--active\", !simple);\n    advancedBtn.setAttribute(\"aria-pressed\", !simple ? \"true\" : \"false\");\n  }\n}\n\nfunction updateInterfaceModeCopy(mode) {\n  const simple = mode === INTERFACE_MODES.SIMPLE;\n  const modeHint = el(\"interfaceModeHint\");\n  if (modeHint) {\n    modeHint.textContent = simple\n      ? \"Simple: vue epuree, infos essentielles uniquement pour demarrer rapidement.\"\n      : \"Avanc: affichage complet avec logs, cache, diagnostics et rglages experts.\";\n  }\n\n  const settingsSubtitle = document.querySelector(\"#settingsModal .settings-page__subtitle\");\n  if (settingsSubtitle) {\n    settingsSubtitle.textContent = simple\n      ? \"Mode simplifi: licence et cls API en priorit\"\n      : \"Cls API, licence, modles et effort de raisonnement\";\n  }\n\n  const configSubtitle = document.querySelector('[data-section=\"config\"] .card__subtitle');\n  if (configSubtitle) {\n    configSubtitle.textContent = simple\n      ? \"Choisissez un fournisseur et la longueur de rponse.\"\n      : \"Modle, effort et tokens.\";\n  }\n\n  const usageSubtitle = document.querySelector('[data-section=\"usage\"] .card__subtitle');\n  if (usageSubtitle) {\n    usageSubtitle.textContent = simple\n      ? \"Rsum rapide de votre consommation.\"\n      : \"Suivi des tokens et estimation de cots\";\n  }\n\n  const providerLabel = document.querySelector(\"#configProviderRow label\");\n  if (providerLabel) {\n    providerLabel.textContent = simple ? \"Fournisseur AI\" : \"Fournisseur par dfaut\";\n  }\n\n  const maxTokensLabel = document.querySelector(\"#configMaxTokensRow label\");\n  if (maxTokensLabel) {\n    maxTokensLabel.textContent = simple ? \"Longueur des rponses\" : \"Max output tokens\";\n  }\n}\n\nfunction applyInterfaceMode(mode, options = {}) {\n  const { silent = true } = options;\n  const normalized = normalizeInterfaceMode(mode);\n  const simple = normalized === INTERFACE_MODES.SIMPLE;\n  interfaceMode = normalized;\n\n  document.body.classList.toggle(\"mode-simple\", simple);\n  document.body.classList.toggle(\"mode-advanced\", !simple);\n  document.body.dataset.interfaceMode = normalized;\n\n  updateInterfaceModeButtons(normalized);\n  updateInterfaceModeCopy(normalized);\n\n  if (simple) {\n    setCollapsedState(document.querySelector('[data-section=\"config\"]'), false);\n    setCollapsedState(document.querySelector('[data-section=\"usage\"]'), false);\n    closeAllHelpPopups();\n  }\n\n  if (!silent) {\n    const label = simple ? \"Simple\" : \"Avanc\";\n    setStatus(`Mode ${label} activ`, { interfaceMode: normalized });\n    showToast(`Mode ${label} activ`);\n  }\n}\n\nasync function refreshInterfaceMode(options = {}) {\n  const { silent = true } = options;\n  const mode = await getInterfaceMode();\n  applyInterfaceMode(mode, { silent });\n  return mode;\n}\n\nasync function saveInterfaceMode(mode) {\n  const normalized = normalizeInterfaceMode(mode);\n  if (normalized === interfaceMode) return normalized;\n  const saved = await setInterfaceMode(normalized);\n  applyInterfaceMode(saved, { silent: false });\n  return saved;\n}\n\nfunction getSectionKey(section) {\n  return String(section?.dataset?.section || \"\").trim();\n}\n\nfunction getSectionTitle(section) {\n  const label = section?.dataset?.sectionTitle;\n  if (label) return label;\n  const title = section?.querySelector?.(\".card__title\");\n  return title ? title.textContent.trim() : getSectionKey(section);\n}\n\nfunction isSectionLocked(section) {\n  return section?.dataset?.sectionLocked === \"true\";\n}\n\nfunction normalizeSectionOrder(storedOrder, keysInDom) {\n  const order = [];\n  const seen = new Set();\n  if (Array.isArray(storedOrder)) {\n    for (const key of storedOrder) {\n      if (!key || seen.has(key) || !sectionElements.has(key)) continue;\n      seen.add(key);\n      order.push(key);\n    }\n  }\n  for (const key of keysInDom) {\n    if (!key || seen.has(key)) continue;\n    seen.add(key);\n    order.push(key);\n  }\n  return order;\n}\n\nfunction applySectionOrder(order) {\n  if (!sectionMain) sectionMain = document.querySelector(\".app__main\");\n  if (!sectionMain) return;\n  const settingsCard = document.querySelector(SECTION_SETTINGS_SELECTOR);\n  for (const key of order) {\n    const section = sectionElements.get(key);\n    if (!section) continue;\n    if (settingsCard) sectionMain.insertBefore(section, settingsCard);\n    else sectionMain.appendChild(section);\n  }\n}\n\nfunction applySectionVisibility(hidden) {\n  sectionElements.forEach((section, key) => {\n    const locked = isSectionLocked(section);\n    const shouldHide = hidden.has(key) && !locked;\n    section.classList.toggle(SECTION_HIDDEN_CLASS, shouldHide);\n  });\n}\n\nfunction pruneHiddenSections() {\n  let changed = false;\n  for (const key of Array.from(hiddenSections)) {\n    const section = sectionElements.get(key);\n    if (!section || isSectionLocked(section)) {\n      hiddenSections.delete(key);\n      changed = true;\n    }\n  }\n  if (changed) void setHiddenSections(Array.from(hiddenSections));\n}\n\nfunction updateSectionOrder(nextOrder, options = {}) {\n  const { persist = true } = options;\n  sectionOrder = nextOrder.slice();\n  applySectionOrder(sectionOrder);\n  renderSectionManager();\n  if (persist) void setSectionOrder(sectionOrder);\n}\n\nfunction resetSectionOrder() {\n  if (!defaultSectionOrder.length) return;\n  updateSectionOrder(defaultSectionOrder);\n}\n\nfunction updateHiddenSections(nextHidden, options = {}) {\n  const { persist = true } = options;\n  hiddenSections = new Set(nextHidden);\n  pruneHiddenSections();\n  applySectionVisibility(hiddenSections);\n  renderSectionManager();\n  if (persist) void setHiddenSections(Array.from(hiddenSections));\n  updateOnboardingVisibility();\n}\n\nfunction moveSection(key, delta) {\n  const idx = sectionOrder.indexOf(key);\n  if (idx < 0) return;\n  const nextIdx = idx + delta;\n  if (nextIdx < 0 || nextIdx >= sectionOrder.length) return;\n  const next = sectionOrder.slice();\n  next.splice(idx, 1);\n  next.splice(nextIdx, 0, key);\n  updateSectionOrder(next);\n}\n\nfunction reorderSectionList(order, draggedKey, targetKey, before) {\n  const next = order.filter((key) => key !== draggedKey);\n  const targetIndex = next.indexOf(targetKey);\n  if (targetIndex < 0) {\n    next.push(draggedKey);\n    return next;\n  }\n  const insertIndex = before ? targetIndex : targetIndex + 1;\n  next.splice(insertIndex, 0, draggedKey);\n  return next;\n}\n\nfunction moveSectionToEnd(order, key) {\n  const next = order.filter((item) => item !== key);\n  next.push(key);\n  return next;\n}\n\nfunction clearDropIndicators(list) {\n  list.querySelectorAll(\".section-row\").forEach((row) => {\n    row.classList.remove(\"is-drop-before\", \"is-drop-after\");\n  });\n}\n\nfunction clearDragState(list) {\n  list.querySelectorAll(\".section-row\").forEach((row) => {\n    row.classList.remove(\"is-drop-before\", \"is-drop-after\", \"is-dragging\");\n  });\n}\n\nfunction renderSectionManager() {\n  const list = el(\"sectionManagerList\");\n  if (!list) return;\n  list.innerHTML = \"\";\n\n  const order = sectionOrder.length ? sectionOrder : Array.from(sectionElements.keys());\n  order.forEach((key, index) => {\n    const section = sectionElements.get(key);\n    if (!section) return;\n\n    const label = getSectionTitle(section);\n    const locked = isSectionLocked(section);\n    const visible = !hiddenSections.has(key) || locked;\n\n    const row = document.createElement(\"div\");\n    row.className = \"section-row\";\n    row.dataset.sectionKey = key;\n    row.setAttribute(\"role\", \"listitem\");\n\n    const handle = document.createElement(\"button\");\n    handle.type = \"button\";\n    handle.className = \"section-row__handle\";\n    handle.draggable = true;\n    handle.setAttribute(\"title\", \"Glisser pour dplacer\");\n    handle.setAttribute(\"aria-label\", `Dplacer ${label}`);\n\n    const labelEl = document.createElement(\"div\");\n    labelEl.className = \"section-row__label\";\n    labelEl.textContent = label;\n\n    const controls = document.createElement(\"div\");\n    controls.className = \"section-row__controls\";\n\n    const upBtn = document.createElement(\"button\");\n    upBtn.type = \"button\";\n    upBtn.className = \"move-btn move-btn--up\";\n    upBtn.disabled = index === 0;\n    upBtn.setAttribute(\"title\", \"Monter\");\n    upBtn.setAttribute(\"aria-label\", `Monter ${label}`);\n    upBtn.addEventListener(\"click\", () => moveSection(key, -1));\n\n    const downBtn = document.createElement(\"button\");\n    downBtn.type = \"button\";\n    downBtn.className = \"move-btn move-btn--down\";\n    downBtn.disabled = index === order.length - 1;\n    downBtn.setAttribute(\"title\", \"Descendre\");\n    downBtn.setAttribute(\"aria-label\", `Descendre ${label}`);\n    downBtn.addEventListener(\"click\", () => moveSection(key, 1));\n\n    const toggleWrap = document.createElement(\"label\");\n    toggleWrap.className = \"visibility-toggle\";\n    toggleWrap.setAttribute(\"title\", locked ? \"Toujours visible\" : visible ? \"Masquer\" : \"Afficher\");\n    const toggleInput = document.createElement(\"input\");\n    toggleInput.type = \"checkbox\";\n    toggleInput.checked = visible;\n    toggleInput.disabled = locked;\n    toggleInput.setAttribute(\"aria-label\", locked ? `${label} toujours visible` : `Afficher ${label}`);\n    const toggleSlider = document.createElement(\"span\");\n    toggleSlider.className = \"visibility-toggle__slider\";\n    toggleWrap.appendChild(toggleInput);\n    toggleWrap.appendChild(toggleSlider);\n    toggleInput.addEventListener(\"change\", () => {\n      if (locked) return;\n      if (toggleInput.checked) hiddenSections.delete(key);\n      else hiddenSections.add(key);\n      applySectionVisibility(hiddenSections);\n      void setHiddenSections(Array.from(hiddenSections));\n      renderSectionManager();\n    });\n\n    controls.appendChild(upBtn);\n    controls.appendChild(downBtn);\n    if (locked) {\n      const lockTag = document.createElement(\"span\");\n      lockTag.className = \"section-row__lock\";\n      lockTag.textContent = \"Fixe\";\n      lockTag.setAttribute(\"title\", \"Toujours visible\");\n      controls.appendChild(lockTag);\n    }\n    controls.appendChild(toggleWrap);\n\n    row.appendChild(handle);\n    row.appendChild(labelEl);\n    row.appendChild(controls);\n    list.appendChild(row);\n  });\n}\n\nfunction initSectionDrag() {\n  const list = el(\"sectionManagerList\");\n  if (!list) return;\n\n  list.addEventListener(\"dragstart\", (event) => {\n    const handle = event.target.closest(\".section-row__handle\");\n    if (!handle) return;\n    const row = handle.closest(\".section-row\");\n    if (!row) return;\n    draggingSectionKey = row.dataset.sectionKey || \"\";\n    row.classList.add(\"is-dragging\");\n    if (event.dataTransfer) {\n      event.dataTransfer.effectAllowed = \"move\";\n      event.dataTransfer.setData(\"text/plain\", draggingSectionKey);\n    }\n  });\n\n  list.addEventListener(\"dragover\", (event) => {\n    if (!draggingSectionKey) return;\n    event.preventDefault();\n    const row = event.target.closest(\".section-row\");\n    if (!row || row.dataset.sectionKey === draggingSectionKey) return;\n    clearDropIndicators(list);\n    const rect = row.getBoundingClientRect();\n    const before = event.clientY < rect.top + rect.height / 2;\n    row.classList.toggle(\"is-drop-before\", before);\n    row.classList.toggle(\"is-drop-after\", !before);\n  });\n\n  list.addEventListener(\"dragleave\", (event) => {\n    const row = event.target.closest(\".section-row\");\n    if (!row) return;\n    row.classList.remove(\"is-drop-before\", \"is-drop-after\");\n  });\n\n  list.addEventListener(\"drop\", (event) => {\n    if (!draggingSectionKey) return;\n    event.preventDefault();\n    const row = event.target.closest(\".section-row\");\n    const targetKey = row ? row.dataset.sectionKey || \"\" : \"\";\n    const key = draggingSectionKey;\n    draggingSectionKey = \"\";\n    clearDragState(list);\n\n    let nextOrder = sectionOrder.slice();\n    if (!targetKey) {\n      nextOrder = moveSectionToEnd(nextOrder, key);\n    } else {\n      const rect = row.getBoundingClientRect();\n      const before = event.clientY < rect.top + rect.height / 2;\n      nextOrder = reorderSectionList(nextOrder, key, targetKey, before);\n    }\n    updateSectionOrder(nextOrder);\n  });\n\n  list.addEventListener(\"dragend\", () => {\n    draggingSectionKey = \"\";\n    clearDragState(list);\n  });\n}\n\nasync function initSectionManager() {\n  sectionMain = document.querySelector(\".app__main\");\n  if (!sectionMain) return;\n  const sections = Array.from(sectionMain.querySelectorAll(SECTION_SELECTOR));\n  sectionElements = new Map();\n  sections.forEach((section) => {\n    const key = getSectionKey(section);\n    if (key) sectionElements.set(key, section);\n  });\n\n  const storedOrder = await getSectionOrder();\n  const domKeys = sections.map((section) => getSectionKey(section)).filter(Boolean);\n  defaultSectionOrder = domKeys.slice();\n  sectionOrder = normalizeSectionOrder(storedOrder, domKeys);\n  applySectionOrder(sectionOrder);\n\n  hiddenSections = new Set(await getHiddenSections());\n  pruneHiddenSections();\n  applySectionVisibility(hiddenSections);\n\n  renderSectionManager();\n  initSectionDrag();\n}\n\nconst TOKEN_EXP_MIN = 7;\nconst TOKEN_EXP_MAX = 17;\nconst MAX_OUTPUT_TOKENS = 128000;\nconst CONCURRENCY_LEVELS = [4, 8, 16, 32, 64, 128];\nconst RPM_MIN = 0;\nconst RPM_MAX = 100000;\nconst UNKNOWN_MODEL_LABEL = \"modele inconnu\";\nconst GEMINI_REASONING_LEVELS = [\"auto\", \"minimal\", \"low\", \"medium\", \"high\"];\nconst OPENAI_REASONING_LEVELS = [\"none\", \"minimal\", \"low\", \"medium\", \"high\"];\nconst HELP_SELECTOR = \"[data-help]\";\nconst SECTION_SELECTOR = \"[data-section]\";\nconst SECTION_SETTINGS_SELECTOR = \"[data-section-settings]\";\nconst SECTION_HIDDEN_CLASS = \"is-section-hidden\";\nconst INTERFACE_MODES = Object.freeze({\n  SIMPLE: \"simple\",\n  ADVANCED: \"advanced\"\n});\nconst KEY_INPUT_SELECTOR = \"[data-key-input]\";\nconst KEY_STATUS_SELECTOR = \"[data-key-status]\";\nconst KEY_SAVE_SELECTOR = \"[data-key-save]\";\nconst LICENSE_INPUT_SELECTOR = \"[data-license-input]\";\nconst LICENSE_STATUS_SELECTOR = \"[data-license-status]\";\nconst LICENSE_META_SELECTOR = \"[data-license-meta]\";\n\nlet keyState = { gemini: false, openai: false };\nlet licenseState = null;\nlet licenseEntryChoice = null;\nlet keysLoaded = false;\nlet licenseLoaded = false;\nlet onboardingKeysConfirmed = false;\nlet onboardingKeysLoaded = false;\nlet privacyModeEnabled = false;\nlet interfaceMode = INTERFACE_MODES.ADVANCED;\nlet sectionOrder = [];\nlet defaultSectionOrder = [];\nlet hiddenSections = new Set();\nlet sectionElements = new Map();\nlet draggingSectionKey = \"\";\nlet sectionMain = null;\nconst expandedLogKeys = new Set();\nlet toastTimer = null;\nlet logErrorsOnly = false;\nlet lastUsageLogs = [];\nlet rpmLimitValue = DEFAULTS.rpmLimit;\n\nconst DEFAULT_MODELS = {\n  gemini: DEFAULTS.geminiModel,\n  openai: DEFAULTS.openaiModel\n};\n\nconst MODEL_CATALOG = {\n  gemini: [\n    {\n      id: \"gemini-3-pro-preview\",\n      label: \"Gemini 3 Pro Preview\",\n      prices: { input: 2, output: 12, cachedInput: 0.2 },\n      costLevel: 3,\n      reasoningLevel: 3,\n      warning: true\n    },\n    {\n      id: \"gemini-3-flash-preview\",\n      label: \"Gemini 3 Flash Preview\",\n      prices: { input: 0.5, output: 3, cachedInput: 0.05 },\n      costLevel: 2,\n      reasoningLevel: 2,\n      recommended: true\n    },\n    {\n      id: \"gemini-2.5-flash-lite\",\n      label: \"Gemini 2.5 Flash Lite\",\n      prices: { input: 0.1, output: 0.4, cachedInput: 0.01 },\n      costLevel: 1,\n      reasoningLevel: 1\n    }\n  ],\n  openai: [\n    {\n      id: \"gpt-5.2\",\n      label: \"GPT-5.2\",\n      prices: { input: 1.75, output: 14, cachedInput: 0.175 },\n      costLevel: 3,\n      reasoningLevel: 3,\n      supportsReasoningNone: true,\n      warning: true\n    },\n    {\n      id: \"gpt-5-mini\",\n      label: \"GPT-5 Mini\",\n      prices: { input: 0.25, output: 2, cachedInput: 0.025 },\n      costLevel: 2,\n      reasoningLevel: 2,\n      recommended: true,\n      supportsReasoningNone: false\n    },\n    {\n      id: \"gpt-5-nano\",\n      label: \"GPT-5 Nano\",\n      prices: { input: 0.05, output: 0.4, cachedInput: 0.005 },\n      costLevel: 1,\n      reasoningLevel: 1,\n      supportsReasoningNone: false\n    }\n  ]\n};\n\nconst GEMINI_CACHE_STORAGE_RATE = 1.0; // /1M token-hours (text)\n\nconst MODEL_LOOKUP = {\n  gemini: new Map(MODEL_CATALOG.gemini.map((m) => [m.id.toLowerCase(), m])),\n  openai: new Map(MODEL_CATALOG.openai.map((m) => [m.id.toLowerCase(), m]))\n};\n\nconst PROVIDER_LABELS = {\n  gemini: \"Gemini\",\n  openai: \"OpenAI\"\n};\n\nfunction repeatIcon(icon, level) {\n  const count = Math.max(1, Number(level) || 1);\n  return new Array(count + 1).join(icon);\n}\n\nfunction getModelMeta(provider, model) {\n  const p = String(provider || \"\").toLowerCase();\n  const key = String(model || \"\").trim().toLowerCase();\n  const map = MODEL_LOOKUP[p];\n  if (map && key && map.has(key)) return map.get(key);\n  const fallback = DEFAULT_MODELS[p];\n  if (map && fallback && map.has(fallback.toLowerCase())) return map.get(fallback.toLowerCase());\n  return null;\n}\n\nfunction openaiModelAllowsNone(model) {\n  const key = String(model || \"\").trim().toLowerCase();\n  const meta = MODEL_LOOKUP.openai?.get(key);\n  if (meta && typeof meta.supportsReasoningNone === \"boolean\") return meta.supportsReasoningNone;\n  return true;\n}\n\nfunction getGeminiAllowedReasoningLevels(modelId) {\n  const key = String(modelId || \"\").trim().toLowerCase();\n  if (key.includes(\"gemini-3\") && key.includes(\"flash\")) {\n    return [\"auto\", \"minimal\", \"low\", \"medium\", \"high\"];\n  }\n  if (key.includes(\"gemini-3\")) {\n    return [\"auto\", \"low\", \"high\"];\n  }\n  if (key.includes(\"gemini-2.5\")) {\n    return [\"auto\", \"minimal\", \"low\", \"medium\", \"high\"];\n  }\n  return [\"auto\", \"low\", \"high\"];\n}\n\nfunction coerceReasoningLabel(label, allowed, levels) {\n  if (!label) return allowed[0] || \"\";\n  if (allowed.includes(label)) return label;\n  const idx = levels.indexOf(label);\n  if (idx < 0) return allowed[0] || \"\";\n  let best = allowed[0] || \"\";\n  let bestDist = Number.POSITIVE_INFINITY;\n  for (const option of allowed) {\n    const optIdx = levels.indexOf(option);\n    if (optIdx < 0) continue;\n    const dist = Math.abs(optIdx - idx);\n    if (dist < bestDist) {\n      bestDist = dist;\n      best = option;\n    }\n  }\n  return best;\n}\n\nfunction syncGeminiReasoningEffort(modelId, preferred) {\n  const effortEl = el(\"geminiReasoningEffort\");\n  if (!effortEl) return \"\";\n  const allowed = getGeminiAllowedReasoningLevels(modelId);\n  let label = getReasoningEffortLabel(preferred, GEMINI_REASONING_LEVELS);\n  if (!label) label = GEMINI_REASONING_LEVELS[0];\n  if (!allowed.includes(label)) {\n    if (label === \"minimal\") label = \"low\";\n    if (label === \"medium\") label = \"high\";\n  }\n  label = coerceReasoningLabel(label, allowed, GEMINI_REASONING_LEVELS);\n  const index = GEMINI_REASONING_LEVELS.indexOf(label);\n  effortEl.value = String(index >= 0 ? index : 0);\n  effortEl.setAttribute(\"aria-valuetext\", label);\n  return label;\n}\n\nfunction getReasoningEffortLabel(value, levels = OPENAI_REASONING_LEVELS) {\n  const raw = String(value || \"\").trim().toLowerCase();\n  if (!raw) return \"\";\n  const idx = Number(raw);\n  if (Number.isFinite(idx)) {\n    const clamped = Math.min(levels.length - 1, Math.max(0, Math.round(idx)));\n    return levels[clamped] || \"\";\n  }\n  return raw;\n}\n\nfunction syncOpenAIReasoningEffort(modelId, preferred) {\n  const effortEl = el(\"openaiReasoningEffort\");\n  if (!effortEl) return \"\";\n  const allowNone = openaiModelAllowsNone(modelId);\n  const wrap = effortEl.closest(\".reasoning\");\n  if (wrap) wrap.classList.toggle(\"reasoning--no-none\", !allowNone);\n  effortEl.dataset.allowNone = allowNone ? \"1\" : \"0\";\n\n  const allowed = allowNone ? OPENAI_REASONING_LEVELS : OPENAI_REASONING_LEVELS.slice(1);\n  let next = getReasoningEffortLabel(preferred);\n  if (!allowed.includes(next)) {\n    next = allowed[0] || \"minimal\";\n  }\n  const index = OPENAI_REASONING_LEVELS.indexOf(next);\n  effortEl.value = String(index >= 0 ? index : 0);\n  effortEl.setAttribute(\"aria-valuetext\", next);\n  return next;\n}\n\nfunction formatRate(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return `${CURRENCY_SYMBOL}0`;\n  const decimals = n >= 1 ? 2 : 3;\n  let text = n.toFixed(decimals);\n  text = text.replace(/\\.?0+$/, \"\");\n  return `${CURRENCY_SYMBOL}${text}`;\n}\n\nfunction modelIndicators(meta) {\n  return {\n    cost: repeatIcon(COST_ICON, meta.costLevel),\n    reasoning: repeatIcon(REASON_ICON, meta.reasoningLevel)\n  };\n}\n\nfunction modelOptionLabel(meta) {\n  const indicators = modelIndicators(meta);\n  const favorite = meta.recommended ? `${FAVORITE_ICON} ` : \"\";\n  const warning = meta.warning ? \"! \" : \"\";\n  return `${warning}${favorite}${meta.id} | ${indicators.cost} | ${indicators.reasoning}`;\n}\n\nfunction updateModelWarningBadge(provider, modelId) {\n  const isGemini = provider === PROVIDERS.GEMINI;\n  const selectEl = isGemini ? el(\"geminiModel\") : el(\"openaiModel\");\n  const warningEl = isGemini ? el(\"geminiModelWarning\") : el(\"openaiModelWarning\");\n  if (!selectEl || !warningEl) return;\n  const meta = getModelMeta(provider, modelId || selectEl.value);\n  const show = !!meta?.warning;\n  warningEl.classList.toggle(\"is-hidden\", !show);\n  selectEl.classList.toggle(\"input--warning\", show);\n}\n\nfunction estimateCost(entry) {\n  if (!entry) return 0;\n  if (entry.fn === \"AI.BATCH\") {\n    const provider = String(entry.provider || \"\").toLowerCase();\n    const meta = getModelMeta(provider, entry.model);\n    if (!meta) return 0;\n\n    const { uncachedInputTokens, cachedInputTokens } = splitInputTokensForCost(entry);\n    const outputTokens = Math.max(0, Number(entry.outputTokens || 0));\n    const reasoningTokens = Math.max(0, Number(entry.reasoningTokens || 0));\n    const cacheStorageTokenHours = Math.max(0, Number(entry.cacheStorageTokenHours || 0));\n    const billableOutputTokens = outputTokens + reasoningTokens;\n\n    const prices = meta.prices || {};\n    const inputRate = Number(prices.input || 0);\n    const cachedRate = Number(prices.cachedInput ?? prices.input ?? 0);\n    const outputRate = Number(prices.output || 0);\n\n    let cost = (uncachedInputTokens / 1e6) * inputRate\n      + (cachedInputTokens / 1e6) * cachedRate\n      + (billableOutputTokens / 1e6) * outputRate;\n    if (provider === PROVIDERS.GEMINI && cacheStorageTokenHours > 0) {\n      cost += (cacheStorageTokenHours / 1e6) * GEMINI_CACHE_STORAGE_RATE;\n    }\n    return cost;\n  }\n  if (entry.batch && Array.isArray(entry.batchModels)) {\n    return entry.batchModels.reduce((sum, item) => {\n      if (!item) return sum;\n      return sum + estimateCost({\n        provider: item.provider,\n        model: item.model,\n        inputTokens: item.inputTokens,\n        outputTokens: item.outputTokens,\n        reasoningTokens: item.reasoningTokens,\n        cachedInputTokens: item.cachedInputTokens,\n        cacheStorageTokenHours: item.cacheStorageTokenHours,\n        cacheAdjusted: !!item.cacheAdjusted\n      });\n    }, 0);\n  }\n  const provider = String(entry.provider || \"\").toLowerCase();\n  const meta = getModelMeta(provider, entry.model);\n  if (!meta) return 0;\n\n  const outputTokens = Math.max(0, Number(entry.outputTokens || 0));\n  const reasoningTokens = Math.max(0, Number(entry.reasoningTokens || 0));\n  const cacheStorageTokenHours = Math.max(0, Number(entry.cacheStorageTokenHours || 0));\n  const billableOutputTokens = outputTokens + reasoningTokens;\n\n  const { uncachedInputTokens, cachedInputTokens: billableCachedInputTokens } = splitInputTokensForCost(entry);\n\n  const prices = meta.prices || {};\n  const inputRate = Number(prices.input || 0);\n  const cachedRate = Number(prices.cachedInput ?? prices.input ?? 0);\n  const outputRate = Number(prices.output || 0);\n\n  let cost = (uncachedInputTokens / 1e6) * inputRate\n    + (billableCachedInputTokens / 1e6) * cachedRate\n    + (billableOutputTokens / 1e6) * outputRate;\n  if (provider === PROVIDERS.GEMINI && cacheStorageTokenHours > 0) {\n    cost += (cacheStorageTokenHours / 1e6) * GEMINI_CACHE_STORAGE_RATE;\n  }\n  return cost;\n}\n\nfunction coerceCount(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return Math.floor(n);\n}\n\nfunction coerceFloat(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n) || n <= 0) return 0;\n  return n;\n}\n\nfunction buildUsageFromTotals(totals) {\n  const safeTotals = totals && typeof totals === \"object\" ? totals : {};\n  const breakdown = {\n    gemini: { tokens: 0, cost: 0, models: new Map() },\n    openai: { tokens: 0, cost: 0, models: new Map() }\n  };\n\n  const total = {\n    inputTokens: coerceCount(safeTotals.inputTokens),\n    reasoningTokens: coerceCount(safeTotals.reasoningTokens),\n    outputTokens: coerceCount(safeTotals.outputTokens),\n    cachedInputTokens: coerceCount(safeTotals.cachedInputTokens),\n    cacheStorageTokenHours: coerceFloat(safeTotals.cacheStorageTokenHours),\n    cost: 0,\n    requests: coerceCount(safeTotals.requests),\n    byProvider: {\n      gemini: { tokens: 0, cost: 0 },\n      openai: { tokens: 0, cost: 0 }\n    }\n  };\n\n  const providerSums = {\n    gemini: { input: 0, output: 0, reasoning: 0, cached: 0, cacheStorageTokenHours: 0 },\n    openai: { input: 0, output: 0, reasoning: 0, cached: 0, cacheStorageTokenHours: 0 }\n  };\n\n  for (const provider of [PROVIDERS.GEMINI, PROVIDERS.OPENAI]) {\n    const providerTotals = safeTotals.byProvider && typeof safeTotals.byProvider === \"object\" ? safeTotals.byProvider[provider] : null;\n    const inputTokens = coerceCount(providerTotals?.inputTokens);\n    const outputTokens = coerceCount(providerTotals?.outputTokens);\n    const reasoningTokens = coerceCount(providerTotals?.reasoningTokens);\n    const cachedInputTokens = coerceCount(providerTotals?.cachedInputTokens);\n    const cacheStorageTokenHours = coerceFloat(providerTotals?.cacheStorageTokenHours);\n    providerSums[provider] = {\n      input: inputTokens,\n      output: outputTokens,\n      reasoning: reasoningTokens,\n      cached: cachedInputTokens,\n      cacheStorageTokenHours\n    };\n\n    const models = providerTotals?.models && typeof providerTotals.models === \"object\" ? providerTotals.models : {};\n    let providerTokens = 0;\n    let providerCost = 0;\n    let modelStorageSum = 0;\n\n    for (const [key, value] of Object.entries(models)) {\n      if (!value || typeof value !== \"object\") continue;\n      const modelInput = coerceCount(value.inputTokens);\n      const modelOutput = coerceCount(value.outputTokens);\n      const modelReasoning = coerceCount(value.reasoningTokens);\n      const modelCached = coerceCount(value.cachedInputTokens);\n      const modelCacheStorageTokenHours = coerceFloat(value.cacheStorageTokenHours);\n      const tokens = modelInput + modelOutput + modelReasoning;\n      if (tokens <= 0 && modelCached <= 0) continue;\n\n      const rawLabel = typeof value.label === \"string\" ? value.label : \"\";\n      const modelKey = String(key || \"\").trim();\n      const modelId = (rawLabel || modelKey).trim();\n      const isUnknown = !modelId || modelId.toLowerCase() === \"unknown\";\n      const label = isUnknown ? UNKNOWN_MODEL_LABEL : modelId;\n      const cost = estimateCost({\n        provider,\n        model: isUnknown ? \"\" : modelId,\n        inputTokens: modelInput,\n        outputTokens: modelOutput,\n        reasoningTokens: modelReasoning,\n        cachedInputTokens: modelCached,\n        cacheStorageTokenHours: modelCacheStorageTokenHours,\n        cacheAdjusted: provider === PROVIDERS.GEMINI\n      });\n\n      const mapKey = label.toLowerCase();\n      const modelEntry = breakdown[provider].models.get(mapKey) || { label, tokens: 0, cost: 0 };\n      modelEntry.tokens += tokens;\n      modelEntry.cost += cost;\n      breakdown[provider].models.set(mapKey, modelEntry);\n\n      providerTokens += tokens;\n      providerCost += cost;\n      modelStorageSum += modelCacheStorageTokenHours;\n    }\n\n    if (provider === PROVIDERS.GEMINI) {\n      const missingStorage = Math.max(0, providerSums[provider].cacheStorageTokenHours - modelStorageSum);\n      if (missingStorage > 0) {\n        providerCost += (missingStorage / 1e6) * GEMINI_CACHE_STORAGE_RATE;\n      }\n    }\n\n    if (providerTokens === 0) {\n      providerTokens = inputTokens + outputTokens + reasoningTokens;\n    }\n\n    breakdown[provider].tokens = providerTokens;\n    breakdown[provider].cost = providerCost;\n    total.byProvider[provider].tokens = providerTokens;\n    total.byProvider[provider].cost = providerCost;\n  }\n\n  if (!total.inputTokens) {\n    total.inputTokens = providerSums.gemini.input + providerSums.openai.input;\n  }\n  if (!total.outputTokens) {\n    total.outputTokens = providerSums.gemini.output + providerSums.openai.output;\n  }\n  if (!total.reasoningTokens) {\n    total.reasoningTokens = providerSums.gemini.reasoning + providerSums.openai.reasoning;\n  }\n  if (!total.cachedInputTokens) {\n    total.cachedInputTokens = providerSums.gemini.cached + providerSums.openai.cached;\n  }\n  if (!total.cacheStorageTokenHours) {\n    total.cacheStorageTokenHours = providerSums.gemini.cacheStorageTokenHours + providerSums.openai.cacheStorageTokenHours;\n  }\n\n  total.cost = total.byProvider.gemini.cost + total.byProvider.openai.cost;\n  return { total, breakdown };\n}\n\nfunction normalizeUsageEntry(entry) {\n  const batchModels = Array.isArray(entry?.batchModels)\n    ? entry.batchModels.map((item) => ({\n      provider: String(item?.provider || \"\").toLowerCase(),\n      model: String(item?.model || \"\").trim(),\n      inputTokens: Number(item?.inputTokens || 0),\n      outputTokens: Number(item?.outputTokens || 0),\n      reasoningTokens: Number(item?.reasoningTokens || 0),\n      cachedInputTokens: Number(item?.cachedInputTokens || 0),\n      cacheStorageTokenHours: Number(item?.cacheStorageTokenHours || 0),\n      requests: Number(item?.requests || 0),\n      cacheAdjusted: !!item?.cacheAdjusted\n    }))\n    : [];\n\n  const batchStats = entry?.batchStats && typeof entry.batchStats === \"object\"\n    ? {\n      totalRequests: Number(entry.batchStats.totalRequests || 0),\n      ok: Number(entry.batchStats.ok || 0),\n      error: Number(entry.batchStats.error || 0),\n      cached: Number(entry.batchStats.cached || 0),\n      avgMs: Number(entry.batchStats.avgMs || 0),\n      maxMs: Number(entry.batchStats.maxMs || 0),\n      minMs: Number(entry.batchStats.minMs || 0),\n      peakQueued: Number(entry.batchStats.peakQueued || 0),\n      peakActive: Number(entry.batchStats.peakActive || 0)\n    }\n    : null;\n\n  return {\n    provider: entry?.provider || \"\",\n    inputTokens: Number(entry?.inputTokens || 0),\n    outputTokens: Number(entry?.outputTokens || 0),\n    reasoningTokens: Number(entry?.reasoningTokens || 0),\n    cachedInputTokens: Number(entry?.cachedInputTokens || 0),\n    cacheStorageTokenHours: Number(entry?.cacheStorageTokenHours || 0),\n    totalTokens: Number(entry?.totalTokens || 0),\n    ok: !!entry?.ok,\n    cache: !!entry?.cache,\n    cacheAdjusted: !!entry?.cacheAdjusted,\n    ms: Number(entry?.ms || 0),\n    fn: entry?.fn || \"AI\",\n    model: entry?.model || \"\",\n    ts: Number(entry?.ts || 0),\n    message: entry?.message || \"\",\n    reasoningEffort: entry?.reasoningEffort || \"\",\n    call: entry?.call || \"\",\n    formula: entry?.formula || \"\",\n    cacheHint: entry?.cacheHint || \"\",\n    batch: !!entry?.batch,\n    batchId: String(entry?.batchId || \"\"),\n    batchLive: !!entry?.batchLive,\n    batchModels,\n    batchStats\n  };\n}\n\nfunction populateModelSelect(provider, selectEl, currentModel) {\n  if (!selectEl) return;\n  const list = MODEL_CATALOG[provider] || [];\n  const requested = String(currentModel || \"\").trim();\n  const requestedKey = requested.toLowerCase();\n  const fallback = DEFAULT_MODELS[provider] || \"\";\n\n  selectEl.innerHTML = \"\";\n  let matched = false;\n\n  for (const meta of list) {\n    const option = document.createElement(\"option\");\n    option.value = meta.id;\n    option.textContent = modelOptionLabel(meta);\n    if (meta.warning) {\n      option.dataset.warning = \"1\";\n      option.style.color = \"#b03524\";\n      option.style.fontWeight = \"700\";\n    }\n    if (meta.id.toLowerCase() === requestedKey) {\n      option.selected = true;\n      matched = true;\n    }\n    selectEl.appendChild(option);\n  }\n\n  if (requested && !matched) {\n    const option = document.createElement(\"option\");\n    option.value = requested;\n    option.textContent = `${requested} | hors liste`;\n    option.selected = true;\n    selectEl.appendChild(option);\n    return;\n  }\n\n  if (!requested && fallback) {\n    selectEl.value = fallback;\n  }\n}\n\nfunction renderPricingTable() {\n  const gemBody = el(\"pricingTableBodyGemini\");\n  const oaiBody = el(\"pricingTableBodyOpenAI\");\n  if (!gemBody && !oaiBody) return;\n  if (gemBody) gemBody.innerHTML = \"\";\n  if (oaiBody) oaiBody.innerHTML = \"\";\n\n  const renderProvider = (provider, body) => {\n    if (!body) return;\n    const list = MODEL_CATALOG[provider] || [];\n    for (const meta of list) {\n      const row = document.createElement(\"tr\");\n      const indicators = modelIndicators(meta);\n\n      const cellModel = document.createElement(\"td\");\n      cellModel.textContent = meta.id;\n\n      const cellInput = document.createElement(\"td\");\n      cellInput.className = \"pricing-table__col-price\";\n      cellInput.textContent = formatRate(meta.prices?.input);\n\n      const cellOutput = document.createElement(\"td\");\n      cellOutput.className = \"pricing-table__col-price\";\n      cellOutput.textContent = formatRate(meta.prices?.output);\n\n      const cellCost = document.createElement(\"td\");\n      cellCost.className = \"pricing-table__col-icon\";\n      cellCost.textContent = indicators.cost;\n\n      const cellReason = document.createElement(\"td\");\n      cellReason.className = \"pricing-table__col-icon\";\n      cellReason.textContent = indicators.reasoning;\n\n      row.appendChild(cellModel);\n      row.appendChild(cellInput);\n      row.appendChild(cellOutput);\n      row.appendChild(cellCost);\n      row.appendChild(cellReason);\n      body.appendChild(row);\n    }\n  };\n\n  renderProvider(PROVIDERS.GEMINI, gemBody);\n  renderProvider(PROVIDERS.OPENAI, oaiBody);\n}\n\nfunction setModalOpen(id, isOpen) {\n  const modal = el(id);\n  if (!modal) return;\n  modal.classList.toggle(\"is-open\", isOpen);\n  modal.setAttribute(\"aria-hidden\", isOpen ? \"false\" : \"true\");\n}\n\nfunction isModalOpen(id) {\n  const modal = el(id);\n  return !!modal && modal.classList.contains(\"is-open\");\n}\n\nfunction setSettingsModalOpen(isOpen) {\n  const settingsPage = el(\"settingsModal\");\n  if (!settingsPage) return;\n  settingsPage.classList.toggle(\"is-open\", !!isOpen);\n  settingsPage.setAttribute(\"aria-hidden\", isOpen ? \"false\" : \"true\");\n  document.body.classList.toggle(\"is-settings-open\", !!isOpen);\n  if (isOpen) {\n    closeAllHelpPopups();\n    el(\"settingsBackButton\")?.focus();\n  } else {\n    el(\"settingsButton\")?.focus();\n  }\n}\n\nfunction setPricingModalOpen(isOpen) {\n  setModalOpen(\"pricingModal\", isOpen);\n}\n\nfunction setOnboardingModalOpen(isOpen) {\n  setModalOpen(\"onboardingModal\", isOpen);\n}\n\nfunction setOnboardingKeysModalOpen(isOpen) {\n  setModalOpen(\"onboardingKeysModal\", isOpen);\n}\n\nfunction openPricingModal() {\n  renderPricingTable();\n  setPricingModalOpen(true);\n}\n\nfunction closePricingModal() {\n  setPricingModalOpen(false);\n}\n\nfunction setKeyStatus(provider, hasKey) {\n  const ok = !!hasKey;\n  document.querySelectorAll(`${KEY_STATUS_SELECTOR}[data-key-status=\"${provider}\"]`).forEach((node) => {\n    node.textContent = ok ? \"Cl enregistre\" : \"Cl manquante\";\n    node.classList.toggle(\"key-status--ok\", ok);\n    node.classList.toggle(\"key-status--missing\", !ok);\n  });\n}\n\nfunction updateKeyPlaceholders() {\n  document.querySelectorAll(KEY_INPUT_SELECTOR).forEach((input) => {\n    const provider = String(input.dataset.keyInput || \"\").trim().toLowerCase();\n    if (provider === PROVIDERS.GEMINI) {\n      input.placeholder = keyState.gemini ? \"Cl enregistre (laisser vide pour conserver)\" : \"AIza...\";\n    } else if (provider === PROVIDERS.OPENAI) {\n      input.placeholder = keyState.openai ? \"Cl enregistre (laisser vide pour conserver)\" : \"sk-...\";\n    }\n  });\n}\n\nfunction setKeyState(geminiPresent, openaiPresent) {\n  keyState = {\n    gemini: !!geminiPresent,\n    openai: !!openaiPresent\n  };\n  updateKeyPlaceholders();\n}\n\nfunction hasAnyApiKey() {\n  return !!keyState.gemini || !!keyState.openai;\n}\n\nfunction hasBothApiKeys() {\n  return !!keyState.gemini && !!keyState.openai;\n}\n\nfunction hasCompletedApiSetup() {\n  return hasBothApiKeys() || (onboardingKeysConfirmed && hasAnyApiKey());\n}\n\nfunction hasStoredLicense() {\n  return !!(licenseState && licenseState.key && isLicenseValid(licenseState));\n}\n\nfunction updateOnboardingVisibility() {\n  const section = document.querySelector('[data-section=\"onboarding\"]');\n  if (!section) return;\n  if (!licenseLoaded || !keysLoaded || !onboardingKeysLoaded) return;\n  const shouldShow = !hasStoredLicense() || !hasCompletedApiSetup();\n  section.classList.toggle(\"is-hidden\", !shouldShow);\n  if (shouldShow && section.classList.contains(SECTION_HIDDEN_CLASS)) {\n    hiddenSections.delete(\"onboarding\");\n    updateHiddenSections(Array.from(hiddenSections));\n  }\n}\n\nfunction setModelGate(provider, hasKey) {\n  const isGemini = provider === PROVIDERS.GEMINI;\n  const modelEl = el(isGemini ? \"geminiModel\" : \"openaiModel\");\n  const effortEl = el(isGemini ? \"geminiReasoningEffort\" : \"openaiReasoningEffort\");\n  const gateEl = el(isGemini ? \"geminiModelGate\" : \"openaiModelGate\");\n  const disabled = !hasKey;\n  if (modelEl) modelEl.disabled = disabled;\n  if (effortEl) effortEl.disabled = disabled;\n  if (gateEl) gateEl.classList.toggle(\"is-hidden\", !disabled);\n}\n\nfunction updateConfigProviderGate() {\n  const geminiBtn = el(\"providerGemini\");\n  const openaiBtn = el(\"providerOpenAI\");\n  const hasGemini = !!keyState.gemini;\n  const hasOpenAI = !!keyState.openai;\n\n  if (geminiBtn) geminiBtn.disabled = !hasGemini;\n  if (openaiBtn) openaiBtn.disabled = !hasOpenAI;\n\n  const gateEl = el(\"configProviderGate\");\n  if (!gateEl) return;\n  const textEl = el(\"configProviderGateText\");\n\n  let message = \"\";\n  if (!hasGemini && !hasOpenAI) {\n    message = \"Ajoutez une cl API pour activer Gemini ou OpenAI.\";\n  }\n\n  gateEl.classList.toggle(\"is-hidden\", !message);\n  if (textEl) textEl.textContent = message;\n}\n\nfunction updateModelGates() {\n  setModelGate(PROVIDERS.GEMINI, !!keyState.gemini);\n  setModelGate(PROVIDERS.OPENAI, !!keyState.openai);\n  updateConfigProviderGate();\n}\n\nfunction parseLicenseExpiryMs(expiresAt) {\n  const raw = String(expiresAt || \"\").trim();\n  if (!raw) return 0;\n  const ts = Date.parse(raw);\n  return Number.isFinite(ts) ? ts : 0;\n}\n\nfunction formatLicenseExpiry(expiresAt) {\n  const ts = parseLicenseExpiryMs(expiresAt);\n  if (!ts) return \"\";\n  return formatDate(ts);\n}\n\nfunction licenseStatusSummary(license) {\n  if (!license || !license.key) {\n    return { ok: false, text: \"Aucune licence\" };\n  }\n\n  if (isLicenseValid(license)) {\n    const expiry = formatLicenseExpiry(license.expiresAt);\n    const suffix = expiry ? `  renouvellement le ${expiry}` : \"\";\n    return { ok: true, text: `Licence active${suffix}` };\n  }\n\n  const expiresAt = parseLicenseExpiryMs(license.expiresAt);\n  const expired = expiresAt && expiresAt <= Date.now();\n  return { ok: false, text: expired ? \"Licence expire\" : \"Licence invalide\" };\n}\n\nfunction setLicenseStatus(node, text, ok) {\n  if (!node) return;\n  node.textContent = text || \"\";\n  node.title = text || \"\";\n  node.setAttribute(\"aria-label\", text || \"\");\n  node.classList.toggle(\"key-status--ok\", ok);\n  node.classList.toggle(\"key-status--missing\", !ok);\n}\n\nfunction setLicenseStatusAll(text, ok) {\n  document.querySelectorAll(LICENSE_STATUS_SELECTOR).forEach((node) => {\n    setLicenseStatus(node, text, ok);\n  });\n}\n\nfunction updateLicenseStatusNodes(license) {\n  const summary = licenseStatusSummary(license);\n  document.querySelectorAll(LICENSE_STATUS_SELECTOR).forEach((node) => {\n    setLicenseStatus(node, summary.text, summary.ok);\n  });\n}\n\nfunction setLicenseEntryVisible(isVisible, options = {}) {\n  const { focus = false, persist = true } = options;\n  const entry = el(\"licenseEntry\");\n  const subscribe = el(\"licenseSubscribe\");\n  if (!entry) return;\n  entry.classList.toggle(\"is-hidden\", !isVisible);\n  if (persist) licenseEntryChoice = isVisible;\n  if (subscribe) subscribe.classList.toggle(\"is-hidden\", isVisible);\n  const subscribeBtn = el(\"licenseModeSubscribe\");\n  const haveBtn = el(\"licenseModeHave\");\n  if (subscribeBtn && haveBtn) {\n    subscribeBtn.classList.toggle(\"segmented__btn--active\", !isVisible);\n    haveBtn.classList.toggle(\"segmented__btn--active\", isVisible);\n    subscribeBtn.setAttribute(\"aria-selected\", !isVisible ? \"true\" : \"false\");\n    haveBtn.setAttribute(\"aria-selected\", isVisible ? \"true\" : \"false\");\n  }\n  if (isVisible && focus) {\n    const input = el(\"licenseKeyInput\");\n    if (input) input.focus();\n  }\n}\n\nfunction updateLicensePlaceholders(license) {\n  const placeholder = license?.key ? \"Cl enregistre (laisser vide pour conserver)\" : LICENSE_PLACEHOLDER;\n  document.querySelectorAll(LICENSE_INPUT_SELECTOR).forEach((input) => {\n    input.placeholder = placeholder;\n  });\n}\n\nfunction updateLicenseMeta(license) {\n  const nodes = document.querySelectorAll(LICENSE_META_SELECTOR);\n  if (!nodes.length) return;\n  let text = \"Cl reue par email aprs achat (mensuel ou annuel)\";\n  if (license && isLicenseValid(license) && license.expiresAt) {\n    const expiry = formatLicenseExpiry(license.expiresAt);\n    text = expiry ? `Renouvellement le ${expiry}` : \"Licence active\";\n  } else if (license && !isLicenseValid(license)) {\n    const expiry = formatLicenseExpiry(license.expiresAt);\n    text = expiry ? `Licence expire le ${expiry}` : \"Licence invalide\";\n  }\n  nodes.forEach((meta) => {\n    meta.textContent = text;\n  });\n}\n\nfunction updateLicenseStepVisibility(license = licenseState) {\n  const step = el(\"setupLicenseStep\");\n  if (!step) return;\n  const shouldHide = !!(license && isLicenseValid(license));\n  step.classList.toggle(\"is-hidden\", shouldHide);\n}\n\nfunction updateKeyStepVisibility() {\n  updateOnboardingKeyCardVisibility();\n  const step = el(\"setupKeysStep\");\n  if (!step) return;\n  const shouldHide = hasBothApiKeys();\n  step.classList.toggle(\"is-hidden\", shouldHide);\n}\n\nfunction updateOnboardingKeyCardVisibility() {\n  const geminiCard = document.querySelector('[data-onboarding-key-card=\"gemini\"]');\n  const openaiCard = document.querySelector('[data-onboarding-key-card=\"openai\"]');\n  if (geminiCard) geminiCard.classList.toggle(\"is-hidden\", !!keyState.gemini);\n  if (openaiCard) openaiCard.classList.toggle(\"is-hidden\", !!keyState.openai);\n}\n\nasync function refreshLicenseUI(options = {}) {\n  const { silent = false } = options;\n  const stored = await getStoredLicense();\n  licenseState = stored;\n  licenseLoaded = true;\n  updateLicenseStatusNodes(stored);\n  const autoVisible = !!(stored && stored.key && !isLicenseValid(stored));\n  const shouldShow = licenseEntryChoice === null ? autoVisible : licenseEntryChoice;\n  setLicenseEntryVisible(shouldShow, { persist: false });\n  updateLicensePlaceholders(stored);\n  updateLicenseMeta(stored);\n  updateLicenseStepVisibility(stored);\n  updateOnboardingVisibility();\n  if (!silent && stored && isLicenseValid(stored)) {\n    setStatus(\"Licence active\", { expiresAt: stored.expiresAt || \"n/a\" });\n  }\n}\n\nfunction clampExp(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return TOKEN_EXP_MIN;\n  return Math.min(TOKEN_EXP_MAX, Math.max(TOKEN_EXP_MIN, Math.round(n)));\n}\n\nfunction expToTokens(exp) {\n  const tokens = 2 ** clampExp(exp);\n  return Math.min(tokens, MAX_OUTPUT_TOKENS);\n}\n\nfunction tokensToExp(tokens) {\n  const n = Number(tokens);\n  if (!Number.isFinite(n) || n <= 0) return TOKEN_EXP_MIN;\n  return clampExp(Math.log2(n));\n}\n\nfunction updateProviderBadge(provider) {\n  const badge = el(\"configProviderBadge\");\n  if (!badge) return;\n  const label = PROVIDER_LABELS[provider] || (provider ? provider.toUpperCase() : \"\");\n  badge.textContent = label;\n  badge.title = `Fournisseur: ${label}`;\n  badge.setAttribute(\"aria-label\", `Fournisseur: ${label}`);\n}\n\nfunction setProviderButtons(provider) {\n  const isGemini = provider === PROVIDERS.GEMINI;\n  el(\"providerGemini\").classList.toggle(\"segmented__btn--active\", isGemini);\n  el(\"providerOpenAI\").classList.toggle(\"segmented__btn--active\", !isGemini);\n  el(\"providerGemini\").setAttribute(\"aria-pressed\", isGemini ? \"true\" : \"false\");\n  el(\"providerOpenAI\").setAttribute(\"aria-pressed\", !isGemini ? \"true\" : \"false\");\n  updateProviderBadge(provider);\n  updateGeminiExplicitSectionVisibility();\n  if (isGemini) {\n    void refreshGeminiExplicitCachesGuarded({ force: true });\n  }\n}\n\nfunction getSelectedProvider() {\n  const geminiActive = el(\"providerGemini\").classList.contains(\"segmented__btn--active\");\n  return geminiActive ? PROVIDERS.GEMINI : PROVIDERS.OPENAI;\n}\n\nfunction updateMaxTokensValue() {\n  const exp = clampExp(el(\"maxTokensRange\").value);\n  const tokens = expToTokens(exp);\n  el(\"maxTokensValue\").textContent = formatNumber(tokens);\n  return tokens;\n}\n\nfunction clampConcurrencyIndex(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return 0;\n  return Math.max(0, Math.min(CONCURRENCY_LEVELS.length - 1, Math.round(n)));\n}\n\nfunction concurrencyIndexToValue(index) {\n  return CONCURRENCY_LEVELS[clampConcurrencyIndex(index)];\n}\n\nfunction concurrencyValueToIndex(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return 0;\n  let bestIndex = 0;\n  let bestDiff = Math.abs(CONCURRENCY_LEVELS[0] - n);\n  for (let i = 1; i < CONCURRENCY_LEVELS.length; i += 1) {\n    const diff = Math.abs(CONCURRENCY_LEVELS[i] - n);\n    if (diff < bestDiff) {\n      bestDiff = diff;\n      bestIndex = i;\n    }\n  }\n  return bestIndex;\n}\n\nfunction updateConcurrencyValue() {\n  const index = clampConcurrencyIndex(el(\"concurrencyRange\").value);\n  const value = concurrencyIndexToValue(index);\n  el(\"concurrencyValue\").textContent = formatNumber(value);\n  return value;\n}\n\nfunction normalizeRpmLimitInput(value) {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return DEFAULTS.rpmLimit;\n  return Math.max(RPM_MIN, Math.min(RPM_MAX, Math.round(n)));\n}\n\nfunction updateRpmLimitValue() {\n  const input = el(\"rpmLimitInput\");\n  if (!input) return DEFAULTS.rpmLimit;\n  const value = normalizeRpmLimitInput(input.value);\n  input.value = String(value);\n  return value;\n}\n\nfunction activateTab(tab) {\n  const isGemini = tab === \"gemini\";\n  el(\"tabGemini\").classList.toggle(\"tab--active\", isGemini);\n  el(\"tabOpenAI\").classList.toggle(\"tab--active\", !isGemini);\n\n  el(\"tabGemini\").setAttribute(\"aria-selected\", isGemini ? \"true\" : \"false\");\n  el(\"tabOpenAI\").setAttribute(\"aria-selected\", !isGemini ? \"true\" : \"false\");\n\n  el(\"panelGemini\").classList.toggle(\"tab-panel--active\", isGemini);\n  el(\"panelOpenAI\").classList.toggle(\"tab-panel--active\", !isGemini);\n  const providerWrap = el(\"settingsProvider\");\n  if (providerWrap) {\n    providerWrap.dataset.activeProvider = isGemini ? \"gemini\" : \"openai\";\n  }\n}\n\nasync function refreshUI(options = {}) {\n  const { preserveKeyInputs = false, silent = false } = options;\n  const storageBackend = el(\"storageBackend\");\n  if (storageBackend) storageBackend.textContent = storageBackendName();\n\n  const [\n    provider,\n    maxTok,\n    concurrencyLimit,\n    rpmLimit,\n    gemModel,\n    oaiModel,\n    gemKeyPresent,\n    oaiKeyPresent,\n    gemReasoningEffort,\n    oaiReasoningEffort,\n    keysConfirmed\n  ] = await Promise.all([\n    getDefaultProvider(),\n    getMaxOutputTokens(),\n    getConcurrencyLimit(),\n    getRpmLimit(),\n    getModel(PROVIDERS.GEMINI),\n    getModel(PROVIDERS.OPENAI),\n    hasApiKey(PROVIDERS.GEMINI),\n    hasApiKey(PROVIDERS.OPENAI),\n    getGeminiReasoningEffort(),\n    getOpenAIReasoningEffort(),\n    getOnboardingKeysConfirmed()\n  ]);\n\n  setProviderButtons(provider);\n\n  const exp = tokensToExp(maxTok);\n  const normalizedTokens = expToTokens(exp);\n  el(\"maxTokensRange\").value = String(exp);\n  el(\"maxTokensValue\").textContent = formatNumber(normalizedTokens);\n  if (normalizedTokens !== maxTok) {\n    await setMaxOutputTokens(normalizedTokens);\n  }\n\n  const concurrencyIndex = concurrencyValueToIndex(concurrencyLimit);\n  const normalizedConcurrency = concurrencyIndexToValue(concurrencyIndex);\n  el(\"concurrencyRange\").value = String(concurrencyIndex);\n  el(\"concurrencyValue\").textContent = formatNumber(normalizedConcurrency);\n  if (normalizedConcurrency !== concurrencyLimit) {\n    await setConcurrencyLimit(normalizedConcurrency);\n  }\n\n  const normalizedRpm = normalizeRpmLimitInput(rpmLimit);\n  rpmLimitValue = normalizedRpm;\n  const rpmInput = el(\"rpmLimitInput\");\n  if (rpmInput) {\n    rpmInput.value = String(normalizedRpm);\n    if (normalizedRpm !== rpmLimit) {\n      await setRpmLimit(normalizedRpm);\n    }\n  }\n\n  // Models\n  const geminiModelEl = el(\"geminiModel\");\n  const openaiModelEl = el(\"openaiModel\");\n  populateModelSelect(PROVIDERS.GEMINI, geminiModelEl, gemModel);\n  populateModelSelect(PROVIDERS.OPENAI, openaiModelEl, oaiModel);\n  const selectedGeminiModel = geminiModelEl ? geminiModelEl.value : gemModel;\n  const selectedOpenAIModel = openaiModelEl ? openaiModelEl.value : oaiModel;\n  const safeGeminiEffort = syncGeminiReasoningEffort(selectedGeminiModel, gemReasoningEffort);\n  if (safeGeminiEffort && safeGeminiEffort !== gemReasoningEffort) {\n    await setGeminiReasoningEffort(safeGeminiEffort);\n  }\n  const safeEffort = syncOpenAIReasoningEffort(selectedOpenAIModel, oaiReasoningEffort);\n  const effectiveEffort = safeEffort || oaiReasoningEffort;\n  if (safeEffort && safeEffort !== oaiReasoningEffort) {\n    await setOpenAIReasoningEffort(safeEffort);\n  }\n\n  updateModelWarningBadge(PROVIDERS.GEMINI, selectedGeminiModel);\n  updateModelWarningBadge(PROVIDERS.OPENAI, selectedOpenAIModel);\n\n  // Keys are not displayed back (security / UX). Use placeholder to indicate presence.\n  if (!preserveKeyInputs) {\n    document.querySelectorAll(KEY_INPUT_SELECTOR).forEach((input) => {\n      input.value = \"\";\n    });\n  }\n\n  setKeyState(gemKeyPresent, oaiKeyPresent);\n  onboardingKeysConfirmed = !!keysConfirmed;\n  onboardingKeysLoaded = true;\n  if (!gemKeyPresent && !oaiKeyPresent && keysConfirmed) {\n    onboardingKeysConfirmed = false;\n    await setOnboardingKeysConfirmed(false);\n  }\n  keysLoaded = true;\n\n  setKeyStatus(PROVIDERS.GEMINI, gemKeyPresent);\n  setKeyStatus(PROVIDERS.OPENAI, oaiKeyPresent);\n  updateModelGates();\n  updateKeyStepVisibility();\n  updateOnboardingVisibility();\n\n  if (!silent) {\n    setStatus(\"Configuration charge\", {\n      defaultProvider: provider,\n      maxOutputTokens: normalizedTokens,\n      gemini: { key: gemKeyPresent ? \"set\" : \"missing\", model: gemModel, reasoningEffort: safeGeminiEffort },\n      openai: { key: oaiKeyPresent ? \"set\" : \"missing\", model: oaiModel, reasoningEffort: effectiveEffort }\n    });\n  }\n}\n\nfunction buildBreakdownRow(label, tokens, cost, isSub) {\n  const row = document.createElement(\"div\");\n  row.className = `breakdown__row ${isSub ? \"breakdown__row--sub\" : \"breakdown__row--total\"}`;\n\n  const name = document.createElement(\"div\");\n  name.className = \"breakdown__name\";\n  if (isSub) {\n    const model = document.createElement(\"span\");\n    model.className = \"breakdown__model\";\n    model.textContent = label;\n    name.appendChild(model);\n  } else {\n    name.textContent = label;\n  }\n\n  const tokensEl = document.createElement(\"div\");\n  tokensEl.className = \"breakdown__tokens\";\n  tokensEl.textContent = `${formatNumber(tokens)} tokens`;\n\n  const costEl = document.createElement(\"div\");\n  costEl.className = \"breakdown__cost\";\n  costEl.textContent = formatCost(cost);\n\n  row.appendChild(name);\n  row.appendChild(tokensEl);\n  row.appendChild(costEl);\n  return row;\n}\n\nfunction renderUsageBreakdown(breakdown) {\n  const container = el(\"usageBreakdown\");\n  if (!container) return;\n  container.innerHTML = \"\";\n\n  const providers = [PROVIDERS.GEMINI, PROVIDERS.OPENAI];\n  for (const provider of providers) {\n    const data = breakdown[provider] || { tokens: 0, cost: 0, models: new Map() };\n    container.appendChild(buildBreakdownRow(PROVIDER_LABELS[provider] || provider, data.tokens, data.cost, false));\n\n    const models = Array.from(data.models.values())\n      .filter((model) => (model.tokens || 0) > 0 || (model.cost || 0) > 0)\n      .sort((a, b) => b.tokens - a.tokens || a.label.localeCompare(b.label));\n\n    for (const model of models) {\n      container.appendChild(buildBreakdownRow(model.label, model.tokens, model.cost, true));\n    }\n  }\n}\n\nfunction formatQueueStatusText(total) {\n  const n = Number(total);\n  if (!Number.isFinite(n) || n <= 0) return \"\";\n  return `${formatNumber(n)} requete${n > 1 ? \"s\" : \"\"} en cours`;\n}\n\nfunction formatRpmStatusText(count, limit) {\n  const n = Number(count);\n  if (!Number.isFinite(n) || n <= 0) return \"\";\n  const lim = Number(limit);\n  if (Number.isFinite(lim) && lim > 0) {\n    return `RPM ${formatNumber(n)}/${formatNumber(lim)}`;\n  }\n  return `RPM ${formatNumber(n)}`;\n}\n\nfunction applyRuntimeStatus(status) {\n  const container = el(\"queueStatus\");\n  if (!container) return;\n  const active = Number(status?.active || 0);\n  const queued = Number(status?.queued || 0);\n  const total = Math.max(0, active) + Math.max(0, queued);\n  const rpm = Number(status?.rpm || 0);\n  const showQueue = total > 0;\n  const showRpm = rpm > 0;\n\n  const main = el(\"queueStatusMain\");\n  if (main) main.classList.toggle(\"is-hidden\", !showQueue);\n  const rpmEl = el(\"rpmStatus\");\n  if (rpmEl) rpmEl.classList.toggle(\"is-hidden\", !showRpm);\n\n  if (!showQueue && !showRpm) {\n    container.classList.add(\"is-hidden\");\n    return;\n  }\n  container.classList.remove(\"is-hidden\");\n\n  const textEl = el(\"queueStatusText\");\n  if (textEl) textEl.textContent = formatQueueStatusText(total);\n  const rpmTextEl = el(\"rpmStatusText\");\n  if (rpmTextEl) rpmTextEl.textContent = formatRpmStatusText(rpm, rpmLimitValue);\n  const stopBtn = el(\"queueStop\");\n  if (stopBtn) stopBtn.classList.toggle(\"is-hidden\", queued <= 0);\n}\n\nasync function refreshRuntimeStatus() {\n  const status = await getRuntimeStatus();\n  applyRuntimeStatus(status);\n}\n\nasync function refreshUsage() {\n  const rawLogs = await getRequestLog({ fresh: true });\n  const logs = rawLogs.map(normalizeUsageEntry).sort((a, b) => b.ts - a.ts);\n  lastUsageLogs = logs;\n\n  const usageTotals = await getUsageTotals({ fresh: true });\n  const { total, breakdown } = buildUsageFromTotals(usageTotals);\n\n  el(\"usageTokensTotal\").textContent = formatNumber(total.inputTokens + total.reasoningTokens + total.outputTokens);\n  el(\"usageTokensInTotal\").textContent = formatNumber(total.inputTokens);\n  el(\"usageTokensCacheTotal\").textContent = formatNumber(total.cachedInputTokens);\n  el(\"usageTokensReasoningTotal\").textContent = formatNumber(total.reasoningTokens);\n  el(\"usageTokensOutTotal\").textContent = formatNumber(total.outputTokens);\n  el(\"usageCostTotal\").textContent = formatCostTotal(total.cost);\n  const summary = el(\"usageSummary\");\n  if (summary) summary.textContent = formatCostTotal(total.cost);\n  el(\"usageCostGemini\").textContent = formatCostTotal(total.byProvider.gemini.cost);\n  el(\"usageCostOpenAI\").textContent = formatCostTotal(total.byProvider.openai.cost);\n\n  renderUsageBreakdown(breakdown);\n  renderLogList(logs);\n}\n\nfunction isDocumentHidden() {\n  try {\n    return typeof document !== \"undefined\" && document.hidden;\n  } catch {\n    return false;\n  }\n}\n\nlet refreshUsagePromise = null;\nlet refreshCachePromise = null;\nlet refreshRuntimePromise = null;\n\nasync function refreshUsageGuarded(options = {}) {\n  const { force = false } = options;\n  if (!force && isDocumentHidden()) return;\n  if (refreshUsagePromise) return refreshUsagePromise;\n  refreshUsagePromise = (async () => {\n    await refreshUsage();\n  })();\n  try {\n    return await refreshUsagePromise;\n  } finally {\n    refreshUsagePromise = null;\n  }\n}\n\nasync function refreshCacheStatsGuarded(options = {}) {\n  const { force = false } = options;\n  if (!force && isDocumentHidden()) return;\n  if (refreshCachePromise) return refreshCachePromise;\n  refreshCachePromise = (async () => {\n    await refreshCacheStats();\n  })();\n  try {\n    return await refreshCachePromise;\n  } finally {\n    refreshCachePromise = null;\n  }\n}\n\nasync function refreshRuntimeStatusGuarded(options = {}) {\n  const { force = false } = options;\n  if (!force && isDocumentHidden()) return;\n  if (refreshRuntimePromise) return refreshRuntimePromise;\n  refreshRuntimePromise = (async () => {\n    await refreshRuntimeStatus();\n  })();\n  try {\n    return await refreshRuntimePromise;\n  } finally {\n    refreshRuntimePromise = null;\n  }\n}\n\nfunction getTokenHeatClass(tokensTotal) {\n  const n = Number(tokensTotal || 0);\n  if (n >= 8000) return \"token-heat--extreme\";\n  if (n >= 4000) return \"token-heat--hot\";\n  if (n >= 1500) return \"token-heat--warm\";\n  return \"token-heat--cool\";\n}\n\nfunction logEntryKey(entry) {\n  if (entry?.batch && entry?.batchId) {\n    return `batch:${entry.batchId}`;\n  }\n  const formulaText = entry.call || entry.formula || \"\";\n  return [entry.ts || 0, entry.fn || \"\", entry.provider || \"\", entry.model || \"\", formulaText].join(\"|\");\n}\n\nfunction updateLogFilterUI() {\n  const filterBtn = el(\"logFilterErrors\");\n  if (!filterBtn) return;\n  filterBtn.classList.toggle(\"is-active\", logErrorsOnly);\n  filterBtn.setAttribute(\"aria-pressed\", logErrorsOnly ? \"true\" : \"false\");\n}\n\nfunction filterLogEntries(logs) {\n  if (!logErrorsOnly) return logs;\n  return logs.filter((entry) => !entry.ok);\n}\n\nfunction renderLogList(logs) {\n  const list = el(\"logList\");\n  list.innerHTML = \"\";\n\n  const filteredLogs = filterLogEntries(logs || []);\n\n  if (!filteredLogs.length) {\n    const empty = document.createElement(\"div\");\n    empty.className = \"log-item log-item--empty\";\n    empty.textContent = logErrorsOnly\n      ? \"Aucune erreur enregistre pour le moment\"\n      : \"Aucune activit enregistre pour le moment\";\n    list.appendChild(empty);\n    return;\n  }\n\n  const buildTokenFlow = (iconText, value) => {\n    const wrap = document.createElement(\"span\");\n    wrap.className = \"token-flow\";\n\n    const icon = document.createElement(\"span\");\n    icon.className = \"token-flow__icon\";\n    icon.textContent = iconText;\n\n    const val = document.createElement(\"span\");\n    val.className = \"token-flow__value\";\n    val.textContent = formatNumber(value);\n\n    wrap.appendChild(icon);\n    wrap.appendChild(val);\n    return wrap;\n  };\n\n  const slice = filteredLogs.slice(0, 40);\n  const activeKeys = new Set();\n  for (const entry of slice) {\n    const item = document.createElement(\"div\");\n    const cacheClass = entry.cache ? \" log-item--cache\" : \"\";\n    const batchClass = entry.batch ? \" log-item--batch\" : \"\";\n    item.className = `log-item ${entry.ok ? \"log-item--ok\" : \"log-item--error\"}${cacheClass}${batchClass}`;\n\n    const top = document.createElement(\"div\");\n    top.className = \"log-item__top\";\n\n    const title = document.createElement(\"div\");\n    title.className = \"log-item__title\";\n\n    const titleText = document.createElement(\"span\");\n    titleText.className = \"log-item__title-text\";\n    titleText.textContent = entry.fn;\n    title.appendChild(titleText);\n\n    const formulaText = String(entry.call || entry.formula || \"\").trim();\n    let detail = null;\n    if (formulaText) {\n      const entryKey = logEntryKey(entry);\n      activeKeys.add(entryKey);\n      const toggle = document.createElement(\"button\");\n      toggle.className = \"log-item__toggle\";\n      toggle.type = \"button\";\n      toggle.setAttribute(\"aria-expanded\", \"false\");\n      toggle.setAttribute(\"aria-label\", \"Afficher la fonction\");\n\n      const chevron = document.createElement(\"span\");\n      chevron.className = \"log-item__chevron\";\n      toggle.appendChild(chevron);\n\n      const wasExpanded = expandedLogKeys.has(entryKey);\n      if (wasExpanded) {\n        item.classList.add(\"log-item--expanded\");\n        toggle.setAttribute(\"aria-expanded\", \"true\");\n        toggle.setAttribute(\"aria-label\", \"Masquer la fonction\");\n      }\n\n      toggle.addEventListener(\"click\", () => {\n        const isOpen = item.classList.toggle(\"log-item--expanded\");\n        toggle.setAttribute(\"aria-expanded\", isOpen ? \"true\" : \"false\");\n        toggle.setAttribute(\"aria-label\", isOpen ? \"Masquer la fonction\" : \"Afficher la fonction\");\n        if (isOpen) expandedLogKeys.add(entryKey);\n        else expandedLogKeys.delete(entryKey);\n      });\n\n      title.appendChild(toggle);\n\n      detail = document.createElement(\"div\");\n      detail.className = \"log-item__detail\";\n      detail.textContent = formulaText;\n    }\n\n    const tags = document.createElement(\"div\");\n    tags.style.display = \"flex\";\n    tags.style.gap = \"6px\";\n\n    const providerTag = document.createElement(\"span\");\n    providerTag.className = \"tag\";\n    providerTag.textContent = entry.batch ? \"BATCH\" : (entry.provider ? entry.provider.toUpperCase() : \"\");\n    tags.appendChild(providerTag);\n\n    const costTag = document.createElement(\"span\");\n    costTag.className = \"tag tag--cost\";\n    costTag.textContent = formatCostCents(estimateCost(entry));\n    costTag.title = \"Cot estim (centimes)\";\n    tags.appendChild(costTag);\n\n    if (entry.batch) {\n      const batchTag = document.createElement(\"span\");\n      batchTag.className = \"tag tag--cache\";\n      batchTag.textContent = \"Lot\";\n      tags.appendChild(batchTag);\n    } else if (entry.cache) {\n      const cacheTag = document.createElement(\"span\");\n      cacheTag.className = \"tag tag--cache\";\n      cacheTag.textContent = \"Cache\";\n      tags.appendChild(cacheTag);\n    }\n\n    const isGemini = isGeminiProvider(entry.provider);\n    const hasGeminiCache = isGemini && (entry.cacheHint === \"gemini_cached_content\" || Number(entry.cachedInputTokens || 0) > 0);\n    if (hasGeminiCache) {\n      const gemCacheTag = document.createElement(\"span\");\n      gemCacheTag.className = \"tag tag--cache\";\n      gemCacheTag.textContent = \"Cache Gemini\";\n      tags.appendChild(gemCacheTag);\n    }\n\n    top.appendChild(title);\n    top.appendChild(tags);\n\n    const meta = document.createElement(\"div\");\n    meta.className = \"log-item__meta\";\n\n    const tokensTotal = Math.max(0, getDisplayTokensTotal(entry));\n    const modelLabel = entry.batch ? \"\" : (entry.model ? entry.model : \"\");\n    const effortLabel = entry.reasoningEffort ? entry.reasoningEffort : \"\";\n    const durationLabel = formatDuration(entry.ms);\n    const modelEffortLabel = [modelLabel, effortLabel].filter(Boolean).join(\"  \");\n\n    const right = document.createElement(\"div\");\n    right.className = \"log-item__info\";\n    const baseMeta = `${formatTime(entry.ts)}  ${durationLabel}`;\n    const detailMeta = modelEffortLabel ? `  ${modelEffortLabel}` : \"\";\n    if (entry.batch && entry.batchStats) {\n      const stats = entry.batchStats;\n      const parts = [\n        `Lot ${formatNumber(stats.totalRequests)} req`,\n        `Err ${formatNumber(stats.error)}`\n      ];\n      if (stats.cached) parts.push(`Cache ${formatNumber(stats.cached)}`);\n      if (stats.avgMs) parts.push(`Moy ${formatDuration(stats.avgMs)}`);\n      if (stats.peakQueued) parts.push(`Pic file ${formatNumber(stats.peakQueued)}`);\n      if (stats.peakActive) parts.push(`Pic actif ${formatNumber(stats.peakActive)}`);\n      right.textContent = `${baseMeta}${detailMeta}  ${parts.join(\"  \")}`;\n    } else if (!entry.ok && entry.message) {\n      right.textContent = `${baseMeta}${detailMeta}  ${entry.message.slice(0, 60)}`;\n    } else {\n      right.textContent = `${baseMeta}${detailMeta}`;\n    }\n\n    if (entry.cache) {\n      const cacheNote = document.createElement(\"div\");\n      cacheNote.className = \"log-item__cache\";\n      cacheNote.textContent = \"Cache local\";\n      meta.appendChild(cacheNote);\n    } else {\n      const tokensWrap = document.createElement(\"div\");\n      tokensWrap.className = \"log-item__tokens\";\n\n      const tokensLine = document.createElement(\"div\");\n      tokensLine.className = \"log-item__tokens-line\";\n\n      const heatDot = document.createElement(\"span\");\n      heatDot.className = `log-item__heat ${getTokenHeatClass(tokensTotal)}`;\n\n      const tokensTotalEl = document.createElement(\"span\");\n      tokensTotalEl.className = \"log-item__tokens-total\";\n      tokensTotalEl.textContent = `${formatNumber(tokensTotal)} tokens`;\n\n      const tokensDetailEl = document.createElement(\"span\");\n      tokensDetailEl.className = \"log-item__tokens-detail\";\n      tokensDetailEl.appendChild(document.createTextNode(\"(\"));\n      tokensDetailEl.appendChild(buildTokenFlow(TOKEN_IN_ICON, getDisplayInputTokens(entry)));\n      tokensDetailEl.appendChild(document.createTextNode(\" / \"));\n      tokensDetailEl.appendChild(buildTokenFlow(TOKEN_REASON_ICON, entry.reasoningTokens));\n      tokensDetailEl.appendChild(document.createTextNode(\" / \"));\n      tokensDetailEl.appendChild(buildTokenFlow(TOKEN_OUT_ICON, entry.outputTokens));\n      if (shouldShowCacheTokens(entry)) {\n        tokensDetailEl.appendChild(document.createTextNode(\" / \"));\n        tokensDetailEl.appendChild(buildTokenFlow(TOKEN_CACHE_ICON, entry.cachedInputTokens));\n      }\n      tokensDetailEl.appendChild(document.createTextNode(\")\"));\n\n      tokensLine.appendChild(heatDot);\n      tokensLine.appendChild(tokensTotalEl);\n      tokensLine.appendChild(tokensDetailEl);\n      tokensWrap.appendChild(tokensLine);\n      meta.appendChild(tokensWrap);\n    }\n\n    meta.appendChild(right);\n\n    item.appendChild(top);\n    if (detail) item.appendChild(detail);\n    item.appendChild(meta);\n    list.appendChild(item);\n  }\n\n  expandedLogKeys.forEach((key) => {\n    if (!activeKeys.has(key)) expandedLogKeys.delete(key);\n  });\n}\n\nfunction updatePrivacyModeUI(enabled) {\n  privacyModeEnabled = !!enabled;\n  const toggle = el(\"privacyModeToggle\");\n  if (toggle) toggle.checked = privacyModeEnabled;\n\n  const status = el(\"privacyModeStatus\");\n  if (status) {\n    status.textContent = privacyModeEnabled ? \"Activ\" : \"Dsactiv\";\n    status.classList.toggle(\"is-active\", privacyModeEnabled);\n  }\n\n  const hint = el(\"privacyModeHint\");\n  if (hint) {\n    hint.textContent = privacyModeEnabled\n      ? \"Journal et cache persistants dsactivs.\"\n      : \"Journal et cache persistants activs.\";\n  }\n\n  const cacheStatus = el(\"cacheStatus\");\n  if (cacheStatus) {\n    const cacheEnabled = !privacyModeEnabled;\n    cacheStatus.classList.toggle(\"status-dot--on\", cacheEnabled);\n    cacheStatus.classList.toggle(\"status-dot--off\", !cacheEnabled);\n    cacheStatus.setAttribute(\"aria-label\", cacheEnabled ? \"Cache actif\" : \"Cache dsactiv\");\n    cacheStatus.setAttribute(\"title\", cacheEnabled ? \"Cache actif\" : \"Cache dsactiv\");\n  }\n}\n\nasync function refreshPrivacyMode() {\n  const enabled = await getPrivacyMode();\n  updatePrivacyModeUI(enabled);\n}\n\nasync function initPrivacyMode() {\n  const toggle = el(\"privacyModeToggle\");\n  if (!toggle) return;\n  await refreshPrivacyMode();\n  toggle.addEventListener(\"change\", async () => {\n    const next = !!toggle.checked;\n    await setPrivacyMode(next);\n    updatePrivacyModeUI(next);\n    if (next) {\n      await clearRequestLog();\n      await clearAllCaches();\n    }\n    await refreshUsageGuarded({ force: true });\n    await refreshCacheStatsGuarded({ force: true });\n    setStatus(next ? \"Mode confidentialit activ\" : \"Mode confidentialit dsactiv\", { privacyMode: next });\n  });\n}\n\nasync function refreshCacheStats() {\n  const stats = await getPersistentCacheStats();\n  const entriesEl = el(\"cacheEntries\");\n  if (entriesEl) entriesEl.textContent = formatNumber(stats.entries);\n  const sizeEl = el(\"cacheSize\");\n  if (sizeEl) sizeEl.textContent = formatBytes(stats.sizeBytes);\n  const geminiEl = el(\"cacheGeminiEntries\");\n  if (geminiEl) geminiEl.textContent = formatNumber(stats.providers.gemini.entries);\n  const openaiEl = el(\"cacheOpenAIEntries\");\n  if (openaiEl) openaiEl.textContent = formatNumber(stats.providers.openai.entries);\n}\n\nfunction parseIsoTimestamp(value) {\n  const raw = String(value || \"\").trim();\n  if (!raw) return 0;\n  const parsed = Date.parse(raw);\n  return Number.isFinite(parsed) ? parsed : 0;\n}\n\nfunction extractCacheTokenCount(meta) {\n  if (!meta || typeof meta !== \"object\") return 0;\n  const candidates = [\n    meta.cachedContentTokenCount,\n    meta.cached_content_token_count,\n    meta.totalTokenCount,\n    meta.total_token_count,\n    meta.promptTokenCount,\n    meta.prompt_token_count\n  ];\n  for (const value of candidates) {\n    const n = Number(value);\n    if (Number.isFinite(n) && n > 0) return Math.floor(n);\n  }\n  return 0;\n}\n\nfunction buildExplicitCacheRow(cache) {\n  const name = String(cache?.name || \"\").trim();\n  const displayName = String(cache?.displayName || cache?.display_name || \"\").trim();\n  const model = String(cache?.model || \"\").trim();\n  const usageMeta = cache?.usageMetadata || cache?.usage_metadata || null;\n  const tokenCount = extractCacheTokenCount(usageMeta);\n  const createdAt = parseIsoTimestamp(cache?.createTime || cache?.create_time);\n  const updatedAt = parseIsoTimestamp(cache?.updateTime || cache?.update_time);\n  const expireAt = parseIsoTimestamp(cache?.expireTime || cache?.expire_time);\n\n  const item = document.createElement(\"div\");\n  item.className = \"explicit-cache__item\";\n\n  const main = document.createElement(\"div\");\n  main.className = \"explicit-cache__main\";\n\n  const title = document.createElement(\"div\");\n  title.className = \"explicit-cache__title\";\n  title.textContent = displayName || (name ? \"Cache Gemini\" : \"Cache\");\n\n  const meta = document.createElement(\"div\");\n  meta.className = \"explicit-cache__meta\";\n  const parts = [];\n  if (model) parts.push(model.replace(\"models/\", \"\"));\n  if (tokenCount > 0) parts.push(`${formatNumber(tokenCount)} tokens`);\n  if (createdAt) parts.push(`Cr ${formatDateTime(createdAt)}`);\n  if (expireAt) parts.push(`Expire ${formatDateTime(expireAt)}`);\n  if (!expireAt && updatedAt) parts.push(`MAJ ${formatDateTime(updatedAt)}`);\n  meta.textContent = parts.join(\"  \");\n\n  const nameEl = document.createElement(\"div\");\n  nameEl.className = \"explicit-cache__name\";\n  nameEl.textContent = name;\n\n  main.appendChild(title);\n  if (parts.length) main.appendChild(meta);\n  if (name) main.appendChild(nameEl);\n\n  const actions = document.createElement(\"div\");\n  actions.className = \"explicit-cache__actions\";\n  const deleteBtn = document.createElement(\"button\");\n  deleteBtn.className = \"explicit-cache__delete\";\n  deleteBtn.type = \"button\";\n  deleteBtn.textContent = \"Supprimer\";\n  deleteBtn.dataset.cacheName = name;\n  actions.appendChild(deleteBtn);\n\n  item.appendChild(main);\n  item.appendChild(actions);\n  return item;\n}\n\nlet refreshGeminiExplicitPromise = null;\n\nfunction updateGeminiExplicitSectionVisibility() {\n  const section = document.querySelector('[data-section=\"gemini-explicit\"]');\n  if (!section) return;\n  const geminiSelected = getSelectedProvider() === PROVIDERS.GEMINI;\n  if (!geminiSelected) {\n    section.classList.add(\"is-hidden\");\n    return;\n  }\n  // Keep section available whenever Gemini is active, even if empty.\n  const shouldHide = false;\n  section.classList.toggle(\"is-hidden\", shouldHide);\n}\n\nasync function refreshGeminiExplicitCaches() {\n  if (getSelectedProvider() !== PROVIDERS.GEMINI) {\n    updateGeminiExplicitSectionVisibility();\n    return;\n  }\n\n  const listEl = el(\"geminiExplicitList\");\n  const emptyEl = el(\"geminiExplicitEmpty\");\n  const summaryEl = el(\"geminiExplicitSummary\");\n  if (!listEl || !emptyEl || !summaryEl) return;\n\n  listEl.innerHTML = \"\";\n  emptyEl.textContent = \"Chargement...\";\n  emptyEl.classList.remove(\"is-hidden\");\n  summaryEl.textContent = \"0 cache\";\n\n  const result = await listGeminiCachedContents({ pageSize: 50, all: true, maxPages: 3 });\n  if (!result.ok) {\n    emptyEl.textContent = result.message || \"Impossible de rcuprer les caches Gemini.\";\n    updateGeminiExplicitSectionVisibility();\n    return;\n  }\n\n  const caches = Array.isArray(result.caches) ? result.caches : [];\n  summaryEl.textContent = `${formatNumber(caches.length)} cache${caches.length > 1 ? \"s\" : \"\"}`;\n\n  if (!caches.length) {\n    emptyEl.textContent = \"Aucun cache explicite actif.\";\n    updateGeminiExplicitSectionVisibility();\n    return;\n  }\n\n  emptyEl.classList.add(\"is-hidden\");\n  updateGeminiExplicitSectionVisibility();\n  for (const cache of caches) {\n    listEl.appendChild(buildExplicitCacheRow(cache));\n  }\n\n  listEl.querySelectorAll(\".explicit-cache__delete\").forEach((btn) => {\n    btn.addEventListener(\"click\", async () => {\n      const name = btn.dataset.cacheName || \"\";\n      if (!name) return;\n      btn.disabled = true;\n      const res = await deleteGeminiCachedContent(name);\n      if (!res.ok) {\n        showToast(res.message || \"Suppression impossible.\");\n      } else {\n        showToast(\"Cache supprim\");\n      }\n      await refreshGeminiExplicitCachesGuarded({ force: true });\n    });\n  });\n}\n\nasync function refreshGeminiExplicitCachesGuarded(options = {}) {\n  const { force = false } = options;\n  if (!force && isDocumentHidden()) return;\n  if (refreshGeminiExplicitPromise) return refreshGeminiExplicitPromise;\n  refreshGeminiExplicitPromise = (async () => {\n    await refreshGeminiExplicitCaches();\n  })();\n  try {\n    return await refreshGeminiExplicitPromise;\n  } finally {\n    refreshGeminiExplicitPromise = null;\n  }\n}\n\nasync function saveCommon(options = {}) {\n  const { silent = false, message = \"Configuration enregistre\" } = options;\n  const provider = getSelectedProvider();\n  const exp = clampExp(el(\"maxTokensRange\").value);\n  const maxTok = expToTokens(exp);\n\n  const savedProvider = await setDefaultProvider(provider);\n  const savedTokens = await setMaxOutputTokens(maxTok);\n\n  if (!silent) {\n    setStatus(message, { defaultProvider: savedProvider, maxOutputTokens: savedTokens });\n  }\n\n  return { savedProvider, savedTokens };\n}\n\nasync function saveConcurrency(options = {}) {\n  const { silent = false, message = \"Concurrence enregistre\" } = options;\n  const value = updateConcurrencyValue();\n  const saved = await setConcurrencyLimit(value);\n  if (!silent) {\n    setStatus(message, { concurrency: saved });\n  }\n  return saved;\n}\n\nasync function saveRpmLimit(options = {}) {\n  const { silent = false, message = \"Limite RPM enregistre\" } = options;\n  const value = updateRpmLimitValue();\n  const saved = await setRpmLimit(value);\n  rpmLimitValue = saved;\n  if (!silent) {\n    setStatus(message, { rpmLimit: saved });\n  }\n  return saved;\n}\n\nfunction initCollapsibles() {\n  const toggles = document.querySelectorAll(\"[data-collapse-toggle]\");\n  toggles.forEach((btn) => {\n    const targetId = btn.getAttribute(\"aria-controls\");\n    const container = btn.closest(\"[data-collapsible]\");\n    if (!targetId || !container) return;\n    const body = document.getElementById(targetId);\n    if (!body) return;\n\n    const collapsed = container.classList.contains(\"is-collapsed\");\n    btn.setAttribute(\"aria-expanded\", collapsed ? \"false\" : \"true\");\n\n    btn.addEventListener(\"click\", () => {\n      const nextCollapsed = !container.classList.contains(\"is-collapsed\");\n      container.classList.toggle(\"is-collapsed\", nextCollapsed);\n      btn.setAttribute(\"aria-expanded\", nextCollapsed ? \"false\" : \"true\");\n    });\n  });\n}\n\nfunction openOnboardingSection(options = {}) {\n  const { focusKey = false } = options;\n  const section = document.querySelector('[data-section=\"onboarding\"]');\n  if (!section) return;\n  section.classList.remove(\"is-hidden\");\n  if (section.classList.contains(SECTION_HIDDEN_CLASS)) {\n    hiddenSections.delete(\"onboarding\");\n    updateHiddenSections(Array.from(hiddenSections));\n  }\n  if (section.classList.contains(\"is-collapsed\")) {\n    section.classList.remove(\"is-collapsed\");\n    const toggle = section.querySelector(\"[data-collapse-toggle]\");\n    if (toggle) toggle.setAttribute(\"aria-expanded\", \"true\");\n  }\n  if (typeof section.scrollIntoView === \"function\") {\n    section.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n  }\n  if (focusKey) {\n    const input = section.querySelector(KEY_INPUT_SELECTOR);\n    if (input) input.focus();\n  }\n}\n\nfunction attachStorageListeners() {\n  let queued = false;\n  const triggerRefresh = () => {\n    if (queued) return;\n    queued = true;\n    setTimeout(async () => {\n      queued = false;\n      await refreshInterfaceMode({ silent: true });\n      await refreshUsageGuarded();\n      await refreshCacheStatsGuarded();\n      await refreshRuntimeStatusGuarded();\n      await refreshPrivacyMode();\n      await refreshLicenseUI({ silent: true });\n    }, 250);\n  };\n\n  try {\n    if (typeof OfficeRuntime !== \"undefined\" && OfficeRuntime?.storage?.onChanged) {\n      const onChanged = OfficeRuntime.storage.onChanged;\n      if (typeof onChanged.add === \"function\") onChanged.add(() => triggerRefresh());\n      else if (typeof onChanged.addListener === \"function\") onChanged.addListener(() => triggerRefresh());\n      else if (typeof onChanged === \"function\") onChanged(() => triggerRefresh());\n    }\n  } catch {\n    // ignore\n  }\n\n  try {\n    window.addEventListener(\"storage\", () => triggerRefresh());\n  } catch {\n    // ignore\n  }\n}\n\nfunction closeAllHelpPopups() {\n  document.querySelectorAll(HELP_SELECTOR).forEach((help) => {\n    help.classList.remove(\"is-open\");\n    const btn = help.querySelector(\"button\");\n    if (btn) btn.setAttribute(\"aria-expanded\", \"false\");\n  });\n}\n\nfunction initHelpPopups() {\n  document.querySelectorAll(HELP_SELECTOR).forEach((help) => {\n    const btn = help.querySelector(\"button\");\n    if (!btn) return;\n    btn.setAttribute(\"aria-expanded\", \"false\");\n    btn.addEventListener(\"click\", (event) => {\n      event.stopPropagation();\n      const wasOpen = help.classList.contains(\"is-open\");\n      closeAllHelpPopups();\n      const nextOpen = !wasOpen;\n      help.classList.toggle(\"is-open\", nextOpen);\n      btn.setAttribute(\"aria-expanded\", nextOpen ? \"true\" : \"false\");\n    });\n  });\n\n  document.addEventListener(\"click\", (event) => {\n    if (event.target.closest(HELP_SELECTOR)) return;\n    closeAllHelpPopups();\n  });\n}\n\nasync function confirmOnboardingKeys(options = {}) {\n  const { silent = false } = options;\n  if (!hasAnyApiKey()) {\n    if (!silent) {\n      setStatus(\"Ajoutez au moins une cl API avant de valider\", { ok: false });\n    }\n    return false;\n  }\n  onboardingKeysConfirmed = true;\n  onboardingKeysLoaded = true;\n  await setOnboardingKeysConfirmed(true);\n  updateOnboardingVisibility();\n  return true;\n}\n\nasync function persistApiKey(provider, value) {\n  const trimmed = (value || \"\").trim();\n  if (!trimmed) return false;\n  await setApiKey(provider, trimmed);\n  keyState[provider] = true;\n  keysLoaded = true;\n  updateKeyPlaceholders();\n  updateModelGates();\n  updateKeyStepVisibility();\n  updateOnboardingVisibility();\n  return true;\n}\n\nasync function saveProviderKey(provider, inputEl) {\n  const key = await persistApiKey(provider, inputEl?.value || \"\");\n  if (!key) return;\n  if (inputEl) inputEl.value = \"\";\n  setKeyStatus(provider, key);\n  setStatus(\"Cl enregistre\", { provider });\n}\n\nasync function saveProviderModel(provider) {\n  const isGemini = provider === PROVIDERS.GEMINI;\n  const modelEl = isGemini ? el(\"geminiModel\") : el(\"openaiModel\");\n  if (!modelEl) return;\n  const newModel = (modelEl.value || \"\").trim();\n  await setModel(provider, newModel);\n\n  let effort = \"\";\n  if (isGemini) {\n    const effortEl = el(\"geminiReasoningEffort\");\n    const rawEffort = effortEl ? effortEl.value : \"\";\n    effort = syncGeminiReasoningEffort(newModel, rawEffort);\n    if (effort) await setGeminiReasoningEffort(effort);\n  } else {\n    const effortEl = el(\"openaiReasoningEffort\");\n    const rawEffort = effortEl ? effortEl.value : \"\";\n    effort = syncOpenAIReasoningEffort(newModel, rawEffort);\n    if (effort) await setOpenAIReasoningEffort(effort);\n  }\n\n  setStatus(\"Configuration enregistre\", {\n    provider,\n    model: newModel,\n    reasoningEffort: effort || undefined\n  });\n\n  updateModelWarningBadge(provider, newModel);\n}\n\nasync function saveGeminiReasoningEffort() {\n  const modelEl = el(\"geminiModel\");\n  const effortEl = el(\"geminiReasoningEffort\");\n  if (!effortEl) return;\n  const label = syncGeminiReasoningEffort(modelEl ? modelEl.value : \"\", effortEl.value);\n  if (label) await setGeminiReasoningEffort(label);\n  setStatus(\"Effort de raisonnement enregistr\", { geminiReasoningEffort: label });\n}\n\nasync function saveOpenAIReasoningEffort() {\n  const modelEl = el(\"openaiModel\");\n  const effortEl = el(\"openaiReasoningEffort\");\n  if (!effortEl) return;\n  const label = syncOpenAIReasoningEffort(modelEl ? modelEl.value : \"\", effortEl.value);\n  if (label) await setOpenAIReasoningEffort(label);\n  setStatus(\"Effort de raisonnement enregistr\", { openaiReasoningEffort: label });\n}\n\nfunction setInputWarning(inputEl, isWarning) {\n  if (!inputEl) return;\n  inputEl.classList.toggle(\"input--warning\", isWarning);\n}\n\nasync function handleLicenseActivate(inputEl, buttonEl) {\n  const key = (inputEl?.value || \"\").trim();\n  setInputWarning(inputEl, false);\n\n  if (!key) {\n    setInputWarning(inputEl, true);\n    setLicenseStatusAll(\"Entrez votre cl de licence\", false);\n    setStatus(\"Cl de licence manquante\", { ok: false });\n    return;\n  }\n\n  const originalLabel = buttonEl?.textContent || \"\";\n  if (buttonEl) {\n    buttonEl.disabled = true;\n    buttonEl.textContent = \"Activation...\";\n  }\n\n  const result = await activateLicense(key);\n\n  if (buttonEl) {\n    buttonEl.disabled = false;\n    buttonEl.textContent = originalLabel;\n  }\n\n  if (result.success) {\n    if (inputEl) inputEl.value = \"\";\n    await refreshLicenseUI({ silent: true });\n    setStatus(\"Licence active\", { expiresAt: result.license?.expiresAt || \"n/a\" });\n    showToast(\"Licence enregistre\");\n    return;\n  }\n\n  const errorText = result.error || \"Cl invalide\";\n  setInputWarning(inputEl, true);\n  setLicenseStatusAll(errorText, false);\n  setStatus(\"chec de l'activation\", { error: errorText });\n}\n\nasync function saveOnboardingKeys() {\n  const geminiInput = el(\"onboardingGeminiKey\");\n  const openaiInput = el(\"onboardingOpenAIKey\");\n\n  const geminiKey = await persistApiKey(PROVIDERS.GEMINI, geminiInput?.value || \"\");\n  const openaiKey = await persistApiKey(PROVIDERS.OPENAI, openaiInput?.value || \"\");\n\n  if (geminiInput) geminiInput.value = \"\";\n  if (openaiInput) openaiInput.value = \"\";\n\n  setKeyStatus(PROVIDERS.GEMINI, keyState.gemini);\n  setKeyStatus(PROVIDERS.OPENAI, keyState.openai);\n\n  if (geminiKey || openaiKey) {\n    setStatus(\"Cls enregistres\", { gemini: !!geminiKey, openai: !!openaiKey });\n  }\n\n  if (keyState.gemini || keyState.openai) {\n    await confirmOnboardingKeys({ silent: true });\n    setOnboardingKeysModalOpen(false);\n  }\n}\n\nasync function dismissOnboarding(markSeen = true) {\n  if (markSeen) await setOnboardingSeen(true);\n  setOnboardingKeysModalOpen(false);\n  setOnboardingModalOpen(false);\n}\n\nasync function maybeShowOnboarding() {\n  const seen = await getOnboardingSeen();\n  if (seen) return;\n  setOnboardingModalOpen(true);\n}\n\nasync function safeOfficeReady() {\n  try {\n    if (typeof Office !== \"undefined\" && Office?.onReady) {\n      await Office.onReady();\n    }\n  } catch {\n    // Running outside Office host (e.g., direct browser open)\n  }\n}\n\nasync function init() {\n  initCollapsibles();\n  attachStorageListeners();\n  initHelpPopups();\n  await initSectionManager();\n  await refreshInterfaceMode({ silent: true });\n  await initPrivacyMode();\n\n  const settingsButton = el(\"settingsButton\");\n  if (settingsButton) {\n    settingsButton.addEventListener(\"click\", () => setSettingsModalOpen(true));\n  }\n\n  document.querySelectorAll(\"[data-settings-open]\").forEach((btn) => {\n    btn.addEventListener(\"click\", () => setSettingsModalOpen(true));\n  });\n\n  document.querySelectorAll(\"[data-settings-close]\").forEach((btn) => {\n    btn.addEventListener(\"click\", () => setSettingsModalOpen(false));\n  });\n\n  document.querySelectorAll(\"[data-interface-mode]\").forEach((btn) => {\n    btn.addEventListener(\"click\", async () => {\n      const nextMode = btn.dataset.interfaceMode || INTERFACE_MODES.ADVANCED;\n      await saveInterfaceMode(nextMode);\n    });\n  });\n\n  const sectionReset = el(\"sectionManagerReset\");\n  if (sectionReset) {\n    sectionReset.addEventListener(\"click\", () => resetSectionOrder());\n  }\n\n  const pricingHelp = el(\"pricingHelp\");\n  if (pricingHelp) {\n    pricingHelp.addEventListener(\"click\", () => openPricingModal());\n  }\n\n  document.querySelectorAll(\"[data-modal-close]\").forEach((btn) => {\n    btn.addEventListener(\"click\", () => closePricingModal());\n  });\n\n  document.querySelectorAll(\"[data-onboarding-close]\").forEach((btn) => {\n    btn.addEventListener(\"click\", async () => dismissOnboarding(true));\n  });\n\n  document.querySelectorAll(\"[data-onboarding-keys-close]\").forEach((btn) => {\n    btn.addEventListener(\"click\", () => setOnboardingKeysModalOpen(false));\n  });\n\n  const onboardingClose = el(\"onboardingClose\");\n  if (onboardingClose) {\n    onboardingClose.addEventListener(\"click\", async () => dismissOnboarding(true));\n  }\n\n  const onboardingDone = el(\"onboardingDone\");\n  if (onboardingDone) {\n    onboardingDone.addEventListener(\"click\", async () => dismissOnboarding(true));\n  }\n\n  const onboardingKeysButton = el(\"onboardingKeysButton\");\n  if (onboardingKeysButton) {\n    onboardingKeysButton.addEventListener(\"click\", async () => {\n      await dismissOnboarding(true);\n      openOnboardingSection({ focusKey: true });\n    });\n  }\n\n  document.querySelectorAll(\"[data-onboarding-open]\").forEach((btn) => {\n    btn.addEventListener(\"click\", () => {\n      setSettingsModalOpen(false);\n      openOnboardingSection({ focusKey: true });\n    });\n  });\n\n  const onboardingKeysSave = el(\"onboardingKeysSave\");\n  if (onboardingKeysSave) {\n    onboardingKeysSave.addEventListener(\"click\", async () => saveOnboardingKeys());\n  }\n\n  const onboardingKeysLater = el(\"onboardingKeysLater\");\n  if (onboardingKeysLater) {\n    onboardingKeysLater.addEventListener(\"click\", () => setOnboardingKeysModalOpen(false));\n  }\n\n  document.addEventListener(\"keydown\", async (e) => {\n    if (e.key !== \"Escape\") return;\n    closeAllHelpPopups();\n    if (isModalOpen(\"onboardingKeysModal\")) {\n      setOnboardingKeysModalOpen(false);\n      return;\n    }\n    if (isModalOpen(\"onboardingModal\")) {\n      await dismissOnboarding(true);\n      return;\n    }\n    if (isModalOpen(\"settingsModal\")) {\n      setSettingsModalOpen(false);\n      return;\n    }\n    if (isModalOpen(\"pricingModal\")) {\n      closePricingModal();\n    }\n  });\n\n  // Tabs\n  el(\"tabGemini\").addEventListener(\"click\", () => activateTab(\"gemini\"));\n  el(\"tabOpenAI\").addEventListener(\"click\", () => activateTab(\"openai\"));\n\n  // Provider selection buttons\n  el(\"providerGemini\").addEventListener(\"click\", async () => {\n    setProviderButtons(PROVIDERS.GEMINI);\n    await saveCommon();\n  });\n\n  el(\"providerOpenAI\").addEventListener(\"click\", async () => {\n    setProviderButtons(PROVIDERS.OPENAI);\n    await saveCommon();\n  });\n\n  // Max tokens slider\n  el(\"maxTokensRange\").addEventListener(\"input\", () => {\n    updateMaxTokensValue();\n  });\n\n  el(\"maxTokensRange\").addEventListener(\"change\", async () => {\n    await saveCommon();\n  });\n\n  // Concurrency slider\n  el(\"concurrencyRange\").addEventListener(\"input\", () => {\n    updateConcurrencyValue();\n  });\n\n  el(\"concurrencyRange\").addEventListener(\"change\", async () => {\n    await saveConcurrency();\n  });\n\n  const rpmInput = el(\"rpmLimitInput\");\n  if (rpmInput) {\n    rpmInput.addEventListener(\"change\", async () => {\n      await saveRpmLimit();\n    });\n  }\n\n  const geminiEffortEl = el(\"geminiReasoningEffort\");\n  if (geminiEffortEl) {\n    geminiEffortEl.addEventListener(\"input\", () => {\n      const modelEl = el(\"geminiModel\");\n      syncGeminiReasoningEffort(modelEl ? modelEl.value : \"\", geminiEffortEl.value);\n    });\n    geminiEffortEl.addEventListener(\"change\", async () => {\n      await saveGeminiReasoningEffort();\n    });\n  }\n\n  const effortEl = el(\"openaiReasoningEffort\");\n  if (effortEl) {\n    effortEl.addEventListener(\"input\", () => {\n      const allowNone = effortEl.dataset.allowNone !== \"0\";\n      let label = getReasoningEffortLabel(effortEl.value);\n      if (!allowNone && label === \"none\") {\n        effortEl.value = \"1\";\n        label = getReasoningEffortLabel(effortEl.value);\n      }\n      effortEl.setAttribute(\"aria-valuetext\", label);\n    });\n    effortEl.addEventListener(\"change\", async () => {\n      await saveOpenAIReasoningEffort();\n    });\n  }\n\n  const geminiModelEl = el(\"geminiModel\");\n  if (geminiModelEl) {\n    geminiModelEl.addEventListener(\"change\", async () => {\n      await saveProviderModel(PROVIDERS.GEMINI);\n    });\n  }\n\n  const openaiModelEl = el(\"openaiModel\");\n  if (openaiModelEl) {\n    openaiModelEl.addEventListener(\"change\", async () => {\n      await saveProviderModel(PROVIDERS.OPENAI);\n    });\n  }\n\n  document.querySelectorAll(KEY_INPUT_SELECTOR).forEach((input) => {\n    const provider = String(input.dataset.keyInput || \"\").trim().toLowerCase();\n    if (!provider) return;\n    input.addEventListener(\"input\", () => setInputWarning(input, false));\n    input.addEventListener(\"change\", async () => {\n      await saveProviderKey(provider, input);\n    });\n    input.addEventListener(\"keydown\", (event) => {\n      if (event.key !== \"Enter\") return;\n      event.preventDefault();\n      const actionBtn = input.closest(\".input-action\")?.querySelector(KEY_SAVE_SELECTOR);\n      if (actionBtn) actionBtn.click();\n      else void saveProviderKey(provider, input);\n    });\n  });\n\n  document.querySelectorAll(KEY_SAVE_SELECTOR).forEach((btn) => {\n    const provider = String(btn.dataset.keySave || \"\").trim().toLowerCase();\n    if (!provider) return;\n    btn.addEventListener(\"click\", async () => {\n      const input = btn.closest(\".input-action\")?.querySelector(KEY_INPUT_SELECTOR);\n      await saveProviderKey(provider, input);\n      if (btn.dataset.keyConfirm === \"true\") {\n        await confirmOnboardingKeys();\n      }\n    });\n  });\n\n  const licenseModeSubscribe = el(\"licenseModeSubscribe\");\n  const licenseModeHave = el(\"licenseModeHave\");\n  if (licenseModeSubscribe) {\n    licenseModeSubscribe.addEventListener(\"click\", () => setLicenseEntryVisible(false));\n  }\n  if (licenseModeHave) {\n    licenseModeHave.addEventListener(\"click\", () => setLicenseEntryVisible(true, { focus: true }));\n  }\n\n  document.querySelectorAll(LICENSE_INPUT_SELECTOR).forEach((input) => {\n    input.addEventListener(\"input\", () => setInputWarning(input, false));\n    input.addEventListener(\"keydown\", (event) => {\n      if (event.key !== \"Enter\") return;\n      event.preventDefault();\n      const targetBtn =\n        document.querySelector(`[data-license-activate][data-license-target=\"${input.id}\"]`) ||\n        input.closest(\".input-action, .setup-license__row\")?.querySelector(\"[data-license-activate]\");\n      if (targetBtn) {\n        void handleLicenseActivate(input, targetBtn);\n      }\n    });\n  });\n\n  document.querySelectorAll(\"[data-license-activate]\").forEach((btn) => {\n    btn.addEventListener(\"click\", async () => {\n      const targetId = btn.dataset.licenseTarget;\n      const input =\n        (targetId ? el(targetId) : null) ||\n        btn.closest(\".input-action, .setup-license__row\")?.querySelector(LICENSE_INPUT_SELECTOR);\n      await handleLicenseActivate(input, btn);\n    });\n  });\n\n  const clearUsageBtn = el(\"clearUsageTotals\");\n  if (clearUsageBtn) {\n    clearUsageBtn.addEventListener(\"click\", async () => {\n      await clearUsageTotals();\n      await refreshUsageGuarded({ force: true });\n      setStatus(\"Utilisation rinitialise\", { ok: true });\n    });\n  }\n\n  const logFilterErrors = el(\"logFilterErrors\");\n  if (logFilterErrors) {\n    logFilterErrors.addEventListener(\"click\", () => {\n      logErrorsOnly = !logErrorsOnly;\n      updateLogFilterUI();\n      renderLogList(lastUsageLogs);\n    });\n  }\n  updateLogFilterUI();\n\n  el(\"clearLogs\").addEventListener(\"click\", async () => {\n    await clearRequestLog();\n    await refreshUsageGuarded({ force: true });\n    setStatus(\"Journal effac\", { ok: true });\n  });\n\n  el(\"clearCache\").addEventListener(\"click\", async () => {\n    await clearAllCaches();\n    await refreshCacheStatsGuarded({ force: true });\n    setStatus(\"Cache vid\", { ok: true });\n  });\n\n  const queueStop = el(\"queueStop\");\n  if (queueStop) {\n    queueStop.addEventListener(\"click\", async () => {\n      stopQueuedRequests();\n      await refreshRuntimeStatusGuarded({ force: true });\n    });\n  }\n\n  // Default tab\n  activateTab(\"gemini\");\n\n  await refreshUI();\n  await refreshLicenseUI({ silent: true });\n  await refreshUsageGuarded({ force: true });\n  await refreshCacheStatsGuarded({ force: true });\n  await refreshGeminiExplicitCachesGuarded({ force: true });\n  await refreshRuntimeStatusGuarded({ force: true });\n  await maybeShowOnboarding();\n\n  const scheduleRefresh = () => {\n    void refreshUsageGuarded();\n    void refreshCacheStatsGuarded();\n    void refreshGeminiExplicitCachesGuarded();\n    void refreshRuntimeStatusGuarded();\n  };\n\n  document.addEventListener(\"visibilitychange\", () => {\n    if (!isDocumentHidden()) scheduleRefresh();\n  });\n\n  setInterval(() => void refreshUsageGuarded(), 2000);\n  setInterval(() => void refreshCacheStatsGuarded(), 12000);\n  setInterval(() => void refreshGeminiExplicitCachesGuarded(), 15000);\n  setInterval(() => void refreshRuntimeStatusGuarded(), 1000);\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n  await safeOfficeReady();\n  await init();\n});\n"],"names":["PROVIDERS","Object","freeze","GEMINI","OPENAI","DEFAULTS","provider","geminiModel","openaiModel","geminiReasoningEffort","openaiReasoningEffort","maxOutputTokens","concurrencyLimit","rpmLimit","interfaceMode","retry","timeoutMs","cache","cacheTtlSec","STORAGE_KEYS","DEFAULT_PROVIDER","GEMINI_API_KEY","OPENAI_API_KEY","GEMINI_MODEL","OPENAI_MODEL","GEMINI_REASONING_EFFORT","OPENAI_REASONING_EFFORT","MAX_OUTPUT_TOKENS","CONCURRENCY_LIMIT","RPM_LIMIT","INTERFACE_MODE","ONBOARDING_SEEN","ONBOARDING_KEYS_CONFIRMED","SECTION_ORDER","SECTION_HIDDEN","LICENSE","PRIVACY_MODE","MIGRATION_DONE","REQUEST_LOG","REQUEST_LOG_CLEAR_AT","USAGE_TOTALS","CACHE_INDEX","CACHE_CLEAR_AT","RUNTIME_STATUS","SENSITIVE_KEYS","Set","LEGACY_KEYS","DEFAULT_PROVIDER_V2","GEMINI_API_KEY_V2","OPENAI_API_KEY_V2","GEMINI_MODEL_V2","OPENAI_MODEL_V2","GEMINI_MAX_TOKENS_V2","OPENAI_MAX_TOKENS_V2","_migrationPromise","_officeStorageFailed","_privacyModeCache","_privacyModeCacheAt","SETTINGS_CACHE_TTL_MS","_defaultProviderCache","_defaultProviderCacheAt","_maxOutputTokensCache","_maxOutputTokensCacheAt","_geminiReasoningCache","_geminiReasoningCacheAt","_openaiReasoningCache","_openaiReasoningCacheAt","_interfaceModeCache","_interfaceModeCacheAt","_apiKeyCache","gemini","openai","_apiKeyCacheAt","_modelCache","_modelCacheAt","markOfficeStorageFailed","MEMORY_STORAGE","kind","storage","mem","Map","async","getItem","k","has","get","setItem","v","set","String","removeItem","delete","getRuntimeStorage","OfficeRuntime","window","localStorage","getLocalStorageSafe","localGet","local","key","localSet","value","localRemove","rawGet","options","sensitive","isSensitiveKey","allowLocalFallback","result","localValue","rawSet","stored","rawRemove","removed","ensureMigrated","normalizeProvider","legacyProvider","legacy","candidates","map","x","parseInt","trim","filter","n","Number","isFinite","migrated","length","Math","max","p","s","toLowerCase","normalizeInterfaceMode","mode","GEMINI_REASONING_EFFORTS","OPENAI_REASONING_EFFORTS","normalizeGeminiReasoningEffort","normalizeReasoningEffort","getDefaultProvider","now","nowMs","keyKey","getApiKey","trimmed","hasApiKey","modelKey","getModel","cached","raw","resolved","getGeminiReasoningEffort","getOpenAIReasoningEffort","setOpenAIReasoningEffort","setGeminiReasoningEffort","getMaxOutputTokens","clampInt","setMaxOutputTokens","CONCURRENCY_OPTIONS","normalizeConcurrencyLimit","base","includes","best","bestDiff","abs","option","slice","diff","getConcurrencyLimit","setConcurrencyLimit","normalized","normalizeRpmLimit","getRpmLimit","setRpmLimit","getOnboardingKeysConfirmed","setOnboardingKeysConfirmed","confirmed","normalizeRuntimeStatus","active","queued","rpm","ts","MAX_SAFE_INTEGER","setRuntimeStatus","status","JSON","stringify","getPrivacyMode","enabled","loadPrivacyMode","normalizeSectionList","Array","isArray","out","seen","item","add","push","setHiddenSections","list","Date","min","fallback","REDACT_PATTERNS","redactSensitiveText","text","pattern","replace","redactSensitiveValue","entry","entries","parseTimestampMs","CACHE_INDEX_MAX_BYTES","_cacheClearMs","loadCacheIndex","arr","parse","removeCacheEntry","REQUEST_LOG_TTL_MS","Infinity","_requestLog","_requestLogLoading","_requestLogLoaded","_requestLogLastLoadedMs","_requestLogClearMs","_logBuffer","_logFlushTimer","_logFlushPromise","_usageTotals","createEmptyUsageTotals","_usageTotalsLoading","_usageTotalsLoaded","_usageTotalsLastLoadedMs","_usageTotalsDirty","syncRequestLogClearMarker","clearedAt","reset","isErrorLogEntry","ok","loadRequestLog","force","normal","errors","concat","coerceRequestLogArray","e","parsed","sanitizeLogEntry","pruneRequestLog","valid","normals","sort","a","b","pruned","toNonNegInt","floor","toNonNegNumber","inputTokens","outputTokens","reasoningTokens","cachedInputTokens","cacheStorageTokenHours","requests","batchApplied","byProvider","models","pruneBatchApplied","loadUsageTotals","batchId","normalizedModels","model","label","normalizeBatchApplied","providers","rawProvider","target","rawModels","normalizeUsageTotals","applyUsageTotalsFromEntry","batch","batchModels","currentModels","modelLabel","mapKey","existing","touched","values","applyUsageDelta","previous","keys","curr","prev","delta","hasUsageDelta","providerTotals","flushLogBuffer","usageTouched","idx","findIndex","REQUEST_LOG_MAX_PER_TYPE","persistRequestLog","persistUsageTotals","clearRequestLog","clearTimeout","CACHE","constructor","maxEntries","this","expiresAtMs","ttlMs","size","oldestKey","next","clear","GEMINI_CACHED_CONTENT","QUEUE_CANCELLED","Symbol","rpmWindow","Promise","resolve","queue","_items","_head","shift","drain","pending","statusTimer","pendingStatus","lastStatusKey","getRpmCount","cutoff","pruneRpmWindow","isNonEmptyString","extractGeminiError","json","msg","error","message","clearAllCaches","index","clearPersistentCache","fetchWithTimeout","url","t","AbortController","fetch","ctrl","id","setTimeout","abort","signal","safeJson","res","POSITIVE_INFINITY","INSTANCE_NAME","normalizeKey","normalizeExpiresAt","toISOString","extractError","data","first","detail","title","getStoredLicense","instanceId","instanceName","expiresAt","activatedAt","lastCheckedAt","normalizeLicense","getLicense","isLicenseValid","license","activateLicense","success","endpoint","payload","formData","FormData","forEach","append","response","method","body","postLicense","license_key","instance_name","activated","overrides","instance","instance_id","name","expires_at","buildLicense","setLicense","el","document","getElementById","setStatus","line","detailsObj","statusLine","statusDetails","safeLine","textContent","safeDetails","showToast","duration","toast","classList","toastTimer","remove","formatNumber","round","toLocaleString","CURRENCY_SYMBOL","formatCostTotal","toFixed","formatCostCents","cents","isGeminiProvider","isCacheAdjustedEntry","cacheAdjusted","fn","shouldShowCacheTokens","getDisplayInputTokens","getDisplayTokensTotal","splitInputTokensForCost","uncachedInputTokens","formatDuration","ms","formatTime","toLocaleTimeString","hour","minute","formatDateTime","year","month","day","INTERFACE_MODES","SIMPLE","ADVANCED","setCollapsedState","section","collapsed","toggle","querySelector","setAttribute","applyInterfaceMode","silent","simple","dataset","simpleBtn","advancedBtn","updateInterfaceModeButtons","modeHint","settingsSubtitle","configSubtitle","usageSubtitle","providerLabel","maxTokensLabel","updateInterfaceModeCopy","closeAllHelpPopups","refreshInterfaceMode","getInterfaceMode","getSectionKey","isSectionLocked","sectionLocked","applySectionOrder","order","sectionMain","settingsCard","SECTION_SETTINGS_SELECTOR","sectionElements","insertBefore","appendChild","applySectionVisibility","hidden","locked","shouldHide","SECTION_HIDDEN_CLASS","pruneHiddenSections","changed","from","hiddenSections","updateSectionOrder","nextOrder","persist","sectionOrder","renderSectionManager","setSectionOrder","updateHiddenSections","nextHidden","updateOnboardingVisibility","moveSection","indexOf","nextIdx","splice","clearDragState","querySelectorAll","row","innerHTML","sectionTitle","getSectionTitle","visible","createElement","className","sectionKey","handle","type","draggable","labelEl","controls","upBtn","disabled","addEventListener","downBtn","toggleWrap","toggleInput","checked","toggleSlider","lockTag","CONCURRENCY_LEVELS","GEMINI_REASONING_LEVELS","OPENAI_REASONING_LEVELS","HELP_SELECTOR","SECTION_SELECTOR","KEY_INPUT_SELECTOR","KEY_SAVE_SELECTOR","LICENSE_INPUT_SELECTOR","LICENSE_STATUS_SELECTOR","keyState","licenseState","licenseEntryChoice","keysLoaded","licenseLoaded","onboardingKeysConfirmed","onboardingKeysLoaded","privacyModeEnabled","defaultSectionOrder","draggingSectionKey","expandedLogKeys","logErrorsOnly","lastUsageLogs","rpmLimitValue","DEFAULT_MODELS","MODEL_CATALOG","prices","input","output","cachedInput","costLevel","reasoningLevel","warning","recommended","supportsReasoningNone","MODEL_LOOKUP","m","PROVIDER_LABELS","repeatIcon","icon","level","count","join","getModelMeta","syncGeminiReasoningEffort","modelId","preferred","effortEl","allowed","getGeminiAllowedReasoningLevels","getReasoningEffortLabel","levels","bestDist","optIdx","dist","coerceReasoningLabel","syncOpenAIReasoningEffort","allowNone","meta","openaiModelAllowsNone","wrap","closest","formatRate","decimals","modelIndicators","cost","reasoning","modelOptionLabel","indicators","favorite","updateModelWarningBadge","isGemini","selectEl","warningEl","show","estimateCost","billableOutputTokens","reduce","sum","billableCachedInputTokens","coerceCount","coerceFloat","normalizeUsageEntry","batchStats","totalRequests","avgMs","maxMs","minMs","peakQueued","peakActive","totalTokens","reasoningEffort","call","formula","cacheHint","batchLive","populateModelSelect","currentModel","requested","requestedKey","matched","style","color","fontWeight","selected","setModalOpen","isOpen","modal","isModalOpen","contains","setSettingsModalOpen","settingsPage","focus","setPricingModalOpen","setOnboardingModalOpen","setOnboardingKeysModalOpen","closePricingModal","setKeyStatus","hasKey","node","updateKeyPlaceholders","keyInput","placeholder","hasAnyApiKey","hasBothApiKeys","shouldShow","setModelGate","modelEl","gateEl","updateModelGates","geminiBtn","openaiBtn","hasGemini","hasOpenAI","textEl","updateConfigProviderGate","parseLicenseExpiryMs","formatLicenseExpiry","toLocaleDateString","formatDate","setLicenseStatus","setLicenseStatusAll","setLicenseEntryVisible","isVisible","subscribe","subscribeBtn","haveBtn","updateKeyStepVisibility","geminiCard","openaiCard","updateOnboardingKeyCardVisibility","step","refreshLicenseUI","summary","expiry","licenseStatusSummary","updateLicenseStatusNodes","autoVisible","updateLicensePlaceholders","nodes","updateLicenseMeta","updateLicenseStepVisibility","clampExp","expToTokens","exp","tokens","setProviderButtons","badge","toUpperCase","updateProviderBadge","updateGeminiExplicitSectionVisibility","refreshGeminiExplicitCachesGuarded","getSelectedProvider","clampConcurrencyIndex","concurrencyIndexToValue","updateConcurrencyValue","normalizeRpmLimitInput","activateTab","tab","providerWrap","activeProvider","buildBreakdownRow","isSub","tokensEl","costEl","formatCost","refreshRuntimeStatus","container","total","showQueue","showRpm","main","rpmEl","formatQueueStatusText","rpmTextEl","limit","lim","formatRpmStatusText","stopBtn","applyRuntimeStatus","getRuntimeStatus","refreshUsage","logs","fresh","getRequestLog","usageTotals","cloneUsageTotals","getUsageTotals","breakdown","totals","safeTotals","providerSums","providerTokens","providerCost","modelStorageSum","modelInput","modelOutput","modelReasoning","modelCached","modelCacheStorageTokenHours","rawLabel","isUnknown","modelEntry","missingStorage","buildUsageFromTotals","localeCompare","renderUsageBreakdown","renderLogList","isDocumentHidden","refreshUsagePromise","refreshCachePromise","refreshRuntimePromise","refreshUsageGuarded","refreshCacheStatsGuarded","stats","sizeBytes","oldestMs","newestMs","kept","removedKeys","savedAt","savedAtMs","totalSize","dropCount","pruneCacheIndex","syncCacheClearMarker","saveCacheIndex","getPersistentCacheStats","entriesEl","sizeEl","bytes","formatBytes","geminiEl","openaiEl","refreshCacheStats","refreshRuntimeStatusGuarded","getTokenHeatClass","tokensTotal","logEntryKey","formulaText","updateLogFilterUI","filterBtn","filteredLogs","filterLogEntries","empty","buildTokenFlow","iconText","val","activeKeys","cacheClass","batchClass","top","titleText","entryKey","chevron","tags","display","gap","providerTag","costTag","batchTag","cacheTag","gemCacheTag","effortLabel","durationLabel","modelEffortLabel","Boolean","right","baseMeta","detailMeta","parts","cacheNote","tokensWrap","tokensLine","heatDot","tokensTotalEl","tokensDetailEl","createTextNode","updatePrivacyModeUI","hint","cacheStatus","cacheEnabled","refreshPrivacyMode","parseIsoTimestamp","buildExplicitCacheRow","displayName","display_name","tokenCount","cachedContentTokenCount","cached_content_token_count","totalTokenCount","total_token_count","promptTokenCount","prompt_token_count","extractCacheTokenCount","usageMetadata","usage_metadata","createdAt","createTime","create_time","updatedAt","updateTime","update_time","expireAt","expireTime","expire_time","nameEl","actions","deleteBtn","cacheName","refreshGeminiExplicitPromise","listEl","emptyEl","summaryEl","apiKey","code","pageSize","maxPages","allPages","all","pageToken","pages","caches","URL","searchParams","toString","headers","cachedContents","cachedContent","nextPageToken","listGeminiCachedContents","btn","path","encodeURI","deleteGeminiCachedContent","refreshGeminiExplicitCaches","saveCommon","maxTok","savedProvider","setDefaultProvider","savedTokens","defaultProvider","openOnboardingSection","focusKey","scrollIntoView","behavior","block","help","confirmOnboardingKeys","persistApiKey","setApiKey","saveProviderKey","inputEl","saveProviderModel","newModel","setModel","effort","undefined","setInputWarning","isWarning","handleLicenseActivate","buttonEl","originalLabel","errorText","dismissOnboarding","markSeen","setOnboardingSeen","init","targetId","getAttribute","nextCollapsed","triggerRefresh","onChanged","addListener","attachStorageListeners","event","stopPropagation","wasOpen","nextOpen","sections","storedOrder","getSectionOrder","domKeys","keysInDom","normalizeSectionOrder","getHiddenSections","dataTransfer","effectAllowed","setData","preventDefault","clearDropIndicators","rect","getBoundingClientRect","before","clientY","height","targetKey","draggedKey","targetIndex","insertIndex","reorderSectionList","moveSectionToEnd","initSectionDrag","initSectionManager","setPrivacyMode","privacyMode","initPrivacyMode","settingsButton","nextMode","saved","setInterfaceMode","saveInterfaceMode","sectionReset","pricingHelp","gemBody","oaiBody","renderProvider","cellModel","cellInput","cellOutput","cellCost","cellReason","renderPricingTable","onboardingClose","onboardingDone","onboardingKeysButton","onboardingKeysSave","geminiInput","openaiInput","geminiKey","openaiKey","saveOnboardingKeys","onboardingKeysLater","updateMaxTokensValue","concurrency","saveConcurrency","rpmInput","updateRpmLimitValue","saveRpmLimit","geminiEffortEl","saveGeminiReasoningEffort","saveOpenAIReasoningEffort","geminiModelEl","openaiModelEl","actionBtn","click","keySave","keyConfirm","licenseModeSubscribe","licenseModeHave","targetBtn","licenseTarget","clearUsageBtn","clearUsageTotals","logFilterErrors","queueStop","snapshot","scheduleRuntimeStatusUpdate","stopQueuedRequests","preserveKeyInputs","storageBackend","gemModel","oaiModel","gemKeyPresent","oaiKeyPresent","gemReasoningEffort","oaiReasoningEffort","keysConfirmed","log2","tokensToExp","normalizedTokens","concurrencyIndex","bestIndex","i","concurrencyValueToIndex","normalizedConcurrency","normalizedRpm","selectedGeminiModel","selectedOpenAIModel","safeGeminiEffort","safeEffort","effectiveEffort","refreshUI","getOnboardingSeen","maybeShowOnboarding","setInterval","Office","onReady","safeOfficeReady"],"sourceRoot":""}